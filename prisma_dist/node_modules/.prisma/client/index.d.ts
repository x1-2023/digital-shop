
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductLog
 * 
 */
export type ProductLog = $Result.DefaultSelection<Prisma.$ProductLogPayload>
/**
 * Model ProductLineItem
 * 
 */
export type ProductLineItem = $Result.DefaultSelection<Prisma.$ProductLineItemPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model License
 * 
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ManualDepositRequest
 * 
 */
export type ManualDepositRequest = $Result.DefaultSelection<Prisma.$ManualDepositRequestPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model DownloadLog
 * 
 */
export type DownloadLog = $Result.DefaultSelection<Prisma.$DownloadLogPayload>
/**
 * Model AdminActionLog
 * 
 */
export type AdminActionLog = $Result.DefaultSelection<Prisma.$AdminActionLogPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model WebsiteSettings
 * 
 */
export type WebsiteSettings = $Result.DefaultSelection<Prisma.$WebsiteSettingsPayload>
/**
 * Model AutoTopupLog
 * 
 */
export type AutoTopupLog = $Result.DefaultSelection<Prisma.$AutoTopupLogPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model UserActivityLog
 * 
 */
export type UserActivityLog = $Result.DefaultSelection<Prisma.$UserActivityLogPayload>
/**
 * Model TwoFactorAccount
 * 
 */
export type TwoFactorAccount = $Result.DefaultSelection<Prisma.$TwoFactorAccountPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Advertisement
 * 
 */
export type Advertisement = $Result.DefaultSelection<Prisma.$AdvertisementPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model ErrorReport
 * 
 */
export type ErrorReport = $Result.DefaultSelection<Prisma.$ErrorReportPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model FeaturedUser
 * 
 */
export type FeaturedUser = $Result.DefaultSelection<Prisma.$FeaturedUserPayload>
/**
 * Model SearchKeyword
 * 
 */
export type SearchKeyword = $Result.DefaultSelection<Prisma.$SearchKeywordPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  BUYER: 'BUYER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const LicenseStatus: {
  NEW: 'NEW',
  ISSUED: 'ISSUED',
  REVOKED: 'REVOKED'
};

export type LicenseStatus = (typeof LicenseStatus)[keyof typeof LicenseStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  EXPIRED: 'EXPIRED',
  REVIEW_REQUIRED: 'REVIEW_REQUIRED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentMethod: {
  WALLET: 'WALLET'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentProvider: {
  MANUAL: 'MANUAL',
  TPBANK: 'TPBANK',
  MOMO: 'MOMO',
  CRYPTO: 'CRYPTO'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const DepositStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type DepositStatus = (typeof DepositStatus)[keyof typeof DepositStatus]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const WalletTransactionType: {
  DEPOSIT: 'DEPOSIT',
  PURCHASE: 'PURCHASE',
  REFUND: 'REFUND',
  ADMIN_ADJUST: 'ADMIN_ADJUST',
  REFERRAL_REWARD: 'REFERRAL_REWARD'
};

export type WalletTransactionType = (typeof WalletTransactionType)[keyof typeof WalletTransactionType]


export const AutoTopupStatus: {
  SUCCESS: 'SUCCESS',
  INVALID: 'INVALID',
  FAILED: 'FAILED'
};

export type AutoTopupStatus = (typeof AutoTopupStatus)[keyof typeof AutoTopupStatus]


export const ErrorReportStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type ErrorReportStatus = (typeof ErrorReportStatus)[keyof typeof ErrorReportStatus]


export const ProductLineStatus: {
  NORMAL: 'NORMAL',
  ERROR_REPORTED: 'ERROR_REPORTED',
  REPLACED: 'REPLACED',
  WARRANTY_REJECTED: 'WARRANTY_REJECTED'
};

export type ProductLineStatus = (typeof ProductLineStatus)[keyof typeof ProductLineStatus]


export const AdType: {
  GOOGLE_ADSENSE: 'GOOGLE_ADSENSE',
  HTML_EMBED: 'HTML_EMBED',
  IMAGE_BANNER: 'IMAGE_BANNER',
  VIDEO: 'VIDEO'
};

export type AdType = (typeof AdType)[keyof typeof AdType]


export const AdPlacement: {
  SIDEBAR_LEFT: 'SIDEBAR_LEFT',
  SIDEBAR_RIGHT: 'SIDEBAR_RIGHT',
  BETWEEN_PRODUCTS: 'BETWEEN_PRODUCTS',
  HEADER: 'HEADER',
  FOOTER: 'FOOTER'
};

export type AdPlacement = (typeof AdPlacement)[keyof typeof AdPlacement]


export const SystemLogAction: {
  USER_REGISTER: 'USER_REGISTER',
  USER_LOGIN: 'USER_LOGIN',
  USER_LOGOUT: 'USER_LOGOUT',
  DEPOSIT_CREATE: 'DEPOSIT_CREATE',
  DEPOSIT_APPROVE: 'DEPOSIT_APPROVE',
  DEPOSIT_REJECT: 'DEPOSIT_REJECT',
  DEPOSIT_AUTO: 'DEPOSIT_AUTO',
  ORDER_CREATE: 'ORDER_CREATE',
  ORDER_PAID: 'ORDER_PAID',
  ORDER_CANCELLED: 'ORDER_CANCELLED',
  WALLET_CREDIT: 'WALLET_CREDIT',
  WALLET_DEBIT: 'WALLET_DEBIT',
  WALLET_ADJUST: 'WALLET_ADJUST',
  PRODUCT_PURCHASE: 'PRODUCT_PURCHASE',
  PRODUCT_DOWNLOAD: 'PRODUCT_DOWNLOAD',
  ADMIN_LOGIN: 'ADMIN_LOGIN',
  ADMIN_SETTINGS_UPDATE: 'ADMIN_SETTINGS_UPDATE',
  REFERRAL_SIGNUP: 'REFERRAL_SIGNUP',
  REFERRAL_REWARD: 'REFERRAL_REWARD',
  SYSTEM_ERROR: 'SYSTEM_ERROR',
  SYSTEM_WARNING: 'SYSTEM_WARNING'
};

export type SystemLogAction = (typeof SystemLogAction)[keyof typeof SystemLogAction]


export const ReviewStatus: {
  PUBLISHED: 'PUBLISHED',
  HIDDEN: 'HIDDEN',
  DELETED: 'DELETED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type LicenseStatus = $Enums.LicenseStatus

export const LicenseStatus: typeof $Enums.LicenseStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type DepositStatus = $Enums.DepositStatus

export const DepositStatus: typeof $Enums.DepositStatus

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type WalletTransactionType = $Enums.WalletTransactionType

export const WalletTransactionType: typeof $Enums.WalletTransactionType

export type AutoTopupStatus = $Enums.AutoTopupStatus

export const AutoTopupStatus: typeof $Enums.AutoTopupStatus

export type ErrorReportStatus = $Enums.ErrorReportStatus

export const ErrorReportStatus: typeof $Enums.ErrorReportStatus

export type ProductLineStatus = $Enums.ProductLineStatus

export const ProductLineStatus: typeof $Enums.ProductLineStatus

export type AdType = $Enums.AdType

export const AdType: typeof $Enums.AdType

export type AdPlacement = $Enums.AdPlacement

export const AdPlacement: typeof $Enums.AdPlacement

export type SystemLogAction = $Enums.SystemLogAction

export const SystemLogAction: typeof $Enums.SystemLogAction

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productLog`: Exposes CRUD operations for the **ProductLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductLogs
    * const productLogs = await prisma.productLog.findMany()
    * ```
    */
  get productLog(): Prisma.ProductLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productLineItem`: Exposes CRUD operations for the **ProductLineItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductLineItems
    * const productLineItems = await prisma.productLineItem.findMany()
    * ```
    */
  get productLineItem(): Prisma.ProductLineItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualDepositRequest`: Exposes CRUD operations for the **ManualDepositRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualDepositRequests
    * const manualDepositRequests = await prisma.manualDepositRequest.findMany()
    * ```
    */
  get manualDepositRequest(): Prisma.ManualDepositRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.downloadLog`: Exposes CRUD operations for the **DownloadLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DownloadLogs
    * const downloadLogs = await prisma.downloadLog.findMany()
    * ```
    */
  get downloadLog(): Prisma.DownloadLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminActionLog`: Exposes CRUD operations for the **AdminActionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActionLogs
    * const adminActionLogs = await prisma.adminActionLog.findMany()
    * ```
    */
  get adminActionLog(): Prisma.AdminActionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.websiteSettings`: Exposes CRUD operations for the **WebsiteSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebsiteSettings
    * const websiteSettings = await prisma.websiteSettings.findMany()
    * ```
    */
  get websiteSettings(): Prisma.WebsiteSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autoTopupLog`: Exposes CRUD operations for the **AutoTopupLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutoTopupLogs
    * const autoTopupLogs = await prisma.autoTopupLog.findMany()
    * ```
    */
  get autoTopupLog(): Prisma.AutoTopupLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivityLog`: Exposes CRUD operations for the **UserActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivityLogs
    * const userActivityLogs = await prisma.userActivityLog.findMany()
    * ```
    */
  get userActivityLog(): Prisma.UserActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twoFactorAccount`: Exposes CRUD operations for the **TwoFactorAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactorAccounts
    * const twoFactorAccounts = await prisma.twoFactorAccount.findMany()
    * ```
    */
  get twoFactorAccount(): Prisma.TwoFactorAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.advertisement`: Exposes CRUD operations for the **Advertisement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisement.findMany()
    * ```
    */
  get advertisement(): Prisma.AdvertisementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.errorReport`: Exposes CRUD operations for the **ErrorReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ErrorReports
    * const errorReports = await prisma.errorReport.findMany()
    * ```
    */
  get errorReport(): Prisma.ErrorReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredUser`: Exposes CRUD operations for the **FeaturedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedUsers
    * const featuredUsers = await prisma.featuredUser.findMany()
    * ```
    */
  get featuredUser(): Prisma.FeaturedUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchKeyword`: Exposes CRUD operations for the **SearchKeyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchKeywords
    * const searchKeywords = await prisma.searchKeyword.findMany()
    * ```
    */
  get searchKeyword(): Prisma.SearchKeywordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Wallet: 'Wallet',
    Category: 'Category',
    Product: 'Product',
    ProductLog: 'ProductLog',
    ProductLineItem: 'ProductLineItem',
    File: 'File',
    License: 'License',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Payment: 'Payment',
    ManualDepositRequest: 'ManualDepositRequest',
    Coupon: 'Coupon',
    Settings: 'Settings',
    DownloadLog: 'DownloadLog',
    AdminActionLog: 'AdminActionLog',
    WalletTransaction: 'WalletTransaction',
    WebsiteSettings: 'WebsiteSettings',
    AutoTopupLog: 'AutoTopupLog',
    Referral: 'Referral',
    UserActivityLog: 'UserActivityLog',
    TwoFactorAccount: 'TwoFactorAccount',
    PasswordResetToken: 'PasswordResetToken',
    Advertisement: 'Advertisement',
    SystemLog: 'SystemLog',
    ErrorReport: 'ErrorReport',
    Review: 'Review',
    Banner: 'Banner',
    FeaturedUser: 'FeaturedUser',
    SearchKeyword: 'SearchKeyword'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "wallet" | "category" | "product" | "productLog" | "productLineItem" | "file" | "license" | "order" | "orderItem" | "payment" | "manualDepositRequest" | "coupon" | "settings" | "downloadLog" | "adminActionLog" | "walletTransaction" | "websiteSettings" | "autoTopupLog" | "referral" | "userActivityLog" | "twoFactorAccount" | "passwordResetToken" | "advertisement" | "systemLog" | "errorReport" | "review" | "banner" | "featuredUser" | "searchKeyword"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductLog: {
        payload: Prisma.$ProductLogPayload<ExtArgs>
        fields: Prisma.ProductLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>
          }
          findFirst: {
            args: Prisma.ProductLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>
          }
          findMany: {
            args: Prisma.ProductLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>[]
          }
          create: {
            args: Prisma.ProductLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>
          }
          createMany: {
            args: Prisma.ProductLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>
          }
          update: {
            args: Prisma.ProductLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>
          }
          deleteMany: {
            args: Prisma.ProductLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLogPayload>
          }
          aggregate: {
            args: Prisma.ProductLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductLog>
          }
          groupBy: {
            args: Prisma.ProductLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductLogCountArgs<ExtArgs>
            result: $Utils.Optional<ProductLogCountAggregateOutputType> | number
          }
        }
      }
      ProductLineItem: {
        payload: Prisma.$ProductLineItemPayload<ExtArgs>
        fields: Prisma.ProductLineItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductLineItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductLineItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>
          }
          findFirst: {
            args: Prisma.ProductLineItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductLineItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>
          }
          findMany: {
            args: Prisma.ProductLineItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>[]
          }
          create: {
            args: Prisma.ProductLineItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>
          }
          createMany: {
            args: Prisma.ProductLineItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductLineItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>
          }
          update: {
            args: Prisma.ProductLineItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>
          }
          deleteMany: {
            args: Prisma.ProductLineItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductLineItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductLineItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductLineItemPayload>
          }
          aggregate: {
            args: Prisma.ProductLineItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductLineItem>
          }
          groupBy: {
            args: Prisma.ProductLineItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductLineItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductLineItemCountArgs<ExtArgs>
            result: $Utils.Optional<ProductLineItemCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ManualDepositRequest: {
        payload: Prisma.$ManualDepositRequestPayload<ExtArgs>
        fields: Prisma.ManualDepositRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualDepositRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualDepositRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>
          }
          findFirst: {
            args: Prisma.ManualDepositRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualDepositRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>
          }
          findMany: {
            args: Prisma.ManualDepositRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>[]
          }
          create: {
            args: Prisma.ManualDepositRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>
          }
          createMany: {
            args: Prisma.ManualDepositRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManualDepositRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>
          }
          update: {
            args: Prisma.ManualDepositRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>
          }
          deleteMany: {
            args: Prisma.ManualDepositRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualDepositRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManualDepositRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualDepositRequestPayload>
          }
          aggregate: {
            args: Prisma.ManualDepositRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualDepositRequest>
          }
          groupBy: {
            args: Prisma.ManualDepositRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualDepositRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualDepositRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ManualDepositRequestCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      DownloadLog: {
        payload: Prisma.$DownloadLogPayload<ExtArgs>
        fields: Prisma.DownloadLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DownloadLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DownloadLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>
          }
          findFirst: {
            args: Prisma.DownloadLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DownloadLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>
          }
          findMany: {
            args: Prisma.DownloadLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>[]
          }
          create: {
            args: Prisma.DownloadLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>
          }
          createMany: {
            args: Prisma.DownloadLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DownloadLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>
          }
          update: {
            args: Prisma.DownloadLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>
          }
          deleteMany: {
            args: Prisma.DownloadLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DownloadLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DownloadLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DownloadLogPayload>
          }
          aggregate: {
            args: Prisma.DownloadLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDownloadLog>
          }
          groupBy: {
            args: Prisma.DownloadLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DownloadLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DownloadLogCountArgs<ExtArgs>
            result: $Utils.Optional<DownloadLogCountAggregateOutputType> | number
          }
        }
      }
      AdminActionLog: {
        payload: Prisma.$AdminActionLogPayload<ExtArgs>
        fields: Prisma.AdminActionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminActionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminActionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>
          }
          findFirst: {
            args: Prisma.AdminActionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminActionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>
          }
          findMany: {
            args: Prisma.AdminActionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>[]
          }
          create: {
            args: Prisma.AdminActionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>
          }
          createMany: {
            args: Prisma.AdminActionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminActionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>
          }
          update: {
            args: Prisma.AdminActionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminActionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminActionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminActionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionLogPayload>
          }
          aggregate: {
            args: Prisma.AdminActionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminActionLog>
          }
          groupBy: {
            args: Prisma.AdminActionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminActionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminActionLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminActionLogCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      WebsiteSettings: {
        payload: Prisma.$WebsiteSettingsPayload<ExtArgs>
        fields: Prisma.WebsiteSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          findFirst: {
            args: Prisma.WebsiteSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          findMany: {
            args: Prisma.WebsiteSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>[]
          }
          create: {
            args: Prisma.WebsiteSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          createMany: {
            args: Prisma.WebsiteSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WebsiteSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          update: {
            args: Prisma.WebsiteSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          deleteMany: {
            args: Prisma.WebsiteSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebsiteSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteSettingsPayload>
          }
          aggregate: {
            args: Prisma.WebsiteSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsiteSettings>
          }
          groupBy: {
            args: Prisma.WebsiteSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsiteSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<WebsiteSettingsCountAggregateOutputType> | number
          }
        }
      }
      AutoTopupLog: {
        payload: Prisma.$AutoTopupLogPayload<ExtArgs>
        fields: Prisma.AutoTopupLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutoTopupLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutoTopupLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>
          }
          findFirst: {
            args: Prisma.AutoTopupLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutoTopupLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>
          }
          findMany: {
            args: Prisma.AutoTopupLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>[]
          }
          create: {
            args: Prisma.AutoTopupLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>
          }
          createMany: {
            args: Prisma.AutoTopupLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AutoTopupLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>
          }
          update: {
            args: Prisma.AutoTopupLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>
          }
          deleteMany: {
            args: Prisma.AutoTopupLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutoTopupLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AutoTopupLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutoTopupLogPayload>
          }
          aggregate: {
            args: Prisma.AutoTopupLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutoTopupLog>
          }
          groupBy: {
            args: Prisma.AutoTopupLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutoTopupLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutoTopupLogCountArgs<ExtArgs>
            result: $Utils.Optional<AutoTopupLogCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      UserActivityLog: {
        payload: Prisma.$UserActivityLogPayload<ExtArgs>
        fields: Prisma.UserActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          findFirst: {
            args: Prisma.UserActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          findMany: {
            args: Prisma.UserActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>[]
          }
          create: {
            args: Prisma.UserActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          createMany: {
            args: Prisma.UserActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          update: {
            args: Prisma.UserActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.UserActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActivityLogPayload>
          }
          aggregate: {
            args: Prisma.UserActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivityLog>
          }
          groupBy: {
            args: Prisma.UserActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivityLogCountAggregateOutputType> | number
          }
        }
      }
      TwoFactorAccount: {
        payload: Prisma.$TwoFactorAccountPayload<ExtArgs>
        fields: Prisma.TwoFactorAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>
          }
          findMany: {
            args: Prisma.TwoFactorAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>[]
          }
          create: {
            args: Prisma.TwoFactorAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>
          }
          createMany: {
            args: Prisma.TwoFactorAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TwoFactorAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>
          }
          update: {
            args: Prisma.TwoFactorAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorAccountPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactorAccount>
          }
          groupBy: {
            args: Prisma.TwoFactorAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorAccountCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorAccountCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Advertisement: {
        payload: Prisma.$AdvertisementPayload<ExtArgs>
        fields: Prisma.AdvertisementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findFirst: {
            args: Prisma.AdvertisementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findMany: {
            args: Prisma.AdvertisementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          create: {
            args: Prisma.AdvertisementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          createMany: {
            args: Prisma.AdvertisementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdvertisementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          update: {
            args: Prisma.AdvertisementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvertisementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvertisement>
          }
          groupBy: {
            args: Prisma.AdvertisementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvertisementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvertisementCountArgs<ExtArgs>
            result: $Utils.Optional<AdvertisementCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      ErrorReport: {
        payload: Prisma.$ErrorReportPayload<ExtArgs>
        fields: Prisma.ErrorReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ErrorReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ErrorReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>
          }
          findFirst: {
            args: Prisma.ErrorReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ErrorReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>
          }
          findMany: {
            args: Prisma.ErrorReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>[]
          }
          create: {
            args: Prisma.ErrorReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>
          }
          createMany: {
            args: Prisma.ErrorReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ErrorReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>
          }
          update: {
            args: Prisma.ErrorReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>
          }
          deleteMany: {
            args: Prisma.ErrorReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ErrorReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ErrorReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ErrorReportPayload>
          }
          aggregate: {
            args: Prisma.ErrorReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErrorReport>
          }
          groupBy: {
            args: Prisma.ErrorReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ErrorReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ErrorReportCountArgs<ExtArgs>
            result: $Utils.Optional<ErrorReportCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      FeaturedUser: {
        payload: Prisma.$FeaturedUserPayload<ExtArgs>
        fields: Prisma.FeaturedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>
          }
          findFirst: {
            args: Prisma.FeaturedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>
          }
          findMany: {
            args: Prisma.FeaturedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>[]
          }
          create: {
            args: Prisma.FeaturedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>
          }
          createMany: {
            args: Prisma.FeaturedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeaturedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>
          }
          update: {
            args: Prisma.FeaturedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeaturedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedUserPayload>
          }
          aggregate: {
            args: Prisma.FeaturedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedUser>
          }
          groupBy: {
            args: Prisma.FeaturedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedUserCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedUserCountAggregateOutputType> | number
          }
        }
      }
      SearchKeyword: {
        payload: Prisma.$SearchKeywordPayload<ExtArgs>
        fields: Prisma.SearchKeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchKeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchKeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          findFirst: {
            args: Prisma.SearchKeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchKeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          findMany: {
            args: Prisma.SearchKeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>[]
          }
          create: {
            args: Prisma.SearchKeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          createMany: {
            args: Prisma.SearchKeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SearchKeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          update: {
            args: Prisma.SearchKeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          deleteMany: {
            args: Prisma.SearchKeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchKeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchKeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchKeywordPayload>
          }
          aggregate: {
            args: Prisma.SearchKeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchKeyword>
          }
          groupBy: {
            args: Prisma.SearchKeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchKeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchKeywordCountArgs<ExtArgs>
            result: $Utils.Optional<SearchKeywordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    wallet?: WalletOmit
    category?: CategoryOmit
    product?: ProductOmit
    productLog?: ProductLogOmit
    productLineItem?: ProductLineItemOmit
    file?: FileOmit
    license?: LicenseOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    payment?: PaymentOmit
    manualDepositRequest?: ManualDepositRequestOmit
    coupon?: CouponOmit
    settings?: SettingsOmit
    downloadLog?: DownloadLogOmit
    adminActionLog?: AdminActionLogOmit
    walletTransaction?: WalletTransactionOmit
    websiteSettings?: WebsiteSettingsOmit
    autoTopupLog?: AutoTopupLogOmit
    referral?: ReferralOmit
    userActivityLog?: UserActivityLogOmit
    twoFactorAccount?: TwoFactorAccountOmit
    passwordResetToken?: PasswordResetTokenOmit
    advertisement?: AdvertisementOmit
    systemLog?: SystemLogOmit
    errorReport?: ErrorReportOmit
    review?: ReviewOmit
    banner?: BannerOmit
    featuredUser?: FeaturedUserOmit
    searchKeyword?: SearchKeywordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    depositRequests: number
    adminActions: number
    productLogs: number
    twoFactorAccounts: number
    passwordResetTokens: number
    referrals: number
    reviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    depositRequests?: boolean | UserCountOutputTypeCountDepositRequestsArgs
    adminActions?: boolean | UserCountOutputTypeCountAdminActionsArgs
    productLogs?: boolean | UserCountOutputTypeCountProductLogsArgs
    twoFactorAccounts?: boolean | UserCountOutputTypeCountTwoFactorAccountsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepositRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualDepositRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwoFactorAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    productLogs: number
    files: number
    licenses: number
    reviews: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    productLogs?: boolean | ProductCountOutputTypeCountProductLogsArgs
    files?: boolean | ProductCountOutputTypeCountFilesArgs
    licenses?: boolean | ProductCountOutputTypeCountLicensesArgs
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLogWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type ProductLogCountOutputType
   */

  export type ProductLogCountOutputType = {
    productLines: number
  }

  export type ProductLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productLines?: boolean | ProductLogCountOutputTypeCountProductLinesArgs
  }

  // Custom InputTypes
  /**
   * ProductLogCountOutputType without action
   */
  export type ProductLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLogCountOutputType
     */
    select?: ProductLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductLogCountOutputType without action
   */
  export type ProductLogCountOutputTypeCountProductLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLineItemWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    downloadLogs: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    downloadLogs?: boolean | FileCountOutputTypeCountDownloadLogsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountDownloadLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DownloadLogWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    payments: number
    orderItems: number
    downloadLogs: number
    productLogs: number
    reviews: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
    downloadLogs?: boolean | OrderCountOutputTypeCountDownloadLogsArgs
    productLogs?: boolean | OrderCountOutputTypeCountProductLogsArgs
    reviews?: boolean | OrderCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDownloadLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DownloadLogWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLogWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referredById: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    referralCode: number
    referredById: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referredById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: $Enums.UserRole
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    referralCode: string | null
    referredById: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
    wallet?: boolean | User$walletArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    depositRequests?: boolean | User$depositRequestsArgs<ExtArgs>
    adminActions?: boolean | User$adminActionsArgs<ExtArgs>
    productLogs?: boolean | User$productLogsArgs<ExtArgs>
    twoFactorAccounts?: boolean | User$twoFactorAccountsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referredById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "emailVerified" | "createdAt" | "updatedAt" | "referralCode" | "referredById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | User$walletArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    depositRequests?: boolean | User$depositRequestsArgs<ExtArgs>
    adminActions?: boolean | User$adminActionsArgs<ExtArgs>
    productLogs?: boolean | User$productLogsArgs<ExtArgs>
    twoFactorAccounts?: boolean | User$twoFactorAccountsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      depositRequests: Prisma.$ManualDepositRequestPayload<ExtArgs>[]
      adminActions: Prisma.$AdminActionLogPayload<ExtArgs>[]
      productLogs: Prisma.$ProductLogPayload<ExtArgs>[]
      twoFactorAccounts: Prisma.$TwoFactorAccountPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      referredBy: Prisma.$ReferralPayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: $Enums.UserRole
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
      referralCode: string | null
      referredById: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    depositRequests<T extends User$depositRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$depositRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminActions<T extends User$adminActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productLogs<T extends User$productLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$productLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    twoFactorAccounts<T extends User$twoFactorAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$twoFactorAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referredById: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.depositRequests
   */
  export type User$depositRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    where?: ManualDepositRequestWhereInput
    orderBy?: ManualDepositRequestOrderByWithRelationInput | ManualDepositRequestOrderByWithRelationInput[]
    cursor?: ManualDepositRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualDepositRequestScalarFieldEnum | ManualDepositRequestScalarFieldEnum[]
  }

  /**
   * User.adminActions
   */
  export type User$adminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    where?: AdminActionLogWhereInput
    orderBy?: AdminActionLogOrderByWithRelationInput | AdminActionLogOrderByWithRelationInput[]
    cursor?: AdminActionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActionLogScalarFieldEnum | AdminActionLogScalarFieldEnum[]
  }

  /**
   * User.productLogs
   */
  export type User$productLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    where?: ProductLogWhereInput
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    cursor?: ProductLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductLogScalarFieldEnum | ProductLogScalarFieldEnum[]
  }

  /**
   * User.twoFactorAccounts
   */
  export type User$twoFactorAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    where?: TwoFactorAccountWhereInput
    orderBy?: TwoFactorAccountOrderByWithRelationInput | TwoFactorAccountOrderByWithRelationInput[]
    cursor?: TwoFactorAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFactorAccountScalarFieldEnum | TwoFactorAccountScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balanceVnd: number | null
  }

  export type WalletSumAggregateOutputType = {
    balanceVnd: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    balanceVnd: number | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    balanceVnd: number | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    balanceVnd: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balanceVnd?: true
  }

  export type WalletSumAggregateInputType = {
    balanceVnd?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    balanceVnd?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    balanceVnd?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    balanceVnd?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    balanceVnd: number
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balanceVnd?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>



  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    balanceVnd?: boolean
    updatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "balanceVnd" | "updatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      balanceVnd: number
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly balanceVnd: FieldRef<"Wallet", 'Float'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type CategorySumAggregateOutputType = {
    order: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    icon: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    icon: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    icon: number
    order: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    order?: true
  }

  export type CategorySumAggregateInputType = {
    order?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    icon?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    icon?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    icon?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    slug: string
    icon: string | null
    order: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    icon?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    icon?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug" | "icon" | "order" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      slug: string
      icon: string | null
      order: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly order: FieldRef<"Category", 'Int'>
    readonly active: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    priceVnd: number | null
    stock: number | null
    totalLines: number | null
    usedLines: number | null
    fakeSold: number | null
    fakeRating: number | null
  }

  export type ProductSumAggregateOutputType = {
    priceVnd: number | null
    stock: number | null
    totalLines: number | null
    usedLines: number | null
    fakeSold: number | null
    fakeRating: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    slug: string | null
    description: string | null
    priceVnd: number | null
    stock: number | null
    fileUrl: string | null
    fileName: string | null
    totalLines: number | null
    usedLines: number | null
    images: string | null
    active: boolean | null
    fakeSold: number | null
    fakeRating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    slug: string | null
    description: string | null
    priceVnd: number | null
    stock: number | null
    fileUrl: string | null
    fileName: string | null
    totalLines: number | null
    usedLines: number | null
    images: string | null
    active: boolean | null
    fakeSold: number | null
    fakeRating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    slug: number
    description: number
    priceVnd: number
    stock: number
    fileUrl: number
    fileName: number
    totalLines: number
    usedLines: number
    images: number
    active: number
    fakeSold: number
    fakeRating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    priceVnd?: true
    stock?: true
    totalLines?: true
    usedLines?: true
    fakeSold?: true
    fakeRating?: true
  }

  export type ProductSumAggregateInputType = {
    priceVnd?: true
    stock?: true
    totalLines?: true
    usedLines?: true
    fakeSold?: true
    fakeRating?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    slug?: true
    description?: true
    priceVnd?: true
    stock?: true
    fileUrl?: true
    fileName?: true
    totalLines?: true
    usedLines?: true
    images?: true
    active?: true
    fakeSold?: true
    fakeRating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    slug?: true
    description?: true
    priceVnd?: true
    stock?: true
    fileUrl?: true
    fileName?: true
    totalLines?: true
    usedLines?: true
    images?: true
    active?: true
    fakeSold?: true
    fakeRating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    slug?: true
    description?: true
    priceVnd?: true
    stock?: true
    fileUrl?: true
    fileName?: true
    totalLines?: true
    usedLines?: true
    images?: true
    active?: true
    fakeSold?: true
    fakeRating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    slug: string
    description: string | null
    priceVnd: number
    stock: number
    fileUrl: string | null
    fileName: string | null
    totalLines: number
    usedLines: number
    images: string | null
    active: boolean
    fakeSold: number
    fakeRating: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceVnd?: boolean
    stock?: boolean
    fileUrl?: boolean
    fileName?: boolean
    totalLines?: boolean
    usedLines?: boolean
    images?: boolean
    active?: boolean
    fakeSold?: boolean
    fakeRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productLogs?: boolean | Product$productLogsArgs<ExtArgs>
    files?: boolean | Product$filesArgs<ExtArgs>
    licenses?: boolean | Product$licensesArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    priceVnd?: boolean
    stock?: boolean
    fileUrl?: boolean
    fileName?: boolean
    totalLines?: boolean
    usedLines?: boolean
    images?: boolean
    active?: boolean
    fakeSold?: boolean
    fakeRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "name" | "slug" | "description" | "priceVnd" | "stock" | "fileUrl" | "fileName" | "totalLines" | "usedLines" | "images" | "active" | "fakeSold" | "fakeRating" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productLogs?: boolean | Product$productLogsArgs<ExtArgs>
    files?: boolean | Product$filesArgs<ExtArgs>
    licenses?: boolean | Product$licensesArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      productLogs: Prisma.$ProductLogPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      licenses: Prisma.$LicensePayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      slug: string
      description: string | null
      priceVnd: number
      stock: number
      fileUrl: string | null
      fileName: string | null
      totalLines: number
      usedLines: number
      images: string | null
      active: boolean
      fakeSold: number
      fakeRating: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productLogs<T extends Product$productLogsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Product$filesArgs<ExtArgs> = {}>(args?: Subset<T, Product$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    licenses<T extends Product$licensesArgs<ExtArgs> = {}>(args?: Subset<T, Product$licensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly priceVnd: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly fileUrl: FieldRef<"Product", 'String'>
    readonly fileName: FieldRef<"Product", 'String'>
    readonly totalLines: FieldRef<"Product", 'Int'>
    readonly usedLines: FieldRef<"Product", 'Int'>
    readonly images: FieldRef<"Product", 'String'>
    readonly active: FieldRef<"Product", 'Boolean'>
    readonly fakeSold: FieldRef<"Product", 'Int'>
    readonly fakeRating: FieldRef<"Product", 'Float'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.productLogs
   */
  export type Product$productLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    where?: ProductLogWhereInput
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    cursor?: ProductLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductLogScalarFieldEnum | ProductLogScalarFieldEnum[]
  }

  /**
   * Product.files
   */
  export type Product$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Product.licenses
   */
  export type Product$licensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    cursor?: LicenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductLog
   */

  export type AggregateProductLog = {
    _count: ProductLogCountAggregateOutputType | null
    _avg: ProductLogAvgAggregateOutputType | null
    _sum: ProductLogSumAggregateOutputType | null
    _min: ProductLogMinAggregateOutputType | null
    _max: ProductLogMaxAggregateOutputType | null
  }

  export type ProductLogAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ProductLogSumAggregateOutputType = {
    quantity: number | null
  }

  export type ProductLogMinAggregateOutputType = {
    id: string | null
    productId: string | null
    userId: string | null
    orderId: string | null
    action: string | null
    quantity: number | null
    lineIndices: string | null
    content: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ProductLogMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    userId: string | null
    orderId: string | null
    action: string | null
    quantity: number | null
    lineIndices: string | null
    content: string | null
    notes: string | null
    createdAt: Date | null
  }

  export type ProductLogCountAggregateOutputType = {
    id: number
    productId: number
    userId: number
    orderId: number
    action: number
    quantity: number
    lineIndices: number
    content: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ProductLogAvgAggregateInputType = {
    quantity?: true
  }

  export type ProductLogSumAggregateInputType = {
    quantity?: true
  }

  export type ProductLogMinAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    orderId?: true
    action?: true
    quantity?: true
    lineIndices?: true
    content?: true
    notes?: true
    createdAt?: true
  }

  export type ProductLogMaxAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    orderId?: true
    action?: true
    quantity?: true
    lineIndices?: true
    content?: true
    notes?: true
    createdAt?: true
  }

  export type ProductLogCountAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    orderId?: true
    action?: true
    quantity?: true
    lineIndices?: true
    content?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ProductLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductLog to aggregate.
     */
    where?: ProductLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLogs to fetch.
     */
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductLogs
    **/
    _count?: true | ProductLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductLogMaxAggregateInputType
  }

  export type GetProductLogAggregateType<T extends ProductLogAggregateArgs> = {
        [P in keyof T & keyof AggregateProductLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductLog[P]>
      : GetScalarType<T[P], AggregateProductLog[P]>
  }




  export type ProductLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLogWhereInput
    orderBy?: ProductLogOrderByWithAggregationInput | ProductLogOrderByWithAggregationInput[]
    by: ProductLogScalarFieldEnum[] | ProductLogScalarFieldEnum
    having?: ProductLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductLogCountAggregateInputType | true
    _avg?: ProductLogAvgAggregateInputType
    _sum?: ProductLogSumAggregateInputType
    _min?: ProductLogMinAggregateInputType
    _max?: ProductLogMaxAggregateInputType
  }

  export type ProductLogGroupByOutputType = {
    id: string
    productId: string
    userId: string
    orderId: string
    action: string
    quantity: number
    lineIndices: string | null
    content: string | null
    notes: string | null
    createdAt: Date
    _count: ProductLogCountAggregateOutputType | null
    _avg: ProductLogAvgAggregateOutputType | null
    _sum: ProductLogSumAggregateOutputType | null
    _min: ProductLogMinAggregateOutputType | null
    _max: ProductLogMaxAggregateOutputType | null
  }

  type GetProductLogGroupByPayload<T extends ProductLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductLogGroupByOutputType[P]>
            : GetScalarType<T[P], ProductLogGroupByOutputType[P]>
        }
      >
    >


  export type ProductLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    orderId?: boolean
    action?: boolean
    quantity?: boolean
    lineIndices?: boolean
    content?: boolean
    notes?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productLines?: boolean | ProductLog$productLinesArgs<ExtArgs>
    _count?: boolean | ProductLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productLog"]>



  export type ProductLogSelectScalar = {
    id?: boolean
    productId?: boolean
    userId?: boolean
    orderId?: boolean
    action?: boolean
    quantity?: boolean
    lineIndices?: boolean
    content?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ProductLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "userId" | "orderId" | "action" | "quantity" | "lineIndices" | "content" | "notes" | "createdAt", ExtArgs["result"]["productLog"]>
  export type ProductLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
    productLines?: boolean | ProductLog$productLinesArgs<ExtArgs>
    _count?: boolean | ProductLogCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductLog"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
      productLines: Prisma.$ProductLineItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      userId: string
      orderId: string
      action: string
      quantity: number
      lineIndices: string | null
      content: string | null
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["productLog"]>
    composites: {}
  }

  type ProductLogGetPayload<S extends boolean | null | undefined | ProductLogDefaultArgs> = $Result.GetResult<Prisma.$ProductLogPayload, S>

  type ProductLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductLogCountAggregateInputType | true
    }

  export interface ProductLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductLog'], meta: { name: 'ProductLog' } }
    /**
     * Find zero or one ProductLog that matches the filter.
     * @param {ProductLogFindUniqueArgs} args - Arguments to find a ProductLog
     * @example
     * // Get one ProductLog
     * const productLog = await prisma.productLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductLogFindUniqueArgs>(args: SelectSubset<T, ProductLogFindUniqueArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductLogFindUniqueOrThrowArgs} args - Arguments to find a ProductLog
     * @example
     * // Get one ProductLog
     * const productLog = await prisma.productLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogFindFirstArgs} args - Arguments to find a ProductLog
     * @example
     * // Get one ProductLog
     * const productLog = await prisma.productLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductLogFindFirstArgs>(args?: SelectSubset<T, ProductLogFindFirstArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogFindFirstOrThrowArgs} args - Arguments to find a ProductLog
     * @example
     * // Get one ProductLog
     * const productLog = await prisma.productLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductLogs
     * const productLogs = await prisma.productLog.findMany()
     * 
     * // Get first 10 ProductLogs
     * const productLogs = await prisma.productLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productLogWithIdOnly = await prisma.productLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductLogFindManyArgs>(args?: SelectSubset<T, ProductLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductLog.
     * @param {ProductLogCreateArgs} args - Arguments to create a ProductLog.
     * @example
     * // Create one ProductLog
     * const ProductLog = await prisma.productLog.create({
     *   data: {
     *     // ... data to create a ProductLog
     *   }
     * })
     * 
     */
    create<T extends ProductLogCreateArgs>(args: SelectSubset<T, ProductLogCreateArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductLogs.
     * @param {ProductLogCreateManyArgs} args - Arguments to create many ProductLogs.
     * @example
     * // Create many ProductLogs
     * const productLog = await prisma.productLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductLogCreateManyArgs>(args?: SelectSubset<T, ProductLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductLog.
     * @param {ProductLogDeleteArgs} args - Arguments to delete one ProductLog.
     * @example
     * // Delete one ProductLog
     * const ProductLog = await prisma.productLog.delete({
     *   where: {
     *     // ... filter to delete one ProductLog
     *   }
     * })
     * 
     */
    delete<T extends ProductLogDeleteArgs>(args: SelectSubset<T, ProductLogDeleteArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductLog.
     * @param {ProductLogUpdateArgs} args - Arguments to update one ProductLog.
     * @example
     * // Update one ProductLog
     * const productLog = await prisma.productLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductLogUpdateArgs>(args: SelectSubset<T, ProductLogUpdateArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductLogs.
     * @param {ProductLogDeleteManyArgs} args - Arguments to filter ProductLogs to delete.
     * @example
     * // Delete a few ProductLogs
     * const { count } = await prisma.productLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductLogDeleteManyArgs>(args?: SelectSubset<T, ProductLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductLogs
     * const productLog = await prisma.productLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductLogUpdateManyArgs>(args: SelectSubset<T, ProductLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductLog.
     * @param {ProductLogUpsertArgs} args - Arguments to update or create a ProductLog.
     * @example
     * // Update or create a ProductLog
     * const productLog = await prisma.productLog.upsert({
     *   create: {
     *     // ... data to create a ProductLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductLog we want to update
     *   }
     * })
     */
    upsert<T extends ProductLogUpsertArgs>(args: SelectSubset<T, ProductLogUpsertArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogCountArgs} args - Arguments to filter ProductLogs to count.
     * @example
     * // Count the number of ProductLogs
     * const count = await prisma.productLog.count({
     *   where: {
     *     // ... the filter for the ProductLogs we want to count
     *   }
     * })
    **/
    count<T extends ProductLogCountArgs>(
      args?: Subset<T, ProductLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductLogAggregateArgs>(args: Subset<T, ProductLogAggregateArgs>): Prisma.PrismaPromise<GetProductLogAggregateType<T>>

    /**
     * Group by ProductLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductLogGroupByArgs['orderBy'] }
        : { orderBy?: ProductLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductLog model
   */
  readonly fields: ProductLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productLines<T extends ProductLog$productLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductLog$productLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductLog model
   */
  interface ProductLogFieldRefs {
    readonly id: FieldRef<"ProductLog", 'String'>
    readonly productId: FieldRef<"ProductLog", 'String'>
    readonly userId: FieldRef<"ProductLog", 'String'>
    readonly orderId: FieldRef<"ProductLog", 'String'>
    readonly action: FieldRef<"ProductLog", 'String'>
    readonly quantity: FieldRef<"ProductLog", 'Int'>
    readonly lineIndices: FieldRef<"ProductLog", 'String'>
    readonly content: FieldRef<"ProductLog", 'String'>
    readonly notes: FieldRef<"ProductLog", 'String'>
    readonly createdAt: FieldRef<"ProductLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductLog findUnique
   */
  export type ProductLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductLog to fetch.
     */
    where: ProductLogWhereUniqueInput
  }

  /**
   * ProductLog findUniqueOrThrow
   */
  export type ProductLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductLog to fetch.
     */
    where: ProductLogWhereUniqueInput
  }

  /**
   * ProductLog findFirst
   */
  export type ProductLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductLog to fetch.
     */
    where?: ProductLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLogs to fetch.
     */
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLogs.
     */
    cursor?: ProductLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLogs.
     */
    distinct?: ProductLogScalarFieldEnum | ProductLogScalarFieldEnum[]
  }

  /**
   * ProductLog findFirstOrThrow
   */
  export type ProductLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductLog to fetch.
     */
    where?: ProductLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLogs to fetch.
     */
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLogs.
     */
    cursor?: ProductLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLogs.
     */
    distinct?: ProductLogScalarFieldEnum | ProductLogScalarFieldEnum[]
  }

  /**
   * ProductLog findMany
   */
  export type ProductLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * Filter, which ProductLogs to fetch.
     */
    where?: ProductLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLogs to fetch.
     */
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductLogs.
     */
    cursor?: ProductLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLogs.
     */
    skip?: number
    distinct?: ProductLogScalarFieldEnum | ProductLogScalarFieldEnum[]
  }

  /**
   * ProductLog create
   */
  export type ProductLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductLog.
     */
    data: XOR<ProductLogCreateInput, ProductLogUncheckedCreateInput>
  }

  /**
   * ProductLog createMany
   */
  export type ProductLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductLogs.
     */
    data: ProductLogCreateManyInput | ProductLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductLog update
   */
  export type ProductLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductLog.
     */
    data: XOR<ProductLogUpdateInput, ProductLogUncheckedUpdateInput>
    /**
     * Choose, which ProductLog to update.
     */
    where: ProductLogWhereUniqueInput
  }

  /**
   * ProductLog updateMany
   */
  export type ProductLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductLogs.
     */
    data: XOR<ProductLogUpdateManyMutationInput, ProductLogUncheckedUpdateManyInput>
    /**
     * Filter which ProductLogs to update
     */
    where?: ProductLogWhereInput
    /**
     * Limit how many ProductLogs to update.
     */
    limit?: number
  }

  /**
   * ProductLog upsert
   */
  export type ProductLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductLog to update in case it exists.
     */
    where: ProductLogWhereUniqueInput
    /**
     * In case the ProductLog found by the `where` argument doesn't exist, create a new ProductLog with this data.
     */
    create: XOR<ProductLogCreateInput, ProductLogUncheckedCreateInput>
    /**
     * In case the ProductLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductLogUpdateInput, ProductLogUncheckedUpdateInput>
  }

  /**
   * ProductLog delete
   */
  export type ProductLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    /**
     * Filter which ProductLog to delete.
     */
    where: ProductLogWhereUniqueInput
  }

  /**
   * ProductLog deleteMany
   */
  export type ProductLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductLogs to delete
     */
    where?: ProductLogWhereInput
    /**
     * Limit how many ProductLogs to delete.
     */
    limit?: number
  }

  /**
   * ProductLog.productLines
   */
  export type ProductLog$productLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    where?: ProductLineItemWhereInput
    orderBy?: ProductLineItemOrderByWithRelationInput | ProductLineItemOrderByWithRelationInput[]
    cursor?: ProductLineItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductLineItemScalarFieldEnum | ProductLineItemScalarFieldEnum[]
  }

  /**
   * ProductLog without action
   */
  export type ProductLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
  }


  /**
   * Model ProductLineItem
   */

  export type AggregateProductLineItem = {
    _count: ProductLineItemCountAggregateOutputType | null
    _avg: ProductLineItemAvgAggregateOutputType | null
    _sum: ProductLineItemSumAggregateOutputType | null
    _min: ProductLineItemMinAggregateOutputType | null
    _max: ProductLineItemMaxAggregateOutputType | null
  }

  export type ProductLineItemAvgAggregateOutputType = {
    priceVnd: number | null
  }

  export type ProductLineItemSumAggregateOutputType = {
    priceVnd: number | null
  }

  export type ProductLineItemMinAggregateOutputType = {
    id: string | null
    productLogId: string | null
    orderId: string | null
    productName: string | null
    content: string | null
    priceVnd: number | null
    status: $Enums.ProductLineStatus | null
    errorReported: boolean | null
    replacement: string | null
    adminNote: string | null
    rejectedAt: Date | null
    replacedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductLineItemMaxAggregateOutputType = {
    id: string | null
    productLogId: string | null
    orderId: string | null
    productName: string | null
    content: string | null
    priceVnd: number | null
    status: $Enums.ProductLineStatus | null
    errorReported: boolean | null
    replacement: string | null
    adminNote: string | null
    rejectedAt: Date | null
    replacedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductLineItemCountAggregateOutputType = {
    id: number
    productLogId: number
    orderId: number
    productName: number
    content: number
    priceVnd: number
    status: number
    errorReported: number
    replacement: number
    adminNote: number
    rejectedAt: number
    replacedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductLineItemAvgAggregateInputType = {
    priceVnd?: true
  }

  export type ProductLineItemSumAggregateInputType = {
    priceVnd?: true
  }

  export type ProductLineItemMinAggregateInputType = {
    id?: true
    productLogId?: true
    orderId?: true
    productName?: true
    content?: true
    priceVnd?: true
    status?: true
    errorReported?: true
    replacement?: true
    adminNote?: true
    rejectedAt?: true
    replacedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductLineItemMaxAggregateInputType = {
    id?: true
    productLogId?: true
    orderId?: true
    productName?: true
    content?: true
    priceVnd?: true
    status?: true
    errorReported?: true
    replacement?: true
    adminNote?: true
    rejectedAt?: true
    replacedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductLineItemCountAggregateInputType = {
    id?: true
    productLogId?: true
    orderId?: true
    productName?: true
    content?: true
    priceVnd?: true
    status?: true
    errorReported?: true
    replacement?: true
    adminNote?: true
    rejectedAt?: true
    replacedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductLineItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductLineItem to aggregate.
     */
    where?: ProductLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLineItems to fetch.
     */
    orderBy?: ProductLineItemOrderByWithRelationInput | ProductLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductLineItems
    **/
    _count?: true | ProductLineItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductLineItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductLineItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductLineItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductLineItemMaxAggregateInputType
  }

  export type GetProductLineItemAggregateType<T extends ProductLineItemAggregateArgs> = {
        [P in keyof T & keyof AggregateProductLineItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductLineItem[P]>
      : GetScalarType<T[P], AggregateProductLineItem[P]>
  }




  export type ProductLineItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductLineItemWhereInput
    orderBy?: ProductLineItemOrderByWithAggregationInput | ProductLineItemOrderByWithAggregationInput[]
    by: ProductLineItemScalarFieldEnum[] | ProductLineItemScalarFieldEnum
    having?: ProductLineItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductLineItemCountAggregateInputType | true
    _avg?: ProductLineItemAvgAggregateInputType
    _sum?: ProductLineItemSumAggregateInputType
    _min?: ProductLineItemMinAggregateInputType
    _max?: ProductLineItemMaxAggregateInputType
  }

  export type ProductLineItemGroupByOutputType = {
    id: string
    productLogId: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status: $Enums.ProductLineStatus
    errorReported: boolean
    replacement: string | null
    adminNote: string | null
    rejectedAt: Date | null
    replacedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProductLineItemCountAggregateOutputType | null
    _avg: ProductLineItemAvgAggregateOutputType | null
    _sum: ProductLineItemSumAggregateOutputType | null
    _min: ProductLineItemMinAggregateOutputType | null
    _max: ProductLineItemMaxAggregateOutputType | null
  }

  type GetProductLineItemGroupByPayload<T extends ProductLineItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductLineItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductLineItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductLineItemGroupByOutputType[P]>
            : GetScalarType<T[P], ProductLineItemGroupByOutputType[P]>
        }
      >
    >


  export type ProductLineItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productLogId?: boolean
    orderId?: boolean
    productName?: boolean
    content?: boolean
    priceVnd?: boolean
    status?: boolean
    errorReported?: boolean
    replacement?: boolean
    adminNote?: boolean
    rejectedAt?: boolean
    replacedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productLog?: boolean | ProductLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productLineItem"]>



  export type ProductLineItemSelectScalar = {
    id?: boolean
    productLogId?: boolean
    orderId?: boolean
    productName?: boolean
    content?: boolean
    priceVnd?: boolean
    status?: boolean
    errorReported?: boolean
    replacement?: boolean
    adminNote?: boolean
    rejectedAt?: boolean
    replacedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductLineItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productLogId" | "orderId" | "productName" | "content" | "priceVnd" | "status" | "errorReported" | "replacement" | "adminNote" | "rejectedAt" | "replacedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["productLineItem"]>
  export type ProductLineItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productLog?: boolean | ProductLogDefaultArgs<ExtArgs>
  }

  export type $ProductLineItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductLineItem"
    objects: {
      productLog: Prisma.$ProductLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productLogId: string
      orderId: string
      productName: string
      content: string
      priceVnd: number
      status: $Enums.ProductLineStatus
      errorReported: boolean
      replacement: string | null
      adminNote: string | null
      rejectedAt: Date | null
      replacedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productLineItem"]>
    composites: {}
  }

  type ProductLineItemGetPayload<S extends boolean | null | undefined | ProductLineItemDefaultArgs> = $Result.GetResult<Prisma.$ProductLineItemPayload, S>

  type ProductLineItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductLineItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductLineItemCountAggregateInputType | true
    }

  export interface ProductLineItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductLineItem'], meta: { name: 'ProductLineItem' } }
    /**
     * Find zero or one ProductLineItem that matches the filter.
     * @param {ProductLineItemFindUniqueArgs} args - Arguments to find a ProductLineItem
     * @example
     * // Get one ProductLineItem
     * const productLineItem = await prisma.productLineItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductLineItemFindUniqueArgs>(args: SelectSubset<T, ProductLineItemFindUniqueArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductLineItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductLineItemFindUniqueOrThrowArgs} args - Arguments to find a ProductLineItem
     * @example
     * // Get one ProductLineItem
     * const productLineItem = await prisma.productLineItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductLineItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductLineItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductLineItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemFindFirstArgs} args - Arguments to find a ProductLineItem
     * @example
     * // Get one ProductLineItem
     * const productLineItem = await prisma.productLineItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductLineItemFindFirstArgs>(args?: SelectSubset<T, ProductLineItemFindFirstArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductLineItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemFindFirstOrThrowArgs} args - Arguments to find a ProductLineItem
     * @example
     * // Get one ProductLineItem
     * const productLineItem = await prisma.productLineItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductLineItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductLineItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductLineItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductLineItems
     * const productLineItems = await prisma.productLineItem.findMany()
     * 
     * // Get first 10 ProductLineItems
     * const productLineItems = await prisma.productLineItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productLineItemWithIdOnly = await prisma.productLineItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductLineItemFindManyArgs>(args?: SelectSubset<T, ProductLineItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductLineItem.
     * @param {ProductLineItemCreateArgs} args - Arguments to create a ProductLineItem.
     * @example
     * // Create one ProductLineItem
     * const ProductLineItem = await prisma.productLineItem.create({
     *   data: {
     *     // ... data to create a ProductLineItem
     *   }
     * })
     * 
     */
    create<T extends ProductLineItemCreateArgs>(args: SelectSubset<T, ProductLineItemCreateArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductLineItems.
     * @param {ProductLineItemCreateManyArgs} args - Arguments to create many ProductLineItems.
     * @example
     * // Create many ProductLineItems
     * const productLineItem = await prisma.productLineItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductLineItemCreateManyArgs>(args?: SelectSubset<T, ProductLineItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductLineItem.
     * @param {ProductLineItemDeleteArgs} args - Arguments to delete one ProductLineItem.
     * @example
     * // Delete one ProductLineItem
     * const ProductLineItem = await prisma.productLineItem.delete({
     *   where: {
     *     // ... filter to delete one ProductLineItem
     *   }
     * })
     * 
     */
    delete<T extends ProductLineItemDeleteArgs>(args: SelectSubset<T, ProductLineItemDeleteArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductLineItem.
     * @param {ProductLineItemUpdateArgs} args - Arguments to update one ProductLineItem.
     * @example
     * // Update one ProductLineItem
     * const productLineItem = await prisma.productLineItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductLineItemUpdateArgs>(args: SelectSubset<T, ProductLineItemUpdateArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductLineItems.
     * @param {ProductLineItemDeleteManyArgs} args - Arguments to filter ProductLineItems to delete.
     * @example
     * // Delete a few ProductLineItems
     * const { count } = await prisma.productLineItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductLineItemDeleteManyArgs>(args?: SelectSubset<T, ProductLineItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductLineItems
     * const productLineItem = await prisma.productLineItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductLineItemUpdateManyArgs>(args: SelectSubset<T, ProductLineItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductLineItem.
     * @param {ProductLineItemUpsertArgs} args - Arguments to update or create a ProductLineItem.
     * @example
     * // Update or create a ProductLineItem
     * const productLineItem = await prisma.productLineItem.upsert({
     *   create: {
     *     // ... data to create a ProductLineItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductLineItem we want to update
     *   }
     * })
     */
    upsert<T extends ProductLineItemUpsertArgs>(args: SelectSubset<T, ProductLineItemUpsertArgs<ExtArgs>>): Prisma__ProductLineItemClient<$Result.GetResult<Prisma.$ProductLineItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductLineItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemCountArgs} args - Arguments to filter ProductLineItems to count.
     * @example
     * // Count the number of ProductLineItems
     * const count = await prisma.productLineItem.count({
     *   where: {
     *     // ... the filter for the ProductLineItems we want to count
     *   }
     * })
    **/
    count<T extends ProductLineItemCountArgs>(
      args?: Subset<T, ProductLineItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductLineItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductLineItemAggregateArgs>(args: Subset<T, ProductLineItemAggregateArgs>): Prisma.PrismaPromise<GetProductLineItemAggregateType<T>>

    /**
     * Group by ProductLineItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductLineItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductLineItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductLineItemGroupByArgs['orderBy'] }
        : { orderBy?: ProductLineItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductLineItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductLineItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductLineItem model
   */
  readonly fields: ProductLineItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductLineItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductLineItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productLog<T extends ProductLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductLogDefaultArgs<ExtArgs>>): Prisma__ProductLogClient<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductLineItem model
   */
  interface ProductLineItemFieldRefs {
    readonly id: FieldRef<"ProductLineItem", 'String'>
    readonly productLogId: FieldRef<"ProductLineItem", 'String'>
    readonly orderId: FieldRef<"ProductLineItem", 'String'>
    readonly productName: FieldRef<"ProductLineItem", 'String'>
    readonly content: FieldRef<"ProductLineItem", 'String'>
    readonly priceVnd: FieldRef<"ProductLineItem", 'Float'>
    readonly status: FieldRef<"ProductLineItem", 'ProductLineStatus'>
    readonly errorReported: FieldRef<"ProductLineItem", 'Boolean'>
    readonly replacement: FieldRef<"ProductLineItem", 'String'>
    readonly adminNote: FieldRef<"ProductLineItem", 'String'>
    readonly rejectedAt: FieldRef<"ProductLineItem", 'DateTime'>
    readonly replacedAt: FieldRef<"ProductLineItem", 'DateTime'>
    readonly createdAt: FieldRef<"ProductLineItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductLineItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductLineItem findUnique
   */
  export type ProductLineItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductLineItem to fetch.
     */
    where: ProductLineItemWhereUniqueInput
  }

  /**
   * ProductLineItem findUniqueOrThrow
   */
  export type ProductLineItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductLineItem to fetch.
     */
    where: ProductLineItemWhereUniqueInput
  }

  /**
   * ProductLineItem findFirst
   */
  export type ProductLineItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductLineItem to fetch.
     */
    where?: ProductLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLineItems to fetch.
     */
    orderBy?: ProductLineItemOrderByWithRelationInput | ProductLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLineItems.
     */
    cursor?: ProductLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLineItems.
     */
    distinct?: ProductLineItemScalarFieldEnum | ProductLineItemScalarFieldEnum[]
  }

  /**
   * ProductLineItem findFirstOrThrow
   */
  export type ProductLineItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductLineItem to fetch.
     */
    where?: ProductLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLineItems to fetch.
     */
    orderBy?: ProductLineItemOrderByWithRelationInput | ProductLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductLineItems.
     */
    cursor?: ProductLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLineItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductLineItems.
     */
    distinct?: ProductLineItemScalarFieldEnum | ProductLineItemScalarFieldEnum[]
  }

  /**
   * ProductLineItem findMany
   */
  export type ProductLineItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * Filter, which ProductLineItems to fetch.
     */
    where?: ProductLineItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductLineItems to fetch.
     */
    orderBy?: ProductLineItemOrderByWithRelationInput | ProductLineItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductLineItems.
     */
    cursor?: ProductLineItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductLineItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductLineItems.
     */
    skip?: number
    distinct?: ProductLineItemScalarFieldEnum | ProductLineItemScalarFieldEnum[]
  }

  /**
   * ProductLineItem create
   */
  export type ProductLineItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductLineItem.
     */
    data: XOR<ProductLineItemCreateInput, ProductLineItemUncheckedCreateInput>
  }

  /**
   * ProductLineItem createMany
   */
  export type ProductLineItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductLineItems.
     */
    data: ProductLineItemCreateManyInput | ProductLineItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductLineItem update
   */
  export type ProductLineItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductLineItem.
     */
    data: XOR<ProductLineItemUpdateInput, ProductLineItemUncheckedUpdateInput>
    /**
     * Choose, which ProductLineItem to update.
     */
    where: ProductLineItemWhereUniqueInput
  }

  /**
   * ProductLineItem updateMany
   */
  export type ProductLineItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductLineItems.
     */
    data: XOR<ProductLineItemUpdateManyMutationInput, ProductLineItemUncheckedUpdateManyInput>
    /**
     * Filter which ProductLineItems to update
     */
    where?: ProductLineItemWhereInput
    /**
     * Limit how many ProductLineItems to update.
     */
    limit?: number
  }

  /**
   * ProductLineItem upsert
   */
  export type ProductLineItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductLineItem to update in case it exists.
     */
    where: ProductLineItemWhereUniqueInput
    /**
     * In case the ProductLineItem found by the `where` argument doesn't exist, create a new ProductLineItem with this data.
     */
    create: XOR<ProductLineItemCreateInput, ProductLineItemUncheckedCreateInput>
    /**
     * In case the ProductLineItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductLineItemUpdateInput, ProductLineItemUncheckedUpdateInput>
  }

  /**
   * ProductLineItem delete
   */
  export type ProductLineItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
    /**
     * Filter which ProductLineItem to delete.
     */
    where: ProductLineItemWhereUniqueInput
  }

  /**
   * ProductLineItem deleteMany
   */
  export type ProductLineItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductLineItems to delete
     */
    where?: ProductLineItemWhereInput
    /**
     * Limit how many ProductLineItems to delete.
     */
    limit?: number
  }

  /**
   * ProductLineItem without action
   */
  export type ProductLineItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLineItem
     */
    select?: ProductLineItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLineItem
     */
    omit?: ProductLineItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLineItemInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    productId: string | null
    s3Key: string | null
    size: number | null
    checksum: string | null
    createdAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    s3Key: string | null
    size: number | null
    checksum: string | null
    createdAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    productId: number
    s3Key: number
    size: number
    checksum: number
    createdAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    productId?: true
    s3Key?: true
    size?: true
    checksum?: true
    createdAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    productId?: true
    s3Key?: true
    size?: true
    checksum?: true
    createdAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    productId?: true
    s3Key?: true
    size?: true
    checksum?: true
    createdAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    productId: string
    s3Key: string
    size: number
    checksum: string | null
    createdAt: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    s3Key?: boolean
    size?: boolean
    checksum?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    downloadLogs?: boolean | File$downloadLogsArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>



  export type FileSelectScalar = {
    id?: boolean
    productId?: boolean
    s3Key?: boolean
    size?: boolean
    checksum?: boolean
    createdAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "s3Key" | "size" | "checksum" | "createdAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    downloadLogs?: boolean | File$downloadLogsArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      downloadLogs: Prisma.$DownloadLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      s3Key: string
      size: number
      checksum: string | null
      createdAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    downloadLogs<T extends File$downloadLogsArgs<ExtArgs> = {}>(args?: Subset<T, File$downloadLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly productId: FieldRef<"File", 'String'>
    readonly s3Key: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly checksum: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.downloadLogs
   */
  export type File$downloadLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    where?: DownloadLogWhereInput
    orderBy?: DownloadLogOrderByWithRelationInput | DownloadLogOrderByWithRelationInput[]
    cursor?: DownloadLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DownloadLogScalarFieldEnum | DownloadLogScalarFieldEnum[]
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseMinAggregateOutputType = {
    id: string | null
    productId: string | null
    codeOrJwt: string | null
    status: $Enums.LicenseStatus | null
    boundEmail: string | null
    issuedAt: Date | null
    createdAt: Date | null
  }

  export type LicenseMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    codeOrJwt: string | null
    status: $Enums.LicenseStatus | null
    boundEmail: string | null
    issuedAt: Date | null
    createdAt: Date | null
  }

  export type LicenseCountAggregateOutputType = {
    id: number
    productId: number
    codeOrJwt: number
    status: number
    boundEmail: number
    issuedAt: number
    createdAt: number
    _all: number
  }


  export type LicenseMinAggregateInputType = {
    id?: true
    productId?: true
    codeOrJwt?: true
    status?: true
    boundEmail?: true
    issuedAt?: true
    createdAt?: true
  }

  export type LicenseMaxAggregateInputType = {
    id?: true
    productId?: true
    codeOrJwt?: true
    status?: true
    boundEmail?: true
    issuedAt?: true
    createdAt?: true
  }

  export type LicenseCountAggregateInputType = {
    id?: true
    productId?: true
    codeOrJwt?: true
    status?: true
    boundEmail?: true
    issuedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    id: string
    productId: string
    codeOrJwt: string
    status: $Enums.LicenseStatus
    boundEmail: string | null
    issuedAt: Date | null
    createdAt: Date
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    codeOrJwt?: boolean
    status?: boolean
    boundEmail?: boolean
    issuedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>



  export type LicenseSelectScalar = {
    id?: boolean
    productId?: boolean
    codeOrJwt?: boolean
    status?: boolean
    boundEmail?: boolean
    issuedAt?: boolean
    createdAt?: boolean
  }

  export type LicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "codeOrJwt" | "status" | "boundEmail" | "issuedAt" | "createdAt", ExtArgs["result"]["license"]>
  export type LicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      codeOrJwt: string
      status: $Enums.LicenseStatus
      boundEmail: string | null
      issuedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseWithIdOnly = await prisma.license.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */
  interface LicenseFieldRefs {
    readonly id: FieldRef<"License", 'String'>
    readonly productId: FieldRef<"License", 'String'>
    readonly codeOrJwt: FieldRef<"License", 'String'>
    readonly status: FieldRef<"License", 'LicenseStatus'>
    readonly boundEmail: FieldRef<"License", 'String'>
    readonly issuedAt: FieldRef<"License", 'DateTime'>
    readonly createdAt: FieldRef<"License", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to delete.
     */
    limit?: number
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalAmountVnd: number | null
    discountVnd: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalAmountVnd: number | null
    discountVnd: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.OrderStatus | null
    totalAmountVnd: number | null
    discountVnd: number | null
    couponCode: string | null
    currency: string | null
    itemsJson: string | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.OrderStatus | null
    totalAmountVnd: number | null
    discountVnd: number | null
    couponCode: string | null
    currency: string | null
    itemsJson: string | null
    paymentMethod: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    totalAmountVnd: number
    discountVnd: number
    couponCode: number
    currency: number
    itemsJson: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalAmountVnd?: true
    discountVnd?: true
  }

  export type OrderSumAggregateInputType = {
    totalAmountVnd?: true
    discountVnd?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    totalAmountVnd?: true
    discountVnd?: true
    couponCode?: true
    currency?: true
    itemsJson?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    totalAmountVnd?: true
    discountVnd?: true
    couponCode?: true
    currency?: true
    itemsJson?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    totalAmountVnd?: true
    discountVnd?: true
    couponCode?: true
    currency?: true
    itemsJson?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd: number
    couponCode: string | null
    currency: string
    itemsJson: string
    paymentMethod: $Enums.PaymentMethod
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    totalAmountVnd?: boolean
    discountVnd?: boolean
    couponCode?: boolean
    currency?: boolean
    itemsJson?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    downloadLogs?: boolean | Order$downloadLogsArgs<ExtArgs>
    productLogs?: boolean | Order$productLogsArgs<ExtArgs>
    reviews?: boolean | Order$reviewsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    totalAmountVnd?: boolean
    discountVnd?: boolean
    couponCode?: boolean
    currency?: boolean
    itemsJson?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "totalAmountVnd" | "discountVnd" | "couponCode" | "currency" | "itemsJson" | "paymentMethod" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    downloadLogs?: boolean | Order$downloadLogsArgs<ExtArgs>
    productLogs?: boolean | Order$productLogsArgs<ExtArgs>
    reviews?: boolean | Order$reviewsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      downloadLogs: Prisma.$DownloadLogPayload<ExtArgs>[]
      productLogs: Prisma.$ProductLogPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.OrderStatus
      totalAmountVnd: number
      discountVnd: number
      couponCode: string | null
      currency: string
      itemsJson: string
      paymentMethod: $Enums.PaymentMethod
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    downloadLogs<T extends Order$downloadLogsArgs<ExtArgs> = {}>(args?: Subset<T, Order$downloadLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productLogs<T extends Order$productLogsArgs<ExtArgs> = {}>(args?: Subset<T, Order$productLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Order$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Order$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly totalAmountVnd: FieldRef<"Order", 'Float'>
    readonly discountVnd: FieldRef<"Order", 'Float'>
    readonly couponCode: FieldRef<"Order", 'String'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly itemsJson: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'PaymentMethod'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.downloadLogs
   */
  export type Order$downloadLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    where?: DownloadLogWhereInput
    orderBy?: DownloadLogOrderByWithRelationInput | DownloadLogOrderByWithRelationInput[]
    cursor?: DownloadLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DownloadLogScalarFieldEnum | DownloadLogScalarFieldEnum[]
  }

  /**
   * Order.productLogs
   */
  export type Order$productLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductLog
     */
    select?: ProductLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductLog
     */
    omit?: ProductLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductLogInclude<ExtArgs> | null
    where?: ProductLogWhereInput
    orderBy?: ProductLogOrderByWithRelationInput | ProductLogOrderByWithRelationInput[]
    cursor?: ProductLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductLogScalarFieldEnum | ProductLogScalarFieldEnum[]
  }

  /**
   * Order.reviews
   */
  export type Order$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    priceVnd: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    priceVnd: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    priceVnd: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
    priceVnd: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    priceVnd: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    priceVnd?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    priceVnd?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceVnd?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceVnd?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceVnd?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    priceVnd: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    priceVnd?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>



  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    priceVnd?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity" | "priceVnd", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
      priceVnd: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly priceVnd: FieldRef<"OrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amountVnd: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amountVnd: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: $Enums.PaymentProvider | null
    providerTxid: string | null
    amountVnd: number | null
    rawJson: string | null
    matchedBy: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    provider: $Enums.PaymentProvider | null
    providerTxid: string | null
    amountVnd: number | null
    rawJson: string | null
    matchedBy: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    provider: number
    providerTxid: number
    amountVnd: number
    rawJson: number
    matchedBy: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amountVnd?: true
  }

  export type PaymentSumAggregateInputType = {
    amountVnd?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    providerTxid?: true
    amountVnd?: true
    rawJson?: true
    matchedBy?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    providerTxid?: true
    amountVnd?: true
    rawJson?: true
    matchedBy?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    provider?: true
    providerTxid?: true
    amountVnd?: true
    rawJson?: true
    matchedBy?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    provider: $Enums.PaymentProvider
    providerTxid: string | null
    amountVnd: number
    rawJson: string | null
    matchedBy: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    provider?: boolean
    providerTxid?: boolean
    amountVnd?: boolean
    rawJson?: boolean
    matchedBy?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    provider?: boolean
    providerTxid?: boolean
    amountVnd?: boolean
    rawJson?: boolean
    matchedBy?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "provider" | "providerTxid" | "amountVnd" | "rawJson" | "matchedBy" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      provider: $Enums.PaymentProvider
      providerTxid: string | null
      amountVnd: number
      rawJson: string | null
      matchedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'PaymentProvider'>
    readonly providerTxid: FieldRef<"Payment", 'String'>
    readonly amountVnd: FieldRef<"Payment", 'Float'>
    readonly rawJson: FieldRef<"Payment", 'String'>
    readonly matchedBy: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ManualDepositRequest
   */

  export type AggregateManualDepositRequest = {
    _count: ManualDepositRequestCountAggregateOutputType | null
    _avg: ManualDepositRequestAvgAggregateOutputType | null
    _sum: ManualDepositRequestSumAggregateOutputType | null
    _min: ManualDepositRequestMinAggregateOutputType | null
    _max: ManualDepositRequestMaxAggregateOutputType | null
  }

  export type ManualDepositRequestAvgAggregateOutputType = {
    id: number | null
    amountVnd: number | null
  }

  export type ManualDepositRequestSumAggregateOutputType = {
    id: number | null
    amountVnd: number | null
  }

  export type ManualDepositRequestMinAggregateOutputType = {
    id: number | null
    internalId: string | null
    userId: string | null
    amountVnd: number | null
    note: string | null
    qrCode: string | null
    transferContent: string | null
    status: $Enums.DepositStatus | null
    adminNote: string | null
    decidedAt: Date | null
    createdAt: Date | null
  }

  export type ManualDepositRequestMaxAggregateOutputType = {
    id: number | null
    internalId: string | null
    userId: string | null
    amountVnd: number | null
    note: string | null
    qrCode: string | null
    transferContent: string | null
    status: $Enums.DepositStatus | null
    adminNote: string | null
    decidedAt: Date | null
    createdAt: Date | null
  }

  export type ManualDepositRequestCountAggregateOutputType = {
    id: number
    internalId: number
    userId: number
    amountVnd: number
    note: number
    qrCode: number
    transferContent: number
    status: number
    adminNote: number
    decidedAt: number
    createdAt: number
    _all: number
  }


  export type ManualDepositRequestAvgAggregateInputType = {
    id?: true
    amountVnd?: true
  }

  export type ManualDepositRequestSumAggregateInputType = {
    id?: true
    amountVnd?: true
  }

  export type ManualDepositRequestMinAggregateInputType = {
    id?: true
    internalId?: true
    userId?: true
    amountVnd?: true
    note?: true
    qrCode?: true
    transferContent?: true
    status?: true
    adminNote?: true
    decidedAt?: true
    createdAt?: true
  }

  export type ManualDepositRequestMaxAggregateInputType = {
    id?: true
    internalId?: true
    userId?: true
    amountVnd?: true
    note?: true
    qrCode?: true
    transferContent?: true
    status?: true
    adminNote?: true
    decidedAt?: true
    createdAt?: true
  }

  export type ManualDepositRequestCountAggregateInputType = {
    id?: true
    internalId?: true
    userId?: true
    amountVnd?: true
    note?: true
    qrCode?: true
    transferContent?: true
    status?: true
    adminNote?: true
    decidedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ManualDepositRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualDepositRequest to aggregate.
     */
    where?: ManualDepositRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDepositRequests to fetch.
     */
    orderBy?: ManualDepositRequestOrderByWithRelationInput | ManualDepositRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualDepositRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDepositRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDepositRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualDepositRequests
    **/
    _count?: true | ManualDepositRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManualDepositRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManualDepositRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualDepositRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualDepositRequestMaxAggregateInputType
  }

  export type GetManualDepositRequestAggregateType<T extends ManualDepositRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateManualDepositRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualDepositRequest[P]>
      : GetScalarType<T[P], AggregateManualDepositRequest[P]>
  }




  export type ManualDepositRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualDepositRequestWhereInput
    orderBy?: ManualDepositRequestOrderByWithAggregationInput | ManualDepositRequestOrderByWithAggregationInput[]
    by: ManualDepositRequestScalarFieldEnum[] | ManualDepositRequestScalarFieldEnum
    having?: ManualDepositRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualDepositRequestCountAggregateInputType | true
    _avg?: ManualDepositRequestAvgAggregateInputType
    _sum?: ManualDepositRequestSumAggregateInputType
    _min?: ManualDepositRequestMinAggregateInputType
    _max?: ManualDepositRequestMaxAggregateInputType
  }

  export type ManualDepositRequestGroupByOutputType = {
    id: number
    internalId: string | null
    userId: string
    amountVnd: number
    note: string | null
    qrCode: string | null
    transferContent: string | null
    status: $Enums.DepositStatus
    adminNote: string | null
    decidedAt: Date | null
    createdAt: Date
    _count: ManualDepositRequestCountAggregateOutputType | null
    _avg: ManualDepositRequestAvgAggregateOutputType | null
    _sum: ManualDepositRequestSumAggregateOutputType | null
    _min: ManualDepositRequestMinAggregateOutputType | null
    _max: ManualDepositRequestMaxAggregateOutputType | null
  }

  type GetManualDepositRequestGroupByPayload<T extends ManualDepositRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualDepositRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualDepositRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualDepositRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ManualDepositRequestGroupByOutputType[P]>
        }
      >
    >


  export type ManualDepositRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    internalId?: boolean
    userId?: boolean
    amountVnd?: boolean
    note?: boolean
    qrCode?: boolean
    transferContent?: boolean
    status?: boolean
    adminNote?: boolean
    decidedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualDepositRequest"]>



  export type ManualDepositRequestSelectScalar = {
    id?: boolean
    internalId?: boolean
    userId?: boolean
    amountVnd?: boolean
    note?: boolean
    qrCode?: boolean
    transferContent?: boolean
    status?: boolean
    adminNote?: boolean
    decidedAt?: boolean
    createdAt?: boolean
  }

  export type ManualDepositRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "internalId" | "userId" | "amountVnd" | "note" | "qrCode" | "transferContent" | "status" | "adminNote" | "decidedAt" | "createdAt", ExtArgs["result"]["manualDepositRequest"]>
  export type ManualDepositRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ManualDepositRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualDepositRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      internalId: string | null
      userId: string
      amountVnd: number
      note: string | null
      qrCode: string | null
      transferContent: string | null
      status: $Enums.DepositStatus
      adminNote: string | null
      decidedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["manualDepositRequest"]>
    composites: {}
  }

  type ManualDepositRequestGetPayload<S extends boolean | null | undefined | ManualDepositRequestDefaultArgs> = $Result.GetResult<Prisma.$ManualDepositRequestPayload, S>

  type ManualDepositRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualDepositRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualDepositRequestCountAggregateInputType | true
    }

  export interface ManualDepositRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualDepositRequest'], meta: { name: 'ManualDepositRequest' } }
    /**
     * Find zero or one ManualDepositRequest that matches the filter.
     * @param {ManualDepositRequestFindUniqueArgs} args - Arguments to find a ManualDepositRequest
     * @example
     * // Get one ManualDepositRequest
     * const manualDepositRequest = await prisma.manualDepositRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualDepositRequestFindUniqueArgs>(args: SelectSubset<T, ManualDepositRequestFindUniqueArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualDepositRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualDepositRequestFindUniqueOrThrowArgs} args - Arguments to find a ManualDepositRequest
     * @example
     * // Get one ManualDepositRequest
     * const manualDepositRequest = await prisma.manualDepositRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualDepositRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualDepositRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualDepositRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestFindFirstArgs} args - Arguments to find a ManualDepositRequest
     * @example
     * // Get one ManualDepositRequest
     * const manualDepositRequest = await prisma.manualDepositRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualDepositRequestFindFirstArgs>(args?: SelectSubset<T, ManualDepositRequestFindFirstArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualDepositRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestFindFirstOrThrowArgs} args - Arguments to find a ManualDepositRequest
     * @example
     * // Get one ManualDepositRequest
     * const manualDepositRequest = await prisma.manualDepositRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualDepositRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualDepositRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualDepositRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualDepositRequests
     * const manualDepositRequests = await prisma.manualDepositRequest.findMany()
     * 
     * // Get first 10 ManualDepositRequests
     * const manualDepositRequests = await prisma.manualDepositRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualDepositRequestWithIdOnly = await prisma.manualDepositRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualDepositRequestFindManyArgs>(args?: SelectSubset<T, ManualDepositRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualDepositRequest.
     * @param {ManualDepositRequestCreateArgs} args - Arguments to create a ManualDepositRequest.
     * @example
     * // Create one ManualDepositRequest
     * const ManualDepositRequest = await prisma.manualDepositRequest.create({
     *   data: {
     *     // ... data to create a ManualDepositRequest
     *   }
     * })
     * 
     */
    create<T extends ManualDepositRequestCreateArgs>(args: SelectSubset<T, ManualDepositRequestCreateArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualDepositRequests.
     * @param {ManualDepositRequestCreateManyArgs} args - Arguments to create many ManualDepositRequests.
     * @example
     * // Create many ManualDepositRequests
     * const manualDepositRequest = await prisma.manualDepositRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualDepositRequestCreateManyArgs>(args?: SelectSubset<T, ManualDepositRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ManualDepositRequest.
     * @param {ManualDepositRequestDeleteArgs} args - Arguments to delete one ManualDepositRequest.
     * @example
     * // Delete one ManualDepositRequest
     * const ManualDepositRequest = await prisma.manualDepositRequest.delete({
     *   where: {
     *     // ... filter to delete one ManualDepositRequest
     *   }
     * })
     * 
     */
    delete<T extends ManualDepositRequestDeleteArgs>(args: SelectSubset<T, ManualDepositRequestDeleteArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualDepositRequest.
     * @param {ManualDepositRequestUpdateArgs} args - Arguments to update one ManualDepositRequest.
     * @example
     * // Update one ManualDepositRequest
     * const manualDepositRequest = await prisma.manualDepositRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualDepositRequestUpdateArgs>(args: SelectSubset<T, ManualDepositRequestUpdateArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualDepositRequests.
     * @param {ManualDepositRequestDeleteManyArgs} args - Arguments to filter ManualDepositRequests to delete.
     * @example
     * // Delete a few ManualDepositRequests
     * const { count } = await prisma.manualDepositRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualDepositRequestDeleteManyArgs>(args?: SelectSubset<T, ManualDepositRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualDepositRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualDepositRequests
     * const manualDepositRequest = await prisma.manualDepositRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualDepositRequestUpdateManyArgs>(args: SelectSubset<T, ManualDepositRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManualDepositRequest.
     * @param {ManualDepositRequestUpsertArgs} args - Arguments to update or create a ManualDepositRequest.
     * @example
     * // Update or create a ManualDepositRequest
     * const manualDepositRequest = await prisma.manualDepositRequest.upsert({
     *   create: {
     *     // ... data to create a ManualDepositRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualDepositRequest we want to update
     *   }
     * })
     */
    upsert<T extends ManualDepositRequestUpsertArgs>(args: SelectSubset<T, ManualDepositRequestUpsertArgs<ExtArgs>>): Prisma__ManualDepositRequestClient<$Result.GetResult<Prisma.$ManualDepositRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualDepositRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestCountArgs} args - Arguments to filter ManualDepositRequests to count.
     * @example
     * // Count the number of ManualDepositRequests
     * const count = await prisma.manualDepositRequest.count({
     *   where: {
     *     // ... the filter for the ManualDepositRequests we want to count
     *   }
     * })
    **/
    count<T extends ManualDepositRequestCountArgs>(
      args?: Subset<T, ManualDepositRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualDepositRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualDepositRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualDepositRequestAggregateArgs>(args: Subset<T, ManualDepositRequestAggregateArgs>): Prisma.PrismaPromise<GetManualDepositRequestAggregateType<T>>

    /**
     * Group by ManualDepositRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualDepositRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualDepositRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualDepositRequestGroupByArgs['orderBy'] }
        : { orderBy?: ManualDepositRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualDepositRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualDepositRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualDepositRequest model
   */
  readonly fields: ManualDepositRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualDepositRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualDepositRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualDepositRequest model
   */
  interface ManualDepositRequestFieldRefs {
    readonly id: FieldRef<"ManualDepositRequest", 'Int'>
    readonly internalId: FieldRef<"ManualDepositRequest", 'String'>
    readonly userId: FieldRef<"ManualDepositRequest", 'String'>
    readonly amountVnd: FieldRef<"ManualDepositRequest", 'Float'>
    readonly note: FieldRef<"ManualDepositRequest", 'String'>
    readonly qrCode: FieldRef<"ManualDepositRequest", 'String'>
    readonly transferContent: FieldRef<"ManualDepositRequest", 'String'>
    readonly status: FieldRef<"ManualDepositRequest", 'DepositStatus'>
    readonly adminNote: FieldRef<"ManualDepositRequest", 'String'>
    readonly decidedAt: FieldRef<"ManualDepositRequest", 'DateTime'>
    readonly createdAt: FieldRef<"ManualDepositRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManualDepositRequest findUnique
   */
  export type ManualDepositRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * Filter, which ManualDepositRequest to fetch.
     */
    where: ManualDepositRequestWhereUniqueInput
  }

  /**
   * ManualDepositRequest findUniqueOrThrow
   */
  export type ManualDepositRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * Filter, which ManualDepositRequest to fetch.
     */
    where: ManualDepositRequestWhereUniqueInput
  }

  /**
   * ManualDepositRequest findFirst
   */
  export type ManualDepositRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * Filter, which ManualDepositRequest to fetch.
     */
    where?: ManualDepositRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDepositRequests to fetch.
     */
    orderBy?: ManualDepositRequestOrderByWithRelationInput | ManualDepositRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualDepositRequests.
     */
    cursor?: ManualDepositRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDepositRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDepositRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualDepositRequests.
     */
    distinct?: ManualDepositRequestScalarFieldEnum | ManualDepositRequestScalarFieldEnum[]
  }

  /**
   * ManualDepositRequest findFirstOrThrow
   */
  export type ManualDepositRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * Filter, which ManualDepositRequest to fetch.
     */
    where?: ManualDepositRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDepositRequests to fetch.
     */
    orderBy?: ManualDepositRequestOrderByWithRelationInput | ManualDepositRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualDepositRequests.
     */
    cursor?: ManualDepositRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDepositRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDepositRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualDepositRequests.
     */
    distinct?: ManualDepositRequestScalarFieldEnum | ManualDepositRequestScalarFieldEnum[]
  }

  /**
   * ManualDepositRequest findMany
   */
  export type ManualDepositRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * Filter, which ManualDepositRequests to fetch.
     */
    where?: ManualDepositRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualDepositRequests to fetch.
     */
    orderBy?: ManualDepositRequestOrderByWithRelationInput | ManualDepositRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualDepositRequests.
     */
    cursor?: ManualDepositRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualDepositRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualDepositRequests.
     */
    skip?: number
    distinct?: ManualDepositRequestScalarFieldEnum | ManualDepositRequestScalarFieldEnum[]
  }

  /**
   * ManualDepositRequest create
   */
  export type ManualDepositRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ManualDepositRequest.
     */
    data: XOR<ManualDepositRequestCreateInput, ManualDepositRequestUncheckedCreateInput>
  }

  /**
   * ManualDepositRequest createMany
   */
  export type ManualDepositRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualDepositRequests.
     */
    data: ManualDepositRequestCreateManyInput | ManualDepositRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualDepositRequest update
   */
  export type ManualDepositRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ManualDepositRequest.
     */
    data: XOR<ManualDepositRequestUpdateInput, ManualDepositRequestUncheckedUpdateInput>
    /**
     * Choose, which ManualDepositRequest to update.
     */
    where: ManualDepositRequestWhereUniqueInput
  }

  /**
   * ManualDepositRequest updateMany
   */
  export type ManualDepositRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualDepositRequests.
     */
    data: XOR<ManualDepositRequestUpdateManyMutationInput, ManualDepositRequestUncheckedUpdateManyInput>
    /**
     * Filter which ManualDepositRequests to update
     */
    where?: ManualDepositRequestWhereInput
    /**
     * Limit how many ManualDepositRequests to update.
     */
    limit?: number
  }

  /**
   * ManualDepositRequest upsert
   */
  export type ManualDepositRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ManualDepositRequest to update in case it exists.
     */
    where: ManualDepositRequestWhereUniqueInput
    /**
     * In case the ManualDepositRequest found by the `where` argument doesn't exist, create a new ManualDepositRequest with this data.
     */
    create: XOR<ManualDepositRequestCreateInput, ManualDepositRequestUncheckedCreateInput>
    /**
     * In case the ManualDepositRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualDepositRequestUpdateInput, ManualDepositRequestUncheckedUpdateInput>
  }

  /**
   * ManualDepositRequest delete
   */
  export type ManualDepositRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
    /**
     * Filter which ManualDepositRequest to delete.
     */
    where: ManualDepositRequestWhereUniqueInput
  }

  /**
   * ManualDepositRequest deleteMany
   */
  export type ManualDepositRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualDepositRequests to delete
     */
    where?: ManualDepositRequestWhereInput
    /**
     * Limit how many ManualDepositRequests to delete.
     */
    limit?: number
  }

  /**
   * ManualDepositRequest without action
   */
  export type ManualDepositRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualDepositRequest
     */
    select?: ManualDepositRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualDepositRequest
     */
    omit?: ManualDepositRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualDepositRequestInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    discountValue: number | null
    maxDiscountVnd: number | null
    minOrderVnd: number | null
    maxUses: number | null
    usedCount: number | null
  }

  export type CouponSumAggregateOutputType = {
    discountValue: number | null
    maxDiscountVnd: number | null
    minOrderVnd: number | null
    maxUses: number | null
    usedCount: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    maxDiscountVnd: number | null
    minOrderVnd: number | null
    maxUses: number | null
    usedCount: number | null
    startDate: Date | null
    expiryDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    maxDiscountVnd: number | null
    minOrderVnd: number | null
    maxUses: number | null
    usedCount: number | null
    startDate: Date | null
    expiryDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    maxDiscountVnd: number
    minOrderVnd: number
    maxUses: number
    usedCount: number
    startDate: number
    expiryDate: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    discountValue?: true
    maxDiscountVnd?: true
    minOrderVnd?: true
    maxUses?: true
    usedCount?: true
  }

  export type CouponSumAggregateInputType = {
    discountValue?: true
    maxDiscountVnd?: true
    minOrderVnd?: true
    maxUses?: true
    usedCount?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    maxDiscountVnd?: true
    minOrderVnd?: true
    maxUses?: true
    usedCount?: true
    startDate?: true
    expiryDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    maxDiscountVnd?: true
    minOrderVnd?: true
    maxUses?: true
    usedCount?: true
    startDate?: true
    expiryDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    maxDiscountVnd?: true
    minOrderVnd?: true
    maxUses?: true
    usedCount?: true
    startDate?: true
    expiryDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    description: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    maxDiscountVnd: number | null
    minOrderVnd: number
    maxUses: number | null
    usedCount: number
    startDate: Date | null
    expiryDate: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    maxDiscountVnd?: boolean
    minOrderVnd?: boolean
    maxUses?: boolean
    usedCount?: boolean
    startDate?: boolean
    expiryDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["coupon"]>



  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    maxDiscountVnd?: boolean
    minOrderVnd?: boolean
    maxUses?: boolean
    usedCount?: boolean
    startDate?: boolean
    expiryDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discountType" | "discountValue" | "maxDiscountVnd" | "minOrderVnd" | "maxUses" | "usedCount" | "startDate" | "expiryDate" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["coupon"]>

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      discountType: $Enums.DiscountType
      discountValue: number
      maxDiscountVnd: number | null
      minOrderVnd: number
      maxUses: number | null
      usedCount: number
      startDate: Date | null
      expiryDate: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly description: FieldRef<"Coupon", 'String'>
    readonly discountType: FieldRef<"Coupon", 'DiscountType'>
    readonly discountValue: FieldRef<"Coupon", 'Float'>
    readonly maxDiscountVnd: FieldRef<"Coupon", 'Float'>
    readonly minOrderVnd: FieldRef<"Coupon", 'Float'>
    readonly maxUses: FieldRef<"Coupon", 'Int'>
    readonly usedCount: FieldRef<"Coupon", 'Int'>
    readonly startDate: FieldRef<"Coupon", 'DateTime'>
    readonly expiryDate: FieldRef<"Coupon", 'DateTime'>
    readonly active: FieldRef<"Coupon", 'Boolean'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    websiteName: string | null
    websiteTitle: string | null
    websiteDescription: string | null
    websiteKeywords: string | null
    websiteLogo: string | null
    websiteFavicon: string | null
    copyrightYear: string | null
    supportEmail: string | null
    contactInfo: string | null
    paymentMethods: string | null
    bankInfo: string | null
    topupRules: string | null
    tpbankConfig: string | null
    depositBonusTiers: string | null
    referralSettings: string | null
    uiTexts: string | null
    themeSettings: string | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    websiteName: string | null
    websiteTitle: string | null
    websiteDescription: string | null
    websiteKeywords: string | null
    websiteLogo: string | null
    websiteFavicon: string | null
    copyrightYear: string | null
    supportEmail: string | null
    contactInfo: string | null
    paymentMethods: string | null
    bankInfo: string | null
    topupRules: string | null
    tpbankConfig: string | null
    depositBonusTiers: string | null
    referralSettings: string | null
    uiTexts: string | null
    themeSettings: string | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    websiteName: number
    websiteTitle: number
    websiteDescription: number
    websiteKeywords: number
    websiteLogo: number
    websiteFavicon: number
    copyrightYear: number
    supportEmail: number
    contactInfo: number
    paymentMethods: number
    bankInfo: number
    topupRules: number
    tpbankConfig: number
    depositBonusTiers: number
    referralSettings: number
    uiTexts: number
    themeSettings: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    websiteName?: true
    websiteTitle?: true
    websiteDescription?: true
    websiteKeywords?: true
    websiteLogo?: true
    websiteFavicon?: true
    copyrightYear?: true
    supportEmail?: true
    contactInfo?: true
    paymentMethods?: true
    bankInfo?: true
    topupRules?: true
    tpbankConfig?: true
    depositBonusTiers?: true
    referralSettings?: true
    uiTexts?: true
    themeSettings?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    websiteName?: true
    websiteTitle?: true
    websiteDescription?: true
    websiteKeywords?: true
    websiteLogo?: true
    websiteFavicon?: true
    copyrightYear?: true
    supportEmail?: true
    contactInfo?: true
    paymentMethods?: true
    bankInfo?: true
    topupRules?: true
    tpbankConfig?: true
    depositBonusTiers?: true
    referralSettings?: true
    uiTexts?: true
    themeSettings?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    websiteName?: true
    websiteTitle?: true
    websiteDescription?: true
    websiteKeywords?: true
    websiteLogo?: true
    websiteFavicon?: true
    copyrightYear?: true
    supportEmail?: true
    contactInfo?: true
    paymentMethods?: true
    bankInfo?: true
    topupRules?: true
    tpbankConfig?: true
    depositBonusTiers?: true
    referralSettings?: true
    uiTexts?: true
    themeSettings?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    websiteName: string
    websiteTitle: string
    websiteDescription: string
    websiteKeywords: string
    websiteLogo: string | null
    websiteFavicon: string | null
    copyrightYear: string
    supportEmail: string
    contactInfo: string
    paymentMethods: string
    bankInfo: string
    topupRules: string
    tpbankConfig: string
    depositBonusTiers: string
    referralSettings: string
    uiTexts: string
    themeSettings: string
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteName?: boolean
    websiteTitle?: boolean
    websiteDescription?: boolean
    websiteKeywords?: boolean
    websiteLogo?: boolean
    websiteFavicon?: boolean
    copyrightYear?: boolean
    supportEmail?: boolean
    contactInfo?: boolean
    paymentMethods?: boolean
    bankInfo?: boolean
    topupRules?: boolean
    tpbankConfig?: boolean
    depositBonusTiers?: boolean
    referralSettings?: boolean
    uiTexts?: boolean
    themeSettings?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["settings"]>



  export type SettingsSelectScalar = {
    id?: boolean
    websiteName?: boolean
    websiteTitle?: boolean
    websiteDescription?: boolean
    websiteKeywords?: boolean
    websiteLogo?: boolean
    websiteFavicon?: boolean
    copyrightYear?: boolean
    supportEmail?: boolean
    contactInfo?: boolean
    paymentMethods?: boolean
    bankInfo?: boolean
    topupRules?: boolean
    tpbankConfig?: boolean
    depositBonusTiers?: boolean
    referralSettings?: boolean
    uiTexts?: boolean
    themeSettings?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "websiteName" | "websiteTitle" | "websiteDescription" | "websiteKeywords" | "websiteLogo" | "websiteFavicon" | "copyrightYear" | "supportEmail" | "contactInfo" | "paymentMethods" | "bankInfo" | "topupRules" | "tpbankConfig" | "depositBonusTiers" | "referralSettings" | "uiTexts" | "themeSettings" | "updatedAt", ExtArgs["result"]["settings"]>

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      websiteName: string
      websiteTitle: string
      websiteDescription: string
      websiteKeywords: string
      websiteLogo: string | null
      websiteFavicon: string | null
      copyrightYear: string
      supportEmail: string
      contactInfo: string
      paymentMethods: string
      bankInfo: string
      topupRules: string
      tpbankConfig: string
      depositBonusTiers: string
      referralSettings: string
      uiTexts: string
      themeSettings: string
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly websiteName: FieldRef<"Settings", 'String'>
    readonly websiteTitle: FieldRef<"Settings", 'String'>
    readonly websiteDescription: FieldRef<"Settings", 'String'>
    readonly websiteKeywords: FieldRef<"Settings", 'String'>
    readonly websiteLogo: FieldRef<"Settings", 'String'>
    readonly websiteFavicon: FieldRef<"Settings", 'String'>
    readonly copyrightYear: FieldRef<"Settings", 'String'>
    readonly supportEmail: FieldRef<"Settings", 'String'>
    readonly contactInfo: FieldRef<"Settings", 'String'>
    readonly paymentMethods: FieldRef<"Settings", 'String'>
    readonly bankInfo: FieldRef<"Settings", 'String'>
    readonly topupRules: FieldRef<"Settings", 'String'>
    readonly tpbankConfig: FieldRef<"Settings", 'String'>
    readonly depositBonusTiers: FieldRef<"Settings", 'String'>
    readonly referralSettings: FieldRef<"Settings", 'String'>
    readonly uiTexts: FieldRef<"Settings", 'String'>
    readonly themeSettings: FieldRef<"Settings", 'String'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
  }


  /**
   * Model DownloadLog
   */

  export type AggregateDownloadLog = {
    _count: DownloadLogCountAggregateOutputType | null
    _min: DownloadLogMinAggregateOutputType | null
    _max: DownloadLogMaxAggregateOutputType | null
  }

  export type DownloadLogMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    fileId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type DownloadLogMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    fileId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type DownloadLogCountAggregateOutputType = {
    id: number
    orderId: number
    fileId: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type DownloadLogMinAggregateInputType = {
    id?: true
    orderId?: true
    fileId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type DownloadLogMaxAggregateInputType = {
    id?: true
    orderId?: true
    fileId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type DownloadLogCountAggregateInputType = {
    id?: true
    orderId?: true
    fileId?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type DownloadLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadLog to aggregate.
     */
    where?: DownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadLogs to fetch.
     */
    orderBy?: DownloadLogOrderByWithRelationInput | DownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DownloadLogs
    **/
    _count?: true | DownloadLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DownloadLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DownloadLogMaxAggregateInputType
  }

  export type GetDownloadLogAggregateType<T extends DownloadLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDownloadLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDownloadLog[P]>
      : GetScalarType<T[P], AggregateDownloadLog[P]>
  }




  export type DownloadLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DownloadLogWhereInput
    orderBy?: DownloadLogOrderByWithAggregationInput | DownloadLogOrderByWithAggregationInput[]
    by: DownloadLogScalarFieldEnum[] | DownloadLogScalarFieldEnum
    having?: DownloadLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DownloadLogCountAggregateInputType | true
    _min?: DownloadLogMinAggregateInputType
    _max?: DownloadLogMaxAggregateInputType
  }

  export type DownloadLogGroupByOutputType = {
    id: string
    orderId: string
    fileId: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    _count: DownloadLogCountAggregateOutputType | null
    _min: DownloadLogMinAggregateOutputType | null
    _max: DownloadLogMaxAggregateOutputType | null
  }

  type GetDownloadLogGroupByPayload<T extends DownloadLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DownloadLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DownloadLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DownloadLogGroupByOutputType[P]>
            : GetScalarType<T[P], DownloadLogGroupByOutputType[P]>
        }
      >
    >


  export type DownloadLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    fileId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    file?: boolean | DownloadLog$fileArgs<ExtArgs>
  }, ExtArgs["result"]["downloadLog"]>



  export type DownloadLogSelectScalar = {
    id?: boolean
    orderId?: boolean
    fileId?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type DownloadLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "fileId" | "ip" | "userAgent" | "createdAt", ExtArgs["result"]["downloadLog"]>
  export type DownloadLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    file?: boolean | DownloadLog$fileArgs<ExtArgs>
  }

  export type $DownloadLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DownloadLog"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      file: Prisma.$FilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      fileId: string | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["downloadLog"]>
    composites: {}
  }

  type DownloadLogGetPayload<S extends boolean | null | undefined | DownloadLogDefaultArgs> = $Result.GetResult<Prisma.$DownloadLogPayload, S>

  type DownloadLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DownloadLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DownloadLogCountAggregateInputType | true
    }

  export interface DownloadLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DownloadLog'], meta: { name: 'DownloadLog' } }
    /**
     * Find zero or one DownloadLog that matches the filter.
     * @param {DownloadLogFindUniqueArgs} args - Arguments to find a DownloadLog
     * @example
     * // Get one DownloadLog
     * const downloadLog = await prisma.downloadLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DownloadLogFindUniqueArgs>(args: SelectSubset<T, DownloadLogFindUniqueArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DownloadLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DownloadLogFindUniqueOrThrowArgs} args - Arguments to find a DownloadLog
     * @example
     * // Get one DownloadLog
     * const downloadLog = await prisma.downloadLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DownloadLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DownloadLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DownloadLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogFindFirstArgs} args - Arguments to find a DownloadLog
     * @example
     * // Get one DownloadLog
     * const downloadLog = await prisma.downloadLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DownloadLogFindFirstArgs>(args?: SelectSubset<T, DownloadLogFindFirstArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DownloadLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogFindFirstOrThrowArgs} args - Arguments to find a DownloadLog
     * @example
     * // Get one DownloadLog
     * const downloadLog = await prisma.downloadLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DownloadLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DownloadLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DownloadLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DownloadLogs
     * const downloadLogs = await prisma.downloadLog.findMany()
     * 
     * // Get first 10 DownloadLogs
     * const downloadLogs = await prisma.downloadLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const downloadLogWithIdOnly = await prisma.downloadLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DownloadLogFindManyArgs>(args?: SelectSubset<T, DownloadLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DownloadLog.
     * @param {DownloadLogCreateArgs} args - Arguments to create a DownloadLog.
     * @example
     * // Create one DownloadLog
     * const DownloadLog = await prisma.downloadLog.create({
     *   data: {
     *     // ... data to create a DownloadLog
     *   }
     * })
     * 
     */
    create<T extends DownloadLogCreateArgs>(args: SelectSubset<T, DownloadLogCreateArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DownloadLogs.
     * @param {DownloadLogCreateManyArgs} args - Arguments to create many DownloadLogs.
     * @example
     * // Create many DownloadLogs
     * const downloadLog = await prisma.downloadLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DownloadLogCreateManyArgs>(args?: SelectSubset<T, DownloadLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DownloadLog.
     * @param {DownloadLogDeleteArgs} args - Arguments to delete one DownloadLog.
     * @example
     * // Delete one DownloadLog
     * const DownloadLog = await prisma.downloadLog.delete({
     *   where: {
     *     // ... filter to delete one DownloadLog
     *   }
     * })
     * 
     */
    delete<T extends DownloadLogDeleteArgs>(args: SelectSubset<T, DownloadLogDeleteArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DownloadLog.
     * @param {DownloadLogUpdateArgs} args - Arguments to update one DownloadLog.
     * @example
     * // Update one DownloadLog
     * const downloadLog = await prisma.downloadLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DownloadLogUpdateArgs>(args: SelectSubset<T, DownloadLogUpdateArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DownloadLogs.
     * @param {DownloadLogDeleteManyArgs} args - Arguments to filter DownloadLogs to delete.
     * @example
     * // Delete a few DownloadLogs
     * const { count } = await prisma.downloadLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DownloadLogDeleteManyArgs>(args?: SelectSubset<T, DownloadLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DownloadLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DownloadLogs
     * const downloadLog = await prisma.downloadLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DownloadLogUpdateManyArgs>(args: SelectSubset<T, DownloadLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DownloadLog.
     * @param {DownloadLogUpsertArgs} args - Arguments to update or create a DownloadLog.
     * @example
     * // Update or create a DownloadLog
     * const downloadLog = await prisma.downloadLog.upsert({
     *   create: {
     *     // ... data to create a DownloadLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DownloadLog we want to update
     *   }
     * })
     */
    upsert<T extends DownloadLogUpsertArgs>(args: SelectSubset<T, DownloadLogUpsertArgs<ExtArgs>>): Prisma__DownloadLogClient<$Result.GetResult<Prisma.$DownloadLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DownloadLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogCountArgs} args - Arguments to filter DownloadLogs to count.
     * @example
     * // Count the number of DownloadLogs
     * const count = await prisma.downloadLog.count({
     *   where: {
     *     // ... the filter for the DownloadLogs we want to count
     *   }
     * })
    **/
    count<T extends DownloadLogCountArgs>(
      args?: Subset<T, DownloadLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DownloadLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DownloadLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DownloadLogAggregateArgs>(args: Subset<T, DownloadLogAggregateArgs>): Prisma.PrismaPromise<GetDownloadLogAggregateType<T>>

    /**
     * Group by DownloadLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DownloadLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DownloadLogGroupByArgs['orderBy'] }
        : { orderBy?: DownloadLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DownloadLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDownloadLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DownloadLog model
   */
  readonly fields: DownloadLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DownloadLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DownloadLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends DownloadLog$fileArgs<ExtArgs> = {}>(args?: Subset<T, DownloadLog$fileArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DownloadLog model
   */
  interface DownloadLogFieldRefs {
    readonly id: FieldRef<"DownloadLog", 'String'>
    readonly orderId: FieldRef<"DownloadLog", 'String'>
    readonly fileId: FieldRef<"DownloadLog", 'String'>
    readonly ip: FieldRef<"DownloadLog", 'String'>
    readonly userAgent: FieldRef<"DownloadLog", 'String'>
    readonly createdAt: FieldRef<"DownloadLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DownloadLog findUnique
   */
  export type DownloadLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which DownloadLog to fetch.
     */
    where: DownloadLogWhereUniqueInput
  }

  /**
   * DownloadLog findUniqueOrThrow
   */
  export type DownloadLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which DownloadLog to fetch.
     */
    where: DownloadLogWhereUniqueInput
  }

  /**
   * DownloadLog findFirst
   */
  export type DownloadLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which DownloadLog to fetch.
     */
    where?: DownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadLogs to fetch.
     */
    orderBy?: DownloadLogOrderByWithRelationInput | DownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadLogs.
     */
    cursor?: DownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadLogs.
     */
    distinct?: DownloadLogScalarFieldEnum | DownloadLogScalarFieldEnum[]
  }

  /**
   * DownloadLog findFirstOrThrow
   */
  export type DownloadLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which DownloadLog to fetch.
     */
    where?: DownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadLogs to fetch.
     */
    orderBy?: DownloadLogOrderByWithRelationInput | DownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadLogs.
     */
    cursor?: DownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadLogs.
     */
    distinct?: DownloadLogScalarFieldEnum | DownloadLogScalarFieldEnum[]
  }

  /**
   * DownloadLog findMany
   */
  export type DownloadLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * Filter, which DownloadLogs to fetch.
     */
    where?: DownloadLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadLogs to fetch.
     */
    orderBy?: DownloadLogOrderByWithRelationInput | DownloadLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DownloadLogs.
     */
    cursor?: DownloadLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadLogs.
     */
    skip?: number
    distinct?: DownloadLogScalarFieldEnum | DownloadLogScalarFieldEnum[]
  }

  /**
   * DownloadLog create
   */
  export type DownloadLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DownloadLog.
     */
    data: XOR<DownloadLogCreateInput, DownloadLogUncheckedCreateInput>
  }

  /**
   * DownloadLog createMany
   */
  export type DownloadLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DownloadLogs.
     */
    data: DownloadLogCreateManyInput | DownloadLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DownloadLog update
   */
  export type DownloadLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DownloadLog.
     */
    data: XOR<DownloadLogUpdateInput, DownloadLogUncheckedUpdateInput>
    /**
     * Choose, which DownloadLog to update.
     */
    where: DownloadLogWhereUniqueInput
  }

  /**
   * DownloadLog updateMany
   */
  export type DownloadLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DownloadLogs.
     */
    data: XOR<DownloadLogUpdateManyMutationInput, DownloadLogUncheckedUpdateManyInput>
    /**
     * Filter which DownloadLogs to update
     */
    where?: DownloadLogWhereInput
    /**
     * Limit how many DownloadLogs to update.
     */
    limit?: number
  }

  /**
   * DownloadLog upsert
   */
  export type DownloadLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DownloadLog to update in case it exists.
     */
    where: DownloadLogWhereUniqueInput
    /**
     * In case the DownloadLog found by the `where` argument doesn't exist, create a new DownloadLog with this data.
     */
    create: XOR<DownloadLogCreateInput, DownloadLogUncheckedCreateInput>
    /**
     * In case the DownloadLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DownloadLogUpdateInput, DownloadLogUncheckedUpdateInput>
  }

  /**
   * DownloadLog delete
   */
  export type DownloadLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
    /**
     * Filter which DownloadLog to delete.
     */
    where: DownloadLogWhereUniqueInput
  }

  /**
   * DownloadLog deleteMany
   */
  export type DownloadLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadLogs to delete
     */
    where?: DownloadLogWhereInput
    /**
     * Limit how many DownloadLogs to delete.
     */
    limit?: number
  }

  /**
   * DownloadLog.file
   */
  export type DownloadLog$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * DownloadLog without action
   */
  export type DownloadLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadLog
     */
    select?: DownloadLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DownloadLog
     */
    omit?: DownloadLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DownloadLogInclude<ExtArgs> | null
  }


  /**
   * Model AdminActionLog
   */

  export type AggregateAdminActionLog = {
    _count: AdminActionLogCountAggregateOutputType | null
    _min: AdminActionLogMinAggregateOutputType | null
    _max: AdminActionLogMaxAggregateOutputType | null
  }

  export type AdminActionLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    diffJson: string | null
    createdAt: Date | null
  }

  export type AdminActionLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    diffJson: string | null
    createdAt: Date | null
  }

  export type AdminActionLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    targetType: number
    targetId: number
    diffJson: number
    createdAt: number
    _all: number
  }


  export type AdminActionLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    diffJson?: true
    createdAt?: true
  }

  export type AdminActionLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    diffJson?: true
    createdAt?: true
  }

  export type AdminActionLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    diffJson?: true
    createdAt?: true
    _all?: true
  }

  export type AdminActionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActionLog to aggregate.
     */
    where?: AdminActionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionLogs to fetch.
     */
    orderBy?: AdminActionLogOrderByWithRelationInput | AdminActionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminActionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminActionLogs
    **/
    _count?: true | AdminActionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminActionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminActionLogMaxAggregateInputType
  }

  export type GetAdminActionLogAggregateType<T extends AdminActionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminActionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminActionLog[P]>
      : GetScalarType<T[P], AggregateAdminActionLog[P]>
  }




  export type AdminActionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionLogWhereInput
    orderBy?: AdminActionLogOrderByWithAggregationInput | AdminActionLogOrderByWithAggregationInput[]
    by: AdminActionLogScalarFieldEnum[] | AdminActionLogScalarFieldEnum
    having?: AdminActionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminActionLogCountAggregateInputType | true
    _min?: AdminActionLogMinAggregateInputType
    _max?: AdminActionLogMaxAggregateInputType
  }

  export type AdminActionLogGroupByOutputType = {
    id: string
    adminId: string
    action: string
    targetType: string | null
    targetId: string | null
    diffJson: string | null
    createdAt: Date
    _count: AdminActionLogCountAggregateOutputType | null
    _min: AdminActionLogMinAggregateOutputType | null
    _max: AdminActionLogMaxAggregateOutputType | null
  }

  type GetAdminActionLogGroupByPayload<T extends AdminActionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminActionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminActionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminActionLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminActionLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminActionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    diffJson?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActionLog"]>



  export type AdminActionLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    diffJson?: boolean
    createdAt?: boolean
  }

  export type AdminActionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "targetType" | "targetId" | "diffJson" | "createdAt", ExtArgs["result"]["adminActionLog"]>
  export type AdminActionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminActionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminActionLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      targetType: string | null
      targetId: string | null
      diffJson: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminActionLog"]>
    composites: {}
  }

  type AdminActionLogGetPayload<S extends boolean | null | undefined | AdminActionLogDefaultArgs> = $Result.GetResult<Prisma.$AdminActionLogPayload, S>

  type AdminActionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminActionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminActionLogCountAggregateInputType | true
    }

  export interface AdminActionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminActionLog'], meta: { name: 'AdminActionLog' } }
    /**
     * Find zero or one AdminActionLog that matches the filter.
     * @param {AdminActionLogFindUniqueArgs} args - Arguments to find a AdminActionLog
     * @example
     * // Get one AdminActionLog
     * const adminActionLog = await prisma.adminActionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminActionLogFindUniqueArgs>(args: SelectSubset<T, AdminActionLogFindUniqueArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminActionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminActionLogFindUniqueOrThrowArgs} args - Arguments to find a AdminActionLog
     * @example
     * // Get one AdminActionLog
     * const adminActionLog = await prisma.adminActionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminActionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminActionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminActionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogFindFirstArgs} args - Arguments to find a AdminActionLog
     * @example
     * // Get one AdminActionLog
     * const adminActionLog = await prisma.adminActionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminActionLogFindFirstArgs>(args?: SelectSubset<T, AdminActionLogFindFirstArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminActionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogFindFirstOrThrowArgs} args - Arguments to find a AdminActionLog
     * @example
     * // Get one AdminActionLog
     * const adminActionLog = await prisma.adminActionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminActionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminActionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminActionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminActionLogs
     * const adminActionLogs = await prisma.adminActionLog.findMany()
     * 
     * // Get first 10 AdminActionLogs
     * const adminActionLogs = await prisma.adminActionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminActionLogWithIdOnly = await prisma.adminActionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminActionLogFindManyArgs>(args?: SelectSubset<T, AdminActionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminActionLog.
     * @param {AdminActionLogCreateArgs} args - Arguments to create a AdminActionLog.
     * @example
     * // Create one AdminActionLog
     * const AdminActionLog = await prisma.adminActionLog.create({
     *   data: {
     *     // ... data to create a AdminActionLog
     *   }
     * })
     * 
     */
    create<T extends AdminActionLogCreateArgs>(args: SelectSubset<T, AdminActionLogCreateArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminActionLogs.
     * @param {AdminActionLogCreateManyArgs} args - Arguments to create many AdminActionLogs.
     * @example
     * // Create many AdminActionLogs
     * const adminActionLog = await prisma.adminActionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminActionLogCreateManyArgs>(args?: SelectSubset<T, AdminActionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdminActionLog.
     * @param {AdminActionLogDeleteArgs} args - Arguments to delete one AdminActionLog.
     * @example
     * // Delete one AdminActionLog
     * const AdminActionLog = await prisma.adminActionLog.delete({
     *   where: {
     *     // ... filter to delete one AdminActionLog
     *   }
     * })
     * 
     */
    delete<T extends AdminActionLogDeleteArgs>(args: SelectSubset<T, AdminActionLogDeleteArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminActionLog.
     * @param {AdminActionLogUpdateArgs} args - Arguments to update one AdminActionLog.
     * @example
     * // Update one AdminActionLog
     * const adminActionLog = await prisma.adminActionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminActionLogUpdateArgs>(args: SelectSubset<T, AdminActionLogUpdateArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminActionLogs.
     * @param {AdminActionLogDeleteManyArgs} args - Arguments to filter AdminActionLogs to delete.
     * @example
     * // Delete a few AdminActionLogs
     * const { count } = await prisma.adminActionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminActionLogDeleteManyArgs>(args?: SelectSubset<T, AdminActionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminActionLogs
     * const adminActionLog = await prisma.adminActionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminActionLogUpdateManyArgs>(args: SelectSubset<T, AdminActionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminActionLog.
     * @param {AdminActionLogUpsertArgs} args - Arguments to update or create a AdminActionLog.
     * @example
     * // Update or create a AdminActionLog
     * const adminActionLog = await prisma.adminActionLog.upsert({
     *   create: {
     *     // ... data to create a AdminActionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminActionLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminActionLogUpsertArgs>(args: SelectSubset<T, AdminActionLogUpsertArgs<ExtArgs>>): Prisma__AdminActionLogClient<$Result.GetResult<Prisma.$AdminActionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminActionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogCountArgs} args - Arguments to filter AdminActionLogs to count.
     * @example
     * // Count the number of AdminActionLogs
     * const count = await prisma.adminActionLog.count({
     *   where: {
     *     // ... the filter for the AdminActionLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminActionLogCountArgs>(
      args?: Subset<T, AdminActionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminActionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminActionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminActionLogAggregateArgs>(args: Subset<T, AdminActionLogAggregateArgs>): Prisma.PrismaPromise<GetAdminActionLogAggregateType<T>>

    /**
     * Group by AdminActionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminActionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminActionLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminActionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminActionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminActionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminActionLog model
   */
  readonly fields: AdminActionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminActionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminActionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminActionLog model
   */
  interface AdminActionLogFieldRefs {
    readonly id: FieldRef<"AdminActionLog", 'String'>
    readonly adminId: FieldRef<"AdminActionLog", 'String'>
    readonly action: FieldRef<"AdminActionLog", 'String'>
    readonly targetType: FieldRef<"AdminActionLog", 'String'>
    readonly targetId: FieldRef<"AdminActionLog", 'String'>
    readonly diffJson: FieldRef<"AdminActionLog", 'String'>
    readonly createdAt: FieldRef<"AdminActionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminActionLog findUnique
   */
  export type AdminActionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionLog to fetch.
     */
    where: AdminActionLogWhereUniqueInput
  }

  /**
   * AdminActionLog findUniqueOrThrow
   */
  export type AdminActionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionLog to fetch.
     */
    where: AdminActionLogWhereUniqueInput
  }

  /**
   * AdminActionLog findFirst
   */
  export type AdminActionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionLog to fetch.
     */
    where?: AdminActionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionLogs to fetch.
     */
    orderBy?: AdminActionLogOrderByWithRelationInput | AdminActionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActionLogs.
     */
    cursor?: AdminActionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActionLogs.
     */
    distinct?: AdminActionLogScalarFieldEnum | AdminActionLogScalarFieldEnum[]
  }

  /**
   * AdminActionLog findFirstOrThrow
   */
  export type AdminActionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionLog to fetch.
     */
    where?: AdminActionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionLogs to fetch.
     */
    orderBy?: AdminActionLogOrderByWithRelationInput | AdminActionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActionLogs.
     */
    cursor?: AdminActionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActionLogs.
     */
    distinct?: AdminActionLogScalarFieldEnum | AdminActionLogScalarFieldEnum[]
  }

  /**
   * AdminActionLog findMany
   */
  export type AdminActionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActionLogs to fetch.
     */
    where?: AdminActionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActionLogs to fetch.
     */
    orderBy?: AdminActionLogOrderByWithRelationInput | AdminActionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminActionLogs.
     */
    cursor?: AdminActionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActionLogs.
     */
    skip?: number
    distinct?: AdminActionLogScalarFieldEnum | AdminActionLogScalarFieldEnum[]
  }

  /**
   * AdminActionLog create
   */
  export type AdminActionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminActionLog.
     */
    data: XOR<AdminActionLogCreateInput, AdminActionLogUncheckedCreateInput>
  }

  /**
   * AdminActionLog createMany
   */
  export type AdminActionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminActionLogs.
     */
    data: AdminActionLogCreateManyInput | AdminActionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminActionLog update
   */
  export type AdminActionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminActionLog.
     */
    data: XOR<AdminActionLogUpdateInput, AdminActionLogUncheckedUpdateInput>
    /**
     * Choose, which AdminActionLog to update.
     */
    where: AdminActionLogWhereUniqueInput
  }

  /**
   * AdminActionLog updateMany
   */
  export type AdminActionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminActionLogs.
     */
    data: XOR<AdminActionLogUpdateManyMutationInput, AdminActionLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminActionLogs to update
     */
    where?: AdminActionLogWhereInput
    /**
     * Limit how many AdminActionLogs to update.
     */
    limit?: number
  }

  /**
   * AdminActionLog upsert
   */
  export type AdminActionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminActionLog to update in case it exists.
     */
    where: AdminActionLogWhereUniqueInput
    /**
     * In case the AdminActionLog found by the `where` argument doesn't exist, create a new AdminActionLog with this data.
     */
    create: XOR<AdminActionLogCreateInput, AdminActionLogUncheckedCreateInput>
    /**
     * In case the AdminActionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminActionLogUpdateInput, AdminActionLogUncheckedUpdateInput>
  }

  /**
   * AdminActionLog delete
   */
  export type AdminActionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
    /**
     * Filter which AdminActionLog to delete.
     */
    where: AdminActionLogWhereUniqueInput
  }

  /**
   * AdminActionLog deleteMany
   */
  export type AdminActionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActionLogs to delete
     */
    where?: AdminActionLogWhereInput
    /**
     * Limit how many AdminActionLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminActionLog without action
   */
  export type AdminActionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActionLog
     */
    select?: AdminActionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActionLog
     */
    omit?: AdminActionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionLogInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amountVnd: number | null
    balanceAfterVnd: number | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amountVnd: number | null
    balanceAfterVnd: number | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.WalletTransactionType | null
    amountVnd: number | null
    balanceAfterVnd: number | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.WalletTransactionType | null
    amountVnd: number | null
    balanceAfterVnd: number | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amountVnd: number
    balanceAfterVnd: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amountVnd?: true
    balanceAfterVnd?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amountVnd?: true
    balanceAfterVnd?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amountVnd?: true
    balanceAfterVnd?: true
    description?: true
    metadata?: true
    createdAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amountVnd?: true
    balanceAfterVnd?: true
    description?: true
    metadata?: true
    createdAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amountVnd?: true
    balanceAfterVnd?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.WalletTransactionType
    amountVnd: number
    balanceAfterVnd: number
    description: string | null
    metadata: string | null
    createdAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amountVnd?: boolean
    balanceAfterVnd?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["walletTransaction"]>



  export type WalletTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amountVnd?: boolean
    balanceAfterVnd?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "amountVnd" | "balanceAfterVnd" | "description" | "metadata" | "createdAt", ExtArgs["result"]["walletTransaction"]>

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.WalletTransactionType
      amountVnd: number
      balanceAfterVnd: number
      description: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly userId: FieldRef<"WalletTransaction", 'String'>
    readonly type: FieldRef<"WalletTransaction", 'WalletTransactionType'>
    readonly amountVnd: FieldRef<"WalletTransaction", 'Float'>
    readonly balanceAfterVnd: FieldRef<"WalletTransaction", 'Float'>
    readonly description: FieldRef<"WalletTransaction", 'String'>
    readonly metadata: FieldRef<"WalletTransaction", 'String'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
  }


  /**
   * Model WebsiteSettings
   */

  export type AggregateWebsiteSettings = {
    _count: WebsiteSettingsCountAggregateOutputType | null
    _min: WebsiteSettingsMinAggregateOutputType | null
    _max: WebsiteSettingsMaxAggregateOutputType | null
  }

  export type WebsiteSettingsMinAggregateOutputType = {
    key: string | null
    value: string | null
    updatedAt: Date | null
  }

  export type WebsiteSettingsMaxAggregateOutputType = {
    key: string | null
    value: string | null
    updatedAt: Date | null
  }

  export type WebsiteSettingsCountAggregateOutputType = {
    key: number
    value: number
    updatedAt: number
    _all: number
  }


  export type WebsiteSettingsMinAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
  }

  export type WebsiteSettingsMaxAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
  }

  export type WebsiteSettingsCountAggregateInputType = {
    key?: true
    value?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsiteSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteSettings to aggregate.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebsiteSettings
    **/
    _count?: true | WebsiteSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteSettingsMaxAggregateInputType
  }

  export type GetWebsiteSettingsAggregateType<T extends WebsiteSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsiteSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsiteSettings[P]>
      : GetScalarType<T[P], AggregateWebsiteSettings[P]>
  }




  export type WebsiteSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteSettingsWhereInput
    orderBy?: WebsiteSettingsOrderByWithAggregationInput | WebsiteSettingsOrderByWithAggregationInput[]
    by: WebsiteSettingsScalarFieldEnum[] | WebsiteSettingsScalarFieldEnum
    having?: WebsiteSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteSettingsCountAggregateInputType | true
    _min?: WebsiteSettingsMinAggregateInputType
    _max?: WebsiteSettingsMaxAggregateInputType
  }

  export type WebsiteSettingsGroupByOutputType = {
    key: string
    value: string
    updatedAt: Date
    _count: WebsiteSettingsCountAggregateOutputType | null
    _min: WebsiteSettingsMinAggregateOutputType | null
    _max: WebsiteSettingsMaxAggregateOutputType | null
  }

  type GetWebsiteSettingsGroupByPayload<T extends WebsiteSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteSettingsGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["websiteSettings"]>



  export type WebsiteSettingsSelectScalar = {
    key?: boolean
    value?: boolean
    updatedAt?: boolean
  }

  export type WebsiteSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "updatedAt", ExtArgs["result"]["websiteSettings"]>

  export type $WebsiteSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebsiteSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      updatedAt: Date
    }, ExtArgs["result"]["websiteSettings"]>
    composites: {}
  }

  type WebsiteSettingsGetPayload<S extends boolean | null | undefined | WebsiteSettingsDefaultArgs> = $Result.GetResult<Prisma.$WebsiteSettingsPayload, S>

  type WebsiteSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsiteSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsiteSettingsCountAggregateInputType | true
    }

  export interface WebsiteSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebsiteSettings'], meta: { name: 'WebsiteSettings' } }
    /**
     * Find zero or one WebsiteSettings that matches the filter.
     * @param {WebsiteSettingsFindUniqueArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsiteSettingsFindUniqueArgs>(args: SelectSubset<T, WebsiteSettingsFindUniqueArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebsiteSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsiteSettingsFindUniqueOrThrowArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsiteSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsiteSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsFindFirstArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsiteSettingsFindFirstArgs>(args?: SelectSubset<T, WebsiteSettingsFindFirstArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsFindFirstOrThrowArgs} args - Arguments to find a WebsiteSettings
     * @example
     * // Get one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsiteSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsiteSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebsiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findMany()
     * 
     * // Get first 10 WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const websiteSettingsWithKeyOnly = await prisma.websiteSettings.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends WebsiteSettingsFindManyArgs>(args?: SelectSubset<T, WebsiteSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebsiteSettings.
     * @param {WebsiteSettingsCreateArgs} args - Arguments to create a WebsiteSettings.
     * @example
     * // Create one WebsiteSettings
     * const WebsiteSettings = await prisma.websiteSettings.create({
     *   data: {
     *     // ... data to create a WebsiteSettings
     *   }
     * })
     * 
     */
    create<T extends WebsiteSettingsCreateArgs>(args: SelectSubset<T, WebsiteSettingsCreateArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebsiteSettings.
     * @param {WebsiteSettingsCreateManyArgs} args - Arguments to create many WebsiteSettings.
     * @example
     * // Create many WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsiteSettingsCreateManyArgs>(args?: SelectSubset<T, WebsiteSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WebsiteSettings.
     * @param {WebsiteSettingsDeleteArgs} args - Arguments to delete one WebsiteSettings.
     * @example
     * // Delete one WebsiteSettings
     * const WebsiteSettings = await prisma.websiteSettings.delete({
     *   where: {
     *     // ... filter to delete one WebsiteSettings
     *   }
     * })
     * 
     */
    delete<T extends WebsiteSettingsDeleteArgs>(args: SelectSubset<T, WebsiteSettingsDeleteArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebsiteSettings.
     * @param {WebsiteSettingsUpdateArgs} args - Arguments to update one WebsiteSettings.
     * @example
     * // Update one WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsiteSettingsUpdateArgs>(args: SelectSubset<T, WebsiteSettingsUpdateArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebsiteSettings.
     * @param {WebsiteSettingsDeleteManyArgs} args - Arguments to filter WebsiteSettings to delete.
     * @example
     * // Delete a few WebsiteSettings
     * const { count } = await prisma.websiteSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsiteSettingsDeleteManyArgs>(args?: SelectSubset<T, WebsiteSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsiteSettingsUpdateManyArgs>(args: SelectSubset<T, WebsiteSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebsiteSettings.
     * @param {WebsiteSettingsUpsertArgs} args - Arguments to update or create a WebsiteSettings.
     * @example
     * // Update or create a WebsiteSettings
     * const websiteSettings = await prisma.websiteSettings.upsert({
     *   create: {
     *     // ... data to create a WebsiteSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebsiteSettings we want to update
     *   }
     * })
     */
    upsert<T extends WebsiteSettingsUpsertArgs>(args: SelectSubset<T, WebsiteSettingsUpsertArgs<ExtArgs>>): Prisma__WebsiteSettingsClient<$Result.GetResult<Prisma.$WebsiteSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsCountArgs} args - Arguments to filter WebsiteSettings to count.
     * @example
     * // Count the number of WebsiteSettings
     * const count = await prisma.websiteSettings.count({
     *   where: {
     *     // ... the filter for the WebsiteSettings we want to count
     *   }
     * })
    **/
    count<T extends WebsiteSettingsCountArgs>(
      args?: Subset<T, WebsiteSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteSettingsAggregateArgs>(args: Subset<T, WebsiteSettingsAggregateArgs>): Prisma.PrismaPromise<GetWebsiteSettingsAggregateType<T>>

    /**
     * Group by WebsiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteSettingsGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebsiteSettings model
   */
  readonly fields: WebsiteSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebsiteSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebsiteSettings model
   */
  interface WebsiteSettingsFieldRefs {
    readonly key: FieldRef<"WebsiteSettings", 'String'>
    readonly value: FieldRef<"WebsiteSettings", 'String'>
    readonly updatedAt: FieldRef<"WebsiteSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebsiteSettings findUnique
   */
  export type WebsiteSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings findUniqueOrThrow
   */
  export type WebsiteSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings findFirst
   */
  export type WebsiteSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteSettings.
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteSettings.
     */
    distinct?: WebsiteSettingsScalarFieldEnum | WebsiteSettingsScalarFieldEnum[]
  }

  /**
   * WebsiteSettings findFirstOrThrow
   */
  export type WebsiteSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteSettings.
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteSettings.
     */
    distinct?: WebsiteSettingsScalarFieldEnum | WebsiteSettingsScalarFieldEnum[]
  }

  /**
   * WebsiteSettings findMany
   */
  export type WebsiteSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which WebsiteSettings to fetch.
     */
    where?: WebsiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteSettings to fetch.
     */
    orderBy?: WebsiteSettingsOrderByWithRelationInput | WebsiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebsiteSettings.
     */
    cursor?: WebsiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteSettings.
     */
    skip?: number
    distinct?: WebsiteSettingsScalarFieldEnum | WebsiteSettingsScalarFieldEnum[]
  }

  /**
   * WebsiteSettings create
   */
  export type WebsiteSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a WebsiteSettings.
     */
    data: XOR<WebsiteSettingsCreateInput, WebsiteSettingsUncheckedCreateInput>
  }

  /**
   * WebsiteSettings createMany
   */
  export type WebsiteSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebsiteSettings.
     */
    data: WebsiteSettingsCreateManyInput | WebsiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebsiteSettings update
   */
  export type WebsiteSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a WebsiteSettings.
     */
    data: XOR<WebsiteSettingsUpdateInput, WebsiteSettingsUncheckedUpdateInput>
    /**
     * Choose, which WebsiteSettings to update.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings updateMany
   */
  export type WebsiteSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebsiteSettings.
     */
    data: XOR<WebsiteSettingsUpdateManyMutationInput, WebsiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteSettings to update
     */
    where?: WebsiteSettingsWhereInput
    /**
     * Limit how many WebsiteSettings to update.
     */
    limit?: number
  }

  /**
   * WebsiteSettings upsert
   */
  export type WebsiteSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the WebsiteSettings to update in case it exists.
     */
    where: WebsiteSettingsWhereUniqueInput
    /**
     * In case the WebsiteSettings found by the `where` argument doesn't exist, create a new WebsiteSettings with this data.
     */
    create: XOR<WebsiteSettingsCreateInput, WebsiteSettingsUncheckedCreateInput>
    /**
     * In case the WebsiteSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteSettingsUpdateInput, WebsiteSettingsUncheckedUpdateInput>
  }

  /**
   * WebsiteSettings delete
   */
  export type WebsiteSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
    /**
     * Filter which WebsiteSettings to delete.
     */
    where: WebsiteSettingsWhereUniqueInput
  }

  /**
   * WebsiteSettings deleteMany
   */
  export type WebsiteSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteSettings to delete
     */
    where?: WebsiteSettingsWhereInput
    /**
     * Limit how many WebsiteSettings to delete.
     */
    limit?: number
  }

  /**
   * WebsiteSettings without action
   */
  export type WebsiteSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteSettings
     */
    select?: WebsiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteSettings
     */
    omit?: WebsiteSettingsOmit<ExtArgs> | null
  }


  /**
   * Model AutoTopupLog
   */

  export type AggregateAutoTopupLog = {
    _count: AutoTopupLogCountAggregateOutputType | null
    _avg: AutoTopupLogAvgAggregateOutputType | null
    _sum: AutoTopupLogSumAggregateOutputType | null
    _min: AutoTopupLogMinAggregateOutputType | null
    _max: AutoTopupLogMaxAggregateOutputType | null
  }

  export type AutoTopupLogAvgAggregateOutputType = {
    depositRequestId: number | null
    amountVnd: number | null
  }

  export type AutoTopupLogSumAggregateOutputType = {
    depositRequestId: number | null
    amountVnd: number | null
  }

  export type AutoTopupLogMinAggregateOutputType = {
    id: string | null
    bankTransactionId: string | null
    bankName: string | null
    depositRequestId: number | null
    userId: string | null
    topupCode: string | null
    amountVnd: number | null
    description: string | null
    status: $Enums.AutoTopupStatus | null
    errorMessage: string | null
    transactionDate: Date | null
    createdAt: Date | null
  }

  export type AutoTopupLogMaxAggregateOutputType = {
    id: string | null
    bankTransactionId: string | null
    bankName: string | null
    depositRequestId: number | null
    userId: string | null
    topupCode: string | null
    amountVnd: number | null
    description: string | null
    status: $Enums.AutoTopupStatus | null
    errorMessage: string | null
    transactionDate: Date | null
    createdAt: Date | null
  }

  export type AutoTopupLogCountAggregateOutputType = {
    id: number
    bankTransactionId: number
    bankName: number
    depositRequestId: number
    userId: number
    topupCode: number
    amountVnd: number
    description: number
    status: number
    errorMessage: number
    transactionDate: number
    createdAt: number
    _all: number
  }


  export type AutoTopupLogAvgAggregateInputType = {
    depositRequestId?: true
    amountVnd?: true
  }

  export type AutoTopupLogSumAggregateInputType = {
    depositRequestId?: true
    amountVnd?: true
  }

  export type AutoTopupLogMinAggregateInputType = {
    id?: true
    bankTransactionId?: true
    bankName?: true
    depositRequestId?: true
    userId?: true
    topupCode?: true
    amountVnd?: true
    description?: true
    status?: true
    errorMessage?: true
    transactionDate?: true
    createdAt?: true
  }

  export type AutoTopupLogMaxAggregateInputType = {
    id?: true
    bankTransactionId?: true
    bankName?: true
    depositRequestId?: true
    userId?: true
    topupCode?: true
    amountVnd?: true
    description?: true
    status?: true
    errorMessage?: true
    transactionDate?: true
    createdAt?: true
  }

  export type AutoTopupLogCountAggregateInputType = {
    id?: true
    bankTransactionId?: true
    bankName?: true
    depositRequestId?: true
    userId?: true
    topupCode?: true
    amountVnd?: true
    description?: true
    status?: true
    errorMessage?: true
    transactionDate?: true
    createdAt?: true
    _all?: true
  }

  export type AutoTopupLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoTopupLog to aggregate.
     */
    where?: AutoTopupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoTopupLogs to fetch.
     */
    orderBy?: AutoTopupLogOrderByWithRelationInput | AutoTopupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutoTopupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoTopupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoTopupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutoTopupLogs
    **/
    _count?: true | AutoTopupLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutoTopupLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutoTopupLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutoTopupLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutoTopupLogMaxAggregateInputType
  }

  export type GetAutoTopupLogAggregateType<T extends AutoTopupLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAutoTopupLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutoTopupLog[P]>
      : GetScalarType<T[P], AggregateAutoTopupLog[P]>
  }




  export type AutoTopupLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutoTopupLogWhereInput
    orderBy?: AutoTopupLogOrderByWithAggregationInput | AutoTopupLogOrderByWithAggregationInput[]
    by: AutoTopupLogScalarFieldEnum[] | AutoTopupLogScalarFieldEnum
    having?: AutoTopupLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutoTopupLogCountAggregateInputType | true
    _avg?: AutoTopupLogAvgAggregateInputType
    _sum?: AutoTopupLogSumAggregateInputType
    _min?: AutoTopupLogMinAggregateInputType
    _max?: AutoTopupLogMaxAggregateInputType
  }

  export type AutoTopupLogGroupByOutputType = {
    id: string
    bankTransactionId: string
    bankName: string
    depositRequestId: number | null
    userId: string | null
    topupCode: string
    amountVnd: number
    description: string
    status: $Enums.AutoTopupStatus
    errorMessage: string | null
    transactionDate: Date
    createdAt: Date
    _count: AutoTopupLogCountAggregateOutputType | null
    _avg: AutoTopupLogAvgAggregateOutputType | null
    _sum: AutoTopupLogSumAggregateOutputType | null
    _min: AutoTopupLogMinAggregateOutputType | null
    _max: AutoTopupLogMaxAggregateOutputType | null
  }

  type GetAutoTopupLogGroupByPayload<T extends AutoTopupLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutoTopupLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutoTopupLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutoTopupLogGroupByOutputType[P]>
            : GetScalarType<T[P], AutoTopupLogGroupByOutputType[P]>
        }
      >
    >


  export type AutoTopupLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankTransactionId?: boolean
    bankName?: boolean
    depositRequestId?: boolean
    userId?: boolean
    topupCode?: boolean
    amountVnd?: boolean
    description?: boolean
    status?: boolean
    errorMessage?: boolean
    transactionDate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["autoTopupLog"]>



  export type AutoTopupLogSelectScalar = {
    id?: boolean
    bankTransactionId?: boolean
    bankName?: boolean
    depositRequestId?: boolean
    userId?: boolean
    topupCode?: boolean
    amountVnd?: boolean
    description?: boolean
    status?: boolean
    errorMessage?: boolean
    transactionDate?: boolean
    createdAt?: boolean
  }

  export type AutoTopupLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankTransactionId" | "bankName" | "depositRequestId" | "userId" | "topupCode" | "amountVnd" | "description" | "status" | "errorMessage" | "transactionDate" | "createdAt", ExtArgs["result"]["autoTopupLog"]>

  export type $AutoTopupLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutoTopupLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankTransactionId: string
      bankName: string
      depositRequestId: number | null
      userId: string | null
      topupCode: string
      amountVnd: number
      description: string
      status: $Enums.AutoTopupStatus
      errorMessage: string | null
      transactionDate: Date
      createdAt: Date
    }, ExtArgs["result"]["autoTopupLog"]>
    composites: {}
  }

  type AutoTopupLogGetPayload<S extends boolean | null | undefined | AutoTopupLogDefaultArgs> = $Result.GetResult<Prisma.$AutoTopupLogPayload, S>

  type AutoTopupLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutoTopupLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutoTopupLogCountAggregateInputType | true
    }

  export interface AutoTopupLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutoTopupLog'], meta: { name: 'AutoTopupLog' } }
    /**
     * Find zero or one AutoTopupLog that matches the filter.
     * @param {AutoTopupLogFindUniqueArgs} args - Arguments to find a AutoTopupLog
     * @example
     * // Get one AutoTopupLog
     * const autoTopupLog = await prisma.autoTopupLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutoTopupLogFindUniqueArgs>(args: SelectSubset<T, AutoTopupLogFindUniqueArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutoTopupLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutoTopupLogFindUniqueOrThrowArgs} args - Arguments to find a AutoTopupLog
     * @example
     * // Get one AutoTopupLog
     * const autoTopupLog = await prisma.autoTopupLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutoTopupLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AutoTopupLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoTopupLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogFindFirstArgs} args - Arguments to find a AutoTopupLog
     * @example
     * // Get one AutoTopupLog
     * const autoTopupLog = await prisma.autoTopupLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutoTopupLogFindFirstArgs>(args?: SelectSubset<T, AutoTopupLogFindFirstArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutoTopupLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogFindFirstOrThrowArgs} args - Arguments to find a AutoTopupLog
     * @example
     * // Get one AutoTopupLog
     * const autoTopupLog = await prisma.autoTopupLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutoTopupLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AutoTopupLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutoTopupLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutoTopupLogs
     * const autoTopupLogs = await prisma.autoTopupLog.findMany()
     * 
     * // Get first 10 AutoTopupLogs
     * const autoTopupLogs = await prisma.autoTopupLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autoTopupLogWithIdOnly = await prisma.autoTopupLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutoTopupLogFindManyArgs>(args?: SelectSubset<T, AutoTopupLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutoTopupLog.
     * @param {AutoTopupLogCreateArgs} args - Arguments to create a AutoTopupLog.
     * @example
     * // Create one AutoTopupLog
     * const AutoTopupLog = await prisma.autoTopupLog.create({
     *   data: {
     *     // ... data to create a AutoTopupLog
     *   }
     * })
     * 
     */
    create<T extends AutoTopupLogCreateArgs>(args: SelectSubset<T, AutoTopupLogCreateArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutoTopupLogs.
     * @param {AutoTopupLogCreateManyArgs} args - Arguments to create many AutoTopupLogs.
     * @example
     * // Create many AutoTopupLogs
     * const autoTopupLog = await prisma.autoTopupLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutoTopupLogCreateManyArgs>(args?: SelectSubset<T, AutoTopupLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AutoTopupLog.
     * @param {AutoTopupLogDeleteArgs} args - Arguments to delete one AutoTopupLog.
     * @example
     * // Delete one AutoTopupLog
     * const AutoTopupLog = await prisma.autoTopupLog.delete({
     *   where: {
     *     // ... filter to delete one AutoTopupLog
     *   }
     * })
     * 
     */
    delete<T extends AutoTopupLogDeleteArgs>(args: SelectSubset<T, AutoTopupLogDeleteArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutoTopupLog.
     * @param {AutoTopupLogUpdateArgs} args - Arguments to update one AutoTopupLog.
     * @example
     * // Update one AutoTopupLog
     * const autoTopupLog = await prisma.autoTopupLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutoTopupLogUpdateArgs>(args: SelectSubset<T, AutoTopupLogUpdateArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutoTopupLogs.
     * @param {AutoTopupLogDeleteManyArgs} args - Arguments to filter AutoTopupLogs to delete.
     * @example
     * // Delete a few AutoTopupLogs
     * const { count } = await prisma.autoTopupLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutoTopupLogDeleteManyArgs>(args?: SelectSubset<T, AutoTopupLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutoTopupLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutoTopupLogs
     * const autoTopupLog = await prisma.autoTopupLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutoTopupLogUpdateManyArgs>(args: SelectSubset<T, AutoTopupLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AutoTopupLog.
     * @param {AutoTopupLogUpsertArgs} args - Arguments to update or create a AutoTopupLog.
     * @example
     * // Update or create a AutoTopupLog
     * const autoTopupLog = await prisma.autoTopupLog.upsert({
     *   create: {
     *     // ... data to create a AutoTopupLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutoTopupLog we want to update
     *   }
     * })
     */
    upsert<T extends AutoTopupLogUpsertArgs>(args: SelectSubset<T, AutoTopupLogUpsertArgs<ExtArgs>>): Prisma__AutoTopupLogClient<$Result.GetResult<Prisma.$AutoTopupLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutoTopupLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogCountArgs} args - Arguments to filter AutoTopupLogs to count.
     * @example
     * // Count the number of AutoTopupLogs
     * const count = await prisma.autoTopupLog.count({
     *   where: {
     *     // ... the filter for the AutoTopupLogs we want to count
     *   }
     * })
    **/
    count<T extends AutoTopupLogCountArgs>(
      args?: Subset<T, AutoTopupLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutoTopupLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutoTopupLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutoTopupLogAggregateArgs>(args: Subset<T, AutoTopupLogAggregateArgs>): Prisma.PrismaPromise<GetAutoTopupLogAggregateType<T>>

    /**
     * Group by AutoTopupLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutoTopupLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutoTopupLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutoTopupLogGroupByArgs['orderBy'] }
        : { orderBy?: AutoTopupLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutoTopupLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutoTopupLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutoTopupLog model
   */
  readonly fields: AutoTopupLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutoTopupLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutoTopupLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutoTopupLog model
   */
  interface AutoTopupLogFieldRefs {
    readonly id: FieldRef<"AutoTopupLog", 'String'>
    readonly bankTransactionId: FieldRef<"AutoTopupLog", 'String'>
    readonly bankName: FieldRef<"AutoTopupLog", 'String'>
    readonly depositRequestId: FieldRef<"AutoTopupLog", 'Int'>
    readonly userId: FieldRef<"AutoTopupLog", 'String'>
    readonly topupCode: FieldRef<"AutoTopupLog", 'String'>
    readonly amountVnd: FieldRef<"AutoTopupLog", 'Float'>
    readonly description: FieldRef<"AutoTopupLog", 'String'>
    readonly status: FieldRef<"AutoTopupLog", 'AutoTopupStatus'>
    readonly errorMessage: FieldRef<"AutoTopupLog", 'String'>
    readonly transactionDate: FieldRef<"AutoTopupLog", 'DateTime'>
    readonly createdAt: FieldRef<"AutoTopupLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutoTopupLog findUnique
   */
  export type AutoTopupLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * Filter, which AutoTopupLog to fetch.
     */
    where: AutoTopupLogWhereUniqueInput
  }

  /**
   * AutoTopupLog findUniqueOrThrow
   */
  export type AutoTopupLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * Filter, which AutoTopupLog to fetch.
     */
    where: AutoTopupLogWhereUniqueInput
  }

  /**
   * AutoTopupLog findFirst
   */
  export type AutoTopupLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * Filter, which AutoTopupLog to fetch.
     */
    where?: AutoTopupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoTopupLogs to fetch.
     */
    orderBy?: AutoTopupLogOrderByWithRelationInput | AutoTopupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoTopupLogs.
     */
    cursor?: AutoTopupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoTopupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoTopupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoTopupLogs.
     */
    distinct?: AutoTopupLogScalarFieldEnum | AutoTopupLogScalarFieldEnum[]
  }

  /**
   * AutoTopupLog findFirstOrThrow
   */
  export type AutoTopupLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * Filter, which AutoTopupLog to fetch.
     */
    where?: AutoTopupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoTopupLogs to fetch.
     */
    orderBy?: AutoTopupLogOrderByWithRelationInput | AutoTopupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutoTopupLogs.
     */
    cursor?: AutoTopupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoTopupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoTopupLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutoTopupLogs.
     */
    distinct?: AutoTopupLogScalarFieldEnum | AutoTopupLogScalarFieldEnum[]
  }

  /**
   * AutoTopupLog findMany
   */
  export type AutoTopupLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * Filter, which AutoTopupLogs to fetch.
     */
    where?: AutoTopupLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutoTopupLogs to fetch.
     */
    orderBy?: AutoTopupLogOrderByWithRelationInput | AutoTopupLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutoTopupLogs.
     */
    cursor?: AutoTopupLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutoTopupLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutoTopupLogs.
     */
    skip?: number
    distinct?: AutoTopupLogScalarFieldEnum | AutoTopupLogScalarFieldEnum[]
  }

  /**
   * AutoTopupLog create
   */
  export type AutoTopupLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AutoTopupLog.
     */
    data: XOR<AutoTopupLogCreateInput, AutoTopupLogUncheckedCreateInput>
  }

  /**
   * AutoTopupLog createMany
   */
  export type AutoTopupLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutoTopupLogs.
     */
    data: AutoTopupLogCreateManyInput | AutoTopupLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutoTopupLog update
   */
  export type AutoTopupLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AutoTopupLog.
     */
    data: XOR<AutoTopupLogUpdateInput, AutoTopupLogUncheckedUpdateInput>
    /**
     * Choose, which AutoTopupLog to update.
     */
    where: AutoTopupLogWhereUniqueInput
  }

  /**
   * AutoTopupLog updateMany
   */
  export type AutoTopupLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutoTopupLogs.
     */
    data: XOR<AutoTopupLogUpdateManyMutationInput, AutoTopupLogUncheckedUpdateManyInput>
    /**
     * Filter which AutoTopupLogs to update
     */
    where?: AutoTopupLogWhereInput
    /**
     * Limit how many AutoTopupLogs to update.
     */
    limit?: number
  }

  /**
   * AutoTopupLog upsert
   */
  export type AutoTopupLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AutoTopupLog to update in case it exists.
     */
    where: AutoTopupLogWhereUniqueInput
    /**
     * In case the AutoTopupLog found by the `where` argument doesn't exist, create a new AutoTopupLog with this data.
     */
    create: XOR<AutoTopupLogCreateInput, AutoTopupLogUncheckedCreateInput>
    /**
     * In case the AutoTopupLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutoTopupLogUpdateInput, AutoTopupLogUncheckedUpdateInput>
  }

  /**
   * AutoTopupLog delete
   */
  export type AutoTopupLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
    /**
     * Filter which AutoTopupLog to delete.
     */
    where: AutoTopupLogWhereUniqueInput
  }

  /**
   * AutoTopupLog deleteMany
   */
  export type AutoTopupLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutoTopupLogs to delete
     */
    where?: AutoTopupLogWhereInput
    /**
     * Limit how many AutoTopupLogs to delete.
     */
    limit?: number
  }

  /**
   * AutoTopupLog without action
   */
  export type AutoTopupLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutoTopupLog
     */
    select?: AutoTopupLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutoTopupLog
     */
    omit?: AutoTopupLogOmit<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    referrerRewardVnd: number | null
    refereeRewardVnd: number | null
    firstDepositVnd: number | null
  }

  export type ReferralSumAggregateOutputType = {
    referrerRewardVnd: number | null
    refereeRewardVnd: number | null
    firstDepositVnd: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    referralCode: string | null
    referrerRewardVnd: number | null
    refereeRewardVnd: number | null
    rewardPaid: boolean | null
    rewardPaidAt: Date | null
    firstDepositVnd: number | null
    firstDepositAt: Date | null
    createdAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    refereeId: string | null
    referralCode: string | null
    referrerRewardVnd: number | null
    refereeRewardVnd: number | null
    rewardPaid: boolean | null
    rewardPaidAt: Date | null
    firstDepositVnd: number | null
    firstDepositAt: Date | null
    createdAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    refereeId: number
    referralCode: number
    referrerRewardVnd: number
    refereeRewardVnd: number
    rewardPaid: number
    rewardPaidAt: number
    firstDepositVnd: number
    firstDepositAt: number
    createdAt: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    referrerRewardVnd?: true
    refereeRewardVnd?: true
    firstDepositVnd?: true
  }

  export type ReferralSumAggregateInputType = {
    referrerRewardVnd?: true
    refereeRewardVnd?: true
    firstDepositVnd?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    referralCode?: true
    referrerRewardVnd?: true
    refereeRewardVnd?: true
    rewardPaid?: true
    rewardPaidAt?: true
    firstDepositVnd?: true
    firstDepositAt?: true
    createdAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    referralCode?: true
    referrerRewardVnd?: true
    refereeRewardVnd?: true
    rewardPaid?: true
    rewardPaidAt?: true
    firstDepositVnd?: true
    firstDepositAt?: true
    createdAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    refereeId?: true
    referralCode?: true
    referrerRewardVnd?: true
    refereeRewardVnd?: true
    rewardPaid?: true
    rewardPaidAt?: true
    firstDepositVnd?: true
    firstDepositAt?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    refereeId: string
    referralCode: string
    referrerRewardVnd: number
    refereeRewardVnd: number
    rewardPaid: boolean
    rewardPaidAt: Date | null
    firstDepositVnd: number | null
    firstDepositAt: Date | null
    createdAt: Date
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    referralCode?: boolean
    referrerRewardVnd?: boolean
    refereeRewardVnd?: boolean
    rewardPaid?: boolean
    rewardPaidAt?: boolean
    firstDepositVnd?: boolean
    firstDepositAt?: boolean
    createdAt?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>



  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    refereeId?: boolean
    referralCode?: boolean
    referrerRewardVnd?: boolean
    refereeRewardVnd?: boolean
    rewardPaid?: boolean
    rewardPaidAt?: boolean
    firstDepositVnd?: boolean
    firstDepositAt?: boolean
    createdAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referrerId" | "refereeId" | "referralCode" | "referrerRewardVnd" | "refereeRewardVnd" | "rewardPaid" | "rewardPaidAt" | "firstDepositVnd" | "firstDepositAt" | "createdAt", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      refereeId: string
      referralCode: string
      referrerRewardVnd: number
      refereeRewardVnd: number
      rewardPaid: boolean
      rewardPaidAt: Date | null
      firstDepositVnd: number | null
      firstDepositAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly refereeId: FieldRef<"Referral", 'String'>
    readonly referralCode: FieldRef<"Referral", 'String'>
    readonly referrerRewardVnd: FieldRef<"Referral", 'Float'>
    readonly refereeRewardVnd: FieldRef<"Referral", 'Float'>
    readonly rewardPaid: FieldRef<"Referral", 'Boolean'>
    readonly rewardPaidAt: FieldRef<"Referral", 'DateTime'>
    readonly firstDepositVnd: FieldRef<"Referral", 'Float'>
    readonly firstDepositAt: FieldRef<"Referral", 'DateTime'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model UserActivityLog
   */

  export type AggregateUserActivityLog = {
    _count: UserActivityLogCountAggregateOutputType | null
    _min: UserActivityLogMinAggregateOutputType | null
    _max: UserActivityLogMaxAggregateOutputType | null
  }

  export type UserActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    metadata: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type UserActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    metadata: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type UserActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    targetType: number
    targetId: number
    metadata: number
    ip: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type UserActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    targetType?: true
    targetId?: true
    metadata?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type UserActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    targetType?: true
    targetId?: true
    metadata?: true
    ip?: true
    userAgent?: true
    createdAt?: true
  }

  export type UserActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    targetType?: true
    targetId?: true
    metadata?: true
    ip?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type UserActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivityLog to aggregate.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActivityLogs
    **/
    _count?: true | UserActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivityLogMaxAggregateInputType
  }

  export type GetUserActivityLogAggregateType<T extends UserActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivityLog[P]>
      : GetScalarType<T[P], AggregateUserActivityLog[P]>
  }




  export type UserActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActivityLogWhereInput
    orderBy?: UserActivityLogOrderByWithAggregationInput | UserActivityLogOrderByWithAggregationInput[]
    by: UserActivityLogScalarFieldEnum[] | UserActivityLogScalarFieldEnum
    having?: UserActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivityLogCountAggregateInputType | true
    _min?: UserActivityLogMinAggregateInputType
    _max?: UserActivityLogMaxAggregateInputType
  }

  export type UserActivityLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    targetType: string | null
    targetId: string | null
    metadata: string | null
    ip: string | null
    userAgent: string | null
    createdAt: Date
    _count: UserActivityLogCountAggregateOutputType | null
    _min: UserActivityLogMinAggregateOutputType | null
    _max: UserActivityLogMaxAggregateOutputType | null
  }

  type GetUserActivityLogGroupByPayload<T extends UserActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type UserActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    metadata?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userActivityLog"]>



  export type UserActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    metadata?: boolean
    ip?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type UserActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "targetType" | "targetId" | "metadata" | "ip" | "userAgent" | "createdAt", ExtArgs["result"]["userActivityLog"]>

  export type $UserActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserActivityLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      targetType: string | null
      targetId: string | null
      metadata: string | null
      ip: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["userActivityLog"]>
    composites: {}
  }

  type UserActivityLogGetPayload<S extends boolean | null | undefined | UserActivityLogDefaultArgs> = $Result.GetResult<Prisma.$UserActivityLogPayload, S>

  type UserActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserActivityLogCountAggregateInputType | true
    }

  export interface UserActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserActivityLog'], meta: { name: 'UserActivityLog' } }
    /**
     * Find zero or one UserActivityLog that matches the filter.
     * @param {UserActivityLogFindUniqueArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActivityLogFindUniqueArgs>(args: SelectSubset<T, UserActivityLogFindUniqueArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserActivityLogFindUniqueOrThrowArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogFindFirstArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActivityLogFindFirstArgs>(args?: SelectSubset<T, UserActivityLogFindFirstArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogFindFirstOrThrowArgs} args - Arguments to find a UserActivityLog
     * @example
     * // Get one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivityLogs
     * const userActivityLogs = await prisma.userActivityLog.findMany()
     * 
     * // Get first 10 UserActivityLogs
     * const userActivityLogs = await prisma.userActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivityLogWithIdOnly = await prisma.userActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActivityLogFindManyArgs>(args?: SelectSubset<T, UserActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserActivityLog.
     * @param {UserActivityLogCreateArgs} args - Arguments to create a UserActivityLog.
     * @example
     * // Create one UserActivityLog
     * const UserActivityLog = await prisma.userActivityLog.create({
     *   data: {
     *     // ... data to create a UserActivityLog
     *   }
     * })
     * 
     */
    create<T extends UserActivityLogCreateArgs>(args: SelectSubset<T, UserActivityLogCreateArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserActivityLogs.
     * @param {UserActivityLogCreateManyArgs} args - Arguments to create many UserActivityLogs.
     * @example
     * // Create many UserActivityLogs
     * const userActivityLog = await prisma.userActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActivityLogCreateManyArgs>(args?: SelectSubset<T, UserActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserActivityLog.
     * @param {UserActivityLogDeleteArgs} args - Arguments to delete one UserActivityLog.
     * @example
     * // Delete one UserActivityLog
     * const UserActivityLog = await prisma.userActivityLog.delete({
     *   where: {
     *     // ... filter to delete one UserActivityLog
     *   }
     * })
     * 
     */
    delete<T extends UserActivityLogDeleteArgs>(args: SelectSubset<T, UserActivityLogDeleteArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserActivityLog.
     * @param {UserActivityLogUpdateArgs} args - Arguments to update one UserActivityLog.
     * @example
     * // Update one UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActivityLogUpdateArgs>(args: SelectSubset<T, UserActivityLogUpdateArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserActivityLogs.
     * @param {UserActivityLogDeleteManyArgs} args - Arguments to filter UserActivityLogs to delete.
     * @example
     * // Delete a few UserActivityLogs
     * const { count } = await prisma.userActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActivityLogDeleteManyArgs>(args?: SelectSubset<T, UserActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivityLogs
     * const userActivityLog = await prisma.userActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActivityLogUpdateManyArgs>(args: SelectSubset<T, UserActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserActivityLog.
     * @param {UserActivityLogUpsertArgs} args - Arguments to update or create a UserActivityLog.
     * @example
     * // Update or create a UserActivityLog
     * const userActivityLog = await prisma.userActivityLog.upsert({
     *   create: {
     *     // ... data to create a UserActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends UserActivityLogUpsertArgs>(args: SelectSubset<T, UserActivityLogUpsertArgs<ExtArgs>>): Prisma__UserActivityLogClient<$Result.GetResult<Prisma.$UserActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogCountArgs} args - Arguments to filter UserActivityLogs to count.
     * @example
     * // Count the number of UserActivityLogs
     * const count = await prisma.userActivityLog.count({
     *   where: {
     *     // ... the filter for the UserActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends UserActivityLogCountArgs>(
      args?: Subset<T, UserActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivityLogAggregateArgs>(args: Subset<T, UserActivityLogAggregateArgs>): Prisma.PrismaPromise<GetUserActivityLogAggregateType<T>>

    /**
     * Group by UserActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: UserActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserActivityLog model
   */
  readonly fields: UserActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserActivityLog model
   */
  interface UserActivityLogFieldRefs {
    readonly id: FieldRef<"UserActivityLog", 'String'>
    readonly userId: FieldRef<"UserActivityLog", 'String'>
    readonly action: FieldRef<"UserActivityLog", 'String'>
    readonly targetType: FieldRef<"UserActivityLog", 'String'>
    readonly targetId: FieldRef<"UserActivityLog", 'String'>
    readonly metadata: FieldRef<"UserActivityLog", 'String'>
    readonly ip: FieldRef<"UserActivityLog", 'String'>
    readonly userAgent: FieldRef<"UserActivityLog", 'String'>
    readonly createdAt: FieldRef<"UserActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserActivityLog findUnique
   */
  export type UserActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog findUniqueOrThrow
   */
  export type UserActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog findFirst
   */
  export type UserActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivityLogs.
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivityLogs.
     */
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * UserActivityLog findFirstOrThrow
   */
  export type UserActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which UserActivityLog to fetch.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActivityLogs.
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActivityLogs.
     */
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * UserActivityLog findMany
   */
  export type UserActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Filter, which UserActivityLogs to fetch.
     */
    where?: UserActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActivityLogs to fetch.
     */
    orderBy?: UserActivityLogOrderByWithRelationInput | UserActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActivityLogs.
     */
    cursor?: UserActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActivityLogs.
     */
    skip?: number
    distinct?: UserActivityLogScalarFieldEnum | UserActivityLogScalarFieldEnum[]
  }

  /**
   * UserActivityLog create
   */
  export type UserActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to create a UserActivityLog.
     */
    data: XOR<UserActivityLogCreateInput, UserActivityLogUncheckedCreateInput>
  }

  /**
   * UserActivityLog createMany
   */
  export type UserActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActivityLogs.
     */
    data: UserActivityLogCreateManyInput | UserActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserActivityLog update
   */
  export type UserActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * The data needed to update a UserActivityLog.
     */
    data: XOR<UserActivityLogUpdateInput, UserActivityLogUncheckedUpdateInput>
    /**
     * Choose, which UserActivityLog to update.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog updateMany
   */
  export type UserActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActivityLogs.
     */
    data: XOR<UserActivityLogUpdateManyMutationInput, UserActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which UserActivityLogs to update
     */
    where?: UserActivityLogWhereInput
    /**
     * Limit how many UserActivityLogs to update.
     */
    limit?: number
  }

  /**
   * UserActivityLog upsert
   */
  export type UserActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * The filter to search for the UserActivityLog to update in case it exists.
     */
    where: UserActivityLogWhereUniqueInput
    /**
     * In case the UserActivityLog found by the `where` argument doesn't exist, create a new UserActivityLog with this data.
     */
    create: XOR<UserActivityLogCreateInput, UserActivityLogUncheckedCreateInput>
    /**
     * In case the UserActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActivityLogUpdateInput, UserActivityLogUncheckedUpdateInput>
  }

  /**
   * UserActivityLog delete
   */
  export type UserActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
    /**
     * Filter which UserActivityLog to delete.
     */
    where: UserActivityLogWhereUniqueInput
  }

  /**
   * UserActivityLog deleteMany
   */
  export type UserActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActivityLogs to delete
     */
    where?: UserActivityLogWhereInput
    /**
     * Limit how many UserActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * UserActivityLog without action
   */
  export type UserActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserActivityLog
     */
    select?: UserActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserActivityLog
     */
    omit?: UserActivityLogOmit<ExtArgs> | null
  }


  /**
   * Model TwoFactorAccount
   */

  export type AggregateTwoFactorAccount = {
    _count: TwoFactorAccountCountAggregateOutputType | null
    _min: TwoFactorAccountMinAggregateOutputType | null
    _max: TwoFactorAccountMaxAggregateOutputType | null
  }

  export type TwoFactorAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    issuer: string | null
    secret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    issuer: string | null
    secret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorAccountCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    issuer: number
    secret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwoFactorAccountMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    issuer?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    issuer?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorAccountCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    issuer?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwoFactorAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAccount to aggregate.
     */
    where?: TwoFactorAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAccounts to fetch.
     */
    orderBy?: TwoFactorAccountOrderByWithRelationInput | TwoFactorAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactorAccounts
    **/
    _count?: true | TwoFactorAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorAccountMaxAggregateInputType
  }

  export type GetTwoFactorAccountAggregateType<T extends TwoFactorAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactorAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactorAccount[P]>
      : GetScalarType<T[P], AggregateTwoFactorAccount[P]>
  }




  export type TwoFactorAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorAccountWhereInput
    orderBy?: TwoFactorAccountOrderByWithAggregationInput | TwoFactorAccountOrderByWithAggregationInput[]
    by: TwoFactorAccountScalarFieldEnum[] | TwoFactorAccountScalarFieldEnum
    having?: TwoFactorAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorAccountCountAggregateInputType | true
    _min?: TwoFactorAccountMinAggregateInputType
    _max?: TwoFactorAccountMaxAggregateInputType
  }

  export type TwoFactorAccountGroupByOutputType = {
    id: string
    userId: string
    name: string
    issuer: string
    secret: string
    createdAt: Date
    updatedAt: Date
    _count: TwoFactorAccountCountAggregateOutputType | null
    _min: TwoFactorAccountMinAggregateOutputType | null
    _max: TwoFactorAccountMaxAggregateOutputType | null
  }

  type GetTwoFactorAccountGroupByPayload<T extends TwoFactorAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorAccountGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorAccountGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    issuer?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactorAccount"]>



  export type TwoFactorAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    issuer?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwoFactorAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "issuer" | "secret" | "createdAt" | "updatedAt", ExtArgs["result"]["twoFactorAccount"]>
  export type TwoFactorAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactorAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      issuer: string
      secret: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["twoFactorAccount"]>
    composites: {}
  }

  type TwoFactorAccountGetPayload<S extends boolean | null | undefined | TwoFactorAccountDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorAccountPayload, S>

  type TwoFactorAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwoFactorAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwoFactorAccountCountAggregateInputType | true
    }

  export interface TwoFactorAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactorAccount'], meta: { name: 'TwoFactorAccount' } }
    /**
     * Find zero or one TwoFactorAccount that matches the filter.
     * @param {TwoFactorAccountFindUniqueArgs} args - Arguments to find a TwoFactorAccount
     * @example
     * // Get one TwoFactorAccount
     * const twoFactorAccount = await prisma.twoFactorAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorAccountFindUniqueArgs>(args: SelectSubset<T, TwoFactorAccountFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwoFactorAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwoFactorAccountFindUniqueOrThrowArgs} args - Arguments to find a TwoFactorAccount
     * @example
     * // Get one TwoFactorAccount
     * const twoFactorAccount = await prisma.twoFactorAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountFindFirstArgs} args - Arguments to find a TwoFactorAccount
     * @example
     * // Get one TwoFactorAccount
     * const twoFactorAccount = await prisma.twoFactorAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorAccountFindFirstArgs>(args?: SelectSubset<T, TwoFactorAccountFindFirstArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwoFactorAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountFindFirstOrThrowArgs} args - Arguments to find a TwoFactorAccount
     * @example
     * // Get one TwoFactorAccount
     * const twoFactorAccount = await prisma.twoFactorAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwoFactorAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactorAccounts
     * const twoFactorAccounts = await prisma.twoFactorAccount.findMany()
     * 
     * // Get first 10 TwoFactorAccounts
     * const twoFactorAccounts = await prisma.twoFactorAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorAccountWithIdOnly = await prisma.twoFactorAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorAccountFindManyArgs>(args?: SelectSubset<T, TwoFactorAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwoFactorAccount.
     * @param {TwoFactorAccountCreateArgs} args - Arguments to create a TwoFactorAccount.
     * @example
     * // Create one TwoFactorAccount
     * const TwoFactorAccount = await prisma.twoFactorAccount.create({
     *   data: {
     *     // ... data to create a TwoFactorAccount
     *   }
     * })
     * 
     */
    create<T extends TwoFactorAccountCreateArgs>(args: SelectSubset<T, TwoFactorAccountCreateArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwoFactorAccounts.
     * @param {TwoFactorAccountCreateManyArgs} args - Arguments to create many TwoFactorAccounts.
     * @example
     * // Create many TwoFactorAccounts
     * const twoFactorAccount = await prisma.twoFactorAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorAccountCreateManyArgs>(args?: SelectSubset<T, TwoFactorAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TwoFactorAccount.
     * @param {TwoFactorAccountDeleteArgs} args - Arguments to delete one TwoFactorAccount.
     * @example
     * // Delete one TwoFactorAccount
     * const TwoFactorAccount = await prisma.twoFactorAccount.delete({
     *   where: {
     *     // ... filter to delete one TwoFactorAccount
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorAccountDeleteArgs>(args: SelectSubset<T, TwoFactorAccountDeleteArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwoFactorAccount.
     * @param {TwoFactorAccountUpdateArgs} args - Arguments to update one TwoFactorAccount.
     * @example
     * // Update one TwoFactorAccount
     * const twoFactorAccount = await prisma.twoFactorAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorAccountUpdateArgs>(args: SelectSubset<T, TwoFactorAccountUpdateArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwoFactorAccounts.
     * @param {TwoFactorAccountDeleteManyArgs} args - Arguments to filter TwoFactorAccounts to delete.
     * @example
     * // Delete a few TwoFactorAccounts
     * const { count } = await prisma.twoFactorAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorAccountDeleteManyArgs>(args?: SelectSubset<T, TwoFactorAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactorAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactorAccounts
     * const twoFactorAccount = await prisma.twoFactorAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorAccountUpdateManyArgs>(args: SelectSubset<T, TwoFactorAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactorAccount.
     * @param {TwoFactorAccountUpsertArgs} args - Arguments to update or create a TwoFactorAccount.
     * @example
     * // Update or create a TwoFactorAccount
     * const twoFactorAccount = await prisma.twoFactorAccount.upsert({
     *   create: {
     *     // ... data to create a TwoFactorAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactorAccount we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorAccountUpsertArgs>(args: SelectSubset<T, TwoFactorAccountUpsertArgs<ExtArgs>>): Prisma__TwoFactorAccountClient<$Result.GetResult<Prisma.$TwoFactorAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwoFactorAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountCountArgs} args - Arguments to filter TwoFactorAccounts to count.
     * @example
     * // Count the number of TwoFactorAccounts
     * const count = await prisma.twoFactorAccount.count({
     *   where: {
     *     // ... the filter for the TwoFactorAccounts we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorAccountCountArgs>(
      args?: Subset<T, TwoFactorAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactorAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAccountAggregateArgs>(args: Subset<T, TwoFactorAccountAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAccountAggregateType<T>>

    /**
     * Group by TwoFactorAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorAccountGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactorAccount model
   */
  readonly fields: TwoFactorAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactorAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactorAccount model
   */
  interface TwoFactorAccountFieldRefs {
    readonly id: FieldRef<"TwoFactorAccount", 'String'>
    readonly userId: FieldRef<"TwoFactorAccount", 'String'>
    readonly name: FieldRef<"TwoFactorAccount", 'String'>
    readonly issuer: FieldRef<"TwoFactorAccount", 'String'>
    readonly secret: FieldRef<"TwoFactorAccount", 'String'>
    readonly createdAt: FieldRef<"TwoFactorAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"TwoFactorAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactorAccount findUnique
   */
  export type TwoFactorAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAccount to fetch.
     */
    where: TwoFactorAccountWhereUniqueInput
  }

  /**
   * TwoFactorAccount findUniqueOrThrow
   */
  export type TwoFactorAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAccount to fetch.
     */
    where: TwoFactorAccountWhereUniqueInput
  }

  /**
   * TwoFactorAccount findFirst
   */
  export type TwoFactorAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAccount to fetch.
     */
    where?: TwoFactorAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAccounts to fetch.
     */
    orderBy?: TwoFactorAccountOrderByWithRelationInput | TwoFactorAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAccounts.
     */
    cursor?: TwoFactorAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAccounts.
     */
    distinct?: TwoFactorAccountScalarFieldEnum | TwoFactorAccountScalarFieldEnum[]
  }

  /**
   * TwoFactorAccount findFirstOrThrow
   */
  export type TwoFactorAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAccount to fetch.
     */
    where?: TwoFactorAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAccounts to fetch.
     */
    orderBy?: TwoFactorAccountOrderByWithRelationInput | TwoFactorAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactorAccounts.
     */
    cursor?: TwoFactorAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactorAccounts.
     */
    distinct?: TwoFactorAccountScalarFieldEnum | TwoFactorAccountScalarFieldEnum[]
  }

  /**
   * TwoFactorAccount findMany
   */
  export type TwoFactorAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactorAccounts to fetch.
     */
    where?: TwoFactorAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactorAccounts to fetch.
     */
    orderBy?: TwoFactorAccountOrderByWithRelationInput | TwoFactorAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactorAccounts.
     */
    cursor?: TwoFactorAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactorAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactorAccounts.
     */
    skip?: number
    distinct?: TwoFactorAccountScalarFieldEnum | TwoFactorAccountScalarFieldEnum[]
  }

  /**
   * TwoFactorAccount create
   */
  export type TwoFactorAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactorAccount.
     */
    data: XOR<TwoFactorAccountCreateInput, TwoFactorAccountUncheckedCreateInput>
  }

  /**
   * TwoFactorAccount createMany
   */
  export type TwoFactorAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactorAccounts.
     */
    data: TwoFactorAccountCreateManyInput | TwoFactorAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactorAccount update
   */
  export type TwoFactorAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactorAccount.
     */
    data: XOR<TwoFactorAccountUpdateInput, TwoFactorAccountUncheckedUpdateInput>
    /**
     * Choose, which TwoFactorAccount to update.
     */
    where: TwoFactorAccountWhereUniqueInput
  }

  /**
   * TwoFactorAccount updateMany
   */
  export type TwoFactorAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactorAccounts.
     */
    data: XOR<TwoFactorAccountUpdateManyMutationInput, TwoFactorAccountUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactorAccounts to update
     */
    where?: TwoFactorAccountWhereInput
    /**
     * Limit how many TwoFactorAccounts to update.
     */
    limit?: number
  }

  /**
   * TwoFactorAccount upsert
   */
  export type TwoFactorAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactorAccount to update in case it exists.
     */
    where: TwoFactorAccountWhereUniqueInput
    /**
     * In case the TwoFactorAccount found by the `where` argument doesn't exist, create a new TwoFactorAccount with this data.
     */
    create: XOR<TwoFactorAccountCreateInput, TwoFactorAccountUncheckedCreateInput>
    /**
     * In case the TwoFactorAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorAccountUpdateInput, TwoFactorAccountUncheckedUpdateInput>
  }

  /**
   * TwoFactorAccount delete
   */
  export type TwoFactorAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
    /**
     * Filter which TwoFactorAccount to delete.
     */
    where: TwoFactorAccountWhereUniqueInput
  }

  /**
   * TwoFactorAccount deleteMany
   */
  export type TwoFactorAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactorAccounts to delete
     */
    where?: TwoFactorAccountWhereInput
    /**
     * Limit how many TwoFactorAccounts to delete.
     */
    limit?: number
  }

  /**
   * TwoFactorAccount without action
   */
  export type TwoFactorAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactorAccount
     */
    select?: TwoFactorAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwoFactorAccount
     */
    omit?: TwoFactorAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorAccountInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    used: boolean | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    used: boolean | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    used: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    used?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    used?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    used?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    used: boolean
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>



  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    used?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "createdAt" | "used", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
      used: boolean
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly used: FieldRef<"PasswordResetToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Advertisement
   */

  export type AggregateAdvertisement = {
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  export type AdvertisementAvgAggregateOutputType = {
    order: number | null
    impressions: number | null
    clicks: number | null
  }

  export type AdvertisementSumAggregateOutputType = {
    order: number | null
    impressions: number | null
    clicks: number | null
  }

  export type AdvertisementMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AdType | null
    placement: $Enums.AdPlacement | null
    content: string | null
    imageUrl: string | null
    clickUrl: string | null
    order: number | null
    enabled: boolean | null
    impressions: number | null
    clicks: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvertisementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AdType | null
    placement: $Enums.AdPlacement | null
    content: string | null
    imageUrl: string | null
    clickUrl: string | null
    order: number | null
    enabled: boolean | null
    impressions: number | null
    clicks: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdvertisementCountAggregateOutputType = {
    id: number
    name: number
    type: number
    placement: number
    content: number
    imageUrl: number
    clickUrl: number
    order: number
    enabled: number
    impressions: number
    clicks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdvertisementAvgAggregateInputType = {
    order?: true
    impressions?: true
    clicks?: true
  }

  export type AdvertisementSumAggregateInputType = {
    order?: true
    impressions?: true
    clicks?: true
  }

  export type AdvertisementMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    placement?: true
    content?: true
    imageUrl?: true
    clickUrl?: true
    order?: true
    enabled?: true
    impressions?: true
    clicks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvertisementMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    placement?: true
    content?: true
    imageUrl?: true
    clickUrl?: true
    order?: true
    enabled?: true
    impressions?: true
    clicks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdvertisementCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    placement?: true
    content?: true
    imageUrl?: true
    clickUrl?: true
    order?: true
    enabled?: true
    impressions?: true
    clicks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdvertisementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisement to aggregate.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advertisements
    **/
    _count?: true | AdvertisementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisementMaxAggregateInputType
  }

  export type GetAdvertisementAggregateType<T extends AdvertisementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisement[P]>
      : GetScalarType<T[P], AggregateAdvertisement[P]>
  }




  export type AdvertisementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithAggregationInput | AdvertisementOrderByWithAggregationInput[]
    by: AdvertisementScalarFieldEnum[] | AdvertisementScalarFieldEnum
    having?: AdvertisementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisementCountAggregateInputType | true
    _avg?: AdvertisementAvgAggregateInputType
    _sum?: AdvertisementSumAggregateInputType
    _min?: AdvertisementMinAggregateInputType
    _max?: AdvertisementMaxAggregateInputType
  }

  export type AdvertisementGroupByOutputType = {
    id: string
    name: string
    type: $Enums.AdType
    placement: $Enums.AdPlacement
    content: string
    imageUrl: string | null
    clickUrl: string | null
    order: number
    enabled: boolean
    impressions: number
    clicks: number
    createdAt: Date
    updatedAt: Date
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  type GetAdvertisementGroupByPayload<T extends AdvertisementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    placement?: boolean
    content?: boolean
    imageUrl?: boolean
    clickUrl?: boolean
    order?: boolean
    enabled?: boolean
    impressions?: boolean
    clicks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["advertisement"]>



  export type AdvertisementSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    placement?: boolean
    content?: boolean
    imageUrl?: boolean
    clickUrl?: boolean
    order?: boolean
    enabled?: boolean
    impressions?: boolean
    clicks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdvertisementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "placement" | "content" | "imageUrl" | "clickUrl" | "order" | "enabled" | "impressions" | "clicks" | "createdAt" | "updatedAt", ExtArgs["result"]["advertisement"]>

  export type $AdvertisementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Advertisement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.AdType
      placement: $Enums.AdPlacement
      content: string
      imageUrl: string | null
      clickUrl: string | null
      order: number
      enabled: boolean
      impressions: number
      clicks: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["advertisement"]>
    composites: {}
  }

  type AdvertisementGetPayload<S extends boolean | null | undefined | AdvertisementDefaultArgs> = $Result.GetResult<Prisma.$AdvertisementPayload, S>

  type AdvertisementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdvertisementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdvertisementCountAggregateInputType | true
    }

  export interface AdvertisementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advertisement'], meta: { name: 'Advertisement' } }
    /**
     * Find zero or one Advertisement that matches the filter.
     * @param {AdvertisementFindUniqueArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvertisementFindUniqueArgs>(args: SelectSubset<T, AdvertisementFindUniqueArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Advertisement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdvertisementFindUniqueOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvertisementFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvertisementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advertisement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvertisementFindFirstArgs>(args?: SelectSubset<T, AdvertisementFindFirstArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advertisement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvertisementFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvertisementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisement.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvertisementFindManyArgs>(args?: SelectSubset<T, AdvertisementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Advertisement.
     * @param {AdvertisementCreateArgs} args - Arguments to create a Advertisement.
     * @example
     * // Create one Advertisement
     * const Advertisement = await prisma.advertisement.create({
     *   data: {
     *     // ... data to create a Advertisement
     *   }
     * })
     * 
     */
    create<T extends AdvertisementCreateArgs>(args: SelectSubset<T, AdvertisementCreateArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Advertisements.
     * @param {AdvertisementCreateManyArgs} args - Arguments to create many Advertisements.
     * @example
     * // Create many Advertisements
     * const advertisement = await prisma.advertisement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvertisementCreateManyArgs>(args?: SelectSubset<T, AdvertisementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advertisement.
     * @param {AdvertisementDeleteArgs} args - Arguments to delete one Advertisement.
     * @example
     * // Delete one Advertisement
     * const Advertisement = await prisma.advertisement.delete({
     *   where: {
     *     // ... filter to delete one Advertisement
     *   }
     * })
     * 
     */
    delete<T extends AdvertisementDeleteArgs>(args: SelectSubset<T, AdvertisementDeleteArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Advertisement.
     * @param {AdvertisementUpdateArgs} args - Arguments to update one Advertisement.
     * @example
     * // Update one Advertisement
     * const advertisement = await prisma.advertisement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvertisementUpdateArgs>(args: SelectSubset<T, AdvertisementUpdateArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Advertisements.
     * @param {AdvertisementDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvertisementDeleteManyArgs>(args?: SelectSubset<T, AdvertisementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvertisementUpdateManyArgs>(args: SelectSubset<T, AdvertisementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advertisement.
     * @param {AdvertisementUpsertArgs} args - Arguments to update or create a Advertisement.
     * @example
     * // Update or create a Advertisement
     * const advertisement = await prisma.advertisement.upsert({
     *   create: {
     *     // ... data to create a Advertisement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisement we want to update
     *   }
     * })
     */
    upsert<T extends AdvertisementUpsertArgs>(args: SelectSubset<T, AdvertisementUpsertArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisement.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisementCountArgs>(
      args?: Subset<T, AdvertisementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementAggregateArgs>(args: Subset<T, AdvertisementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisementAggregateType<T>>

    /**
     * Group by Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisementGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advertisement model
   */
  readonly fields: AdvertisementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advertisement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Advertisement model
   */
  interface AdvertisementFieldRefs {
    readonly id: FieldRef<"Advertisement", 'String'>
    readonly name: FieldRef<"Advertisement", 'String'>
    readonly type: FieldRef<"Advertisement", 'AdType'>
    readonly placement: FieldRef<"Advertisement", 'AdPlacement'>
    readonly content: FieldRef<"Advertisement", 'String'>
    readonly imageUrl: FieldRef<"Advertisement", 'String'>
    readonly clickUrl: FieldRef<"Advertisement", 'String'>
    readonly order: FieldRef<"Advertisement", 'Int'>
    readonly enabled: FieldRef<"Advertisement", 'Boolean'>
    readonly impressions: FieldRef<"Advertisement", 'Int'>
    readonly clicks: FieldRef<"Advertisement", 'Int'>
    readonly createdAt: FieldRef<"Advertisement", 'DateTime'>
    readonly updatedAt: FieldRef<"Advertisement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Advertisement findUnique
   */
  export type AdvertisementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement findUniqueOrThrow
   */
  export type AdvertisementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement findFirst
   */
  export type AdvertisementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * Advertisement findFirstOrThrow
   */
  export type AdvertisementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * Advertisement findMany
   */
  export type AdvertisementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Filter, which Advertisements to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }

  /**
   * Advertisement create
   */
  export type AdvertisementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * The data needed to create a Advertisement.
     */
    data: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
  }

  /**
   * Advertisement createMany
   */
  export type AdvertisementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advertisements.
     */
    data: AdvertisementCreateManyInput | AdvertisementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Advertisement update
   */
  export type AdvertisementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * The data needed to update a Advertisement.
     */
    data: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
    /**
     * Choose, which Advertisement to update.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement updateMany
   */
  export type AdvertisementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advertisements.
     */
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyInput>
    /**
     * Filter which Advertisements to update
     */
    where?: AdvertisementWhereInput
    /**
     * Limit how many Advertisements to update.
     */
    limit?: number
  }

  /**
   * Advertisement upsert
   */
  export type AdvertisementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * The filter to search for the Advertisement to update in case it exists.
     */
    where: AdvertisementWhereUniqueInput
    /**
     * In case the Advertisement found by the `where` argument doesn't exist, create a new Advertisement with this data.
     */
    create: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
    /**
     * In case the Advertisement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
  }

  /**
   * Advertisement delete
   */
  export type AdvertisementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
    /**
     * Filter which Advertisement to delete.
     */
    where: AdvertisementWhereUniqueInput
  }

  /**
   * Advertisement deleteMany
   */
  export type AdvertisementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisements to delete
     */
    where?: AdvertisementWhereInput
    /**
     * Limit how many Advertisements to delete.
     */
    limit?: number
  }

  /**
   * Advertisement without action
   */
  export type AdvertisementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Advertisement
     */
    omit?: AdvertisementOmit<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _avg: SystemLogAvgAggregateOutputType | null
    _sum: SystemLogSumAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogAvgAggregateOutputType = {
    amount: number | null
  }

  export type SystemLogSumAggregateOutputType = {
    amount: number | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    action: $Enums.SystemLogAction | null
    targetType: string | null
    targetId: string | null
    amount: number | null
    description: string | null
    metadata: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    action: $Enums.SystemLogAction | null
    targetType: string | null
    targetId: string | null
    amount: number | null
    description: string | null
    metadata: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    action: number
    targetType: number
    targetId: number
    amount: number
    description: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type SystemLogAvgAggregateInputType = {
    amount?: true
  }

  export type SystemLogSumAggregateInputType = {
    amount?: true
  }

  export type SystemLogMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    action?: true
    targetType?: true
    targetId?: true
    amount?: true
    description?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    action?: true
    targetType?: true
    targetId?: true
    amount?: true
    description?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    action?: true
    targetType?: true
    targetId?: true
    amount?: true
    description?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _avg?: SystemLogAvgAggregateInputType
    _sum?: SystemLogSumAggregateInputType
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    userId: string | null
    userEmail: string | null
    action: $Enums.SystemLogAction
    targetType: string | null
    targetId: string | null
    amount: number | null
    description: string
    metadata: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: SystemLogCountAggregateOutputType | null
    _avg: SystemLogAvgAggregateOutputType | null
    _sum: SystemLogSumAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    amount?: boolean
    description?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["systemLog"]>



  export type SystemLogSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    amount?: boolean
    description?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type SystemLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userEmail" | "action" | "targetType" | "targetId" | "amount" | "description" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["systemLog"]>

  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      userEmail: string | null
      action: $Enums.SystemLogAction
      targetType: string | null
      targetId: string | null
      amount: number | null
      description: string
      metadata: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly userId: FieldRef<"SystemLog", 'String'>
    readonly userEmail: FieldRef<"SystemLog", 'String'>
    readonly action: FieldRef<"SystemLog", 'SystemLogAction'>
    readonly targetType: FieldRef<"SystemLog", 'String'>
    readonly targetId: FieldRef<"SystemLog", 'String'>
    readonly amount: FieldRef<"SystemLog", 'Float'>
    readonly description: FieldRef<"SystemLog", 'String'>
    readonly metadata: FieldRef<"SystemLog", 'String'>
    readonly ipAddress: FieldRef<"SystemLog", 'String'>
    readonly userAgent: FieldRef<"SystemLog", 'String'>
    readonly createdAt: FieldRef<"SystemLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to update.
     */
    limit?: number
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to delete.
     */
    limit?: number
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
  }


  /**
   * Model ErrorReport
   */

  export type AggregateErrorReport = {
    _count: ErrorReportCountAggregateOutputType | null
    _min: ErrorReportMinAggregateOutputType | null
    _max: ErrorReportMaxAggregateOutputType | null
  }

  export type ErrorReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    orderId: string | null
    productLineId: string | null
    productName: string | null
    originalContent: string | null
    userNote: string | null
    status: $Enums.ErrorReportStatus | null
    reportedProducts: string | null
    adminNote: string | null
    resolution: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ErrorReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userEmail: string | null
    orderId: string | null
    productLineId: string | null
    productName: string | null
    originalContent: string | null
    userNote: string | null
    status: $Enums.ErrorReportStatus | null
    reportedProducts: string | null
    adminNote: string | null
    resolution: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ErrorReportCountAggregateOutputType = {
    id: number
    userId: number
    userEmail: number
    orderId: number
    productLineId: number
    productName: number
    originalContent: number
    userNote: number
    status: number
    reportedProducts: number
    adminNote: number
    resolution: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ErrorReportMinAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    orderId?: true
    productLineId?: true
    productName?: true
    originalContent?: true
    userNote?: true
    status?: true
    reportedProducts?: true
    adminNote?: true
    resolution?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ErrorReportMaxAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    orderId?: true
    productLineId?: true
    productName?: true
    originalContent?: true
    userNote?: true
    status?: true
    reportedProducts?: true
    adminNote?: true
    resolution?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ErrorReportCountAggregateInputType = {
    id?: true
    userId?: true
    userEmail?: true
    orderId?: true
    productLineId?: true
    productName?: true
    originalContent?: true
    userNote?: true
    status?: true
    reportedProducts?: true
    adminNote?: true
    resolution?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ErrorReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorReport to aggregate.
     */
    where?: ErrorReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorReports to fetch.
     */
    orderBy?: ErrorReportOrderByWithRelationInput | ErrorReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ErrorReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ErrorReports
    **/
    _count?: true | ErrorReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ErrorReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ErrorReportMaxAggregateInputType
  }

  export type GetErrorReportAggregateType<T extends ErrorReportAggregateArgs> = {
        [P in keyof T & keyof AggregateErrorReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErrorReport[P]>
      : GetScalarType<T[P], AggregateErrorReport[P]>
  }




  export type ErrorReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ErrorReportWhereInput
    orderBy?: ErrorReportOrderByWithAggregationInput | ErrorReportOrderByWithAggregationInput[]
    by: ErrorReportScalarFieldEnum[] | ErrorReportScalarFieldEnum
    having?: ErrorReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ErrorReportCountAggregateInputType | true
    _min?: ErrorReportMinAggregateInputType
    _max?: ErrorReportMaxAggregateInputType
  }

  export type ErrorReportGroupByOutputType = {
    id: string
    userId: string
    userEmail: string
    orderId: string
    productLineId: string | null
    productName: string | null
    originalContent: string | null
    userNote: string | null
    status: $Enums.ErrorReportStatus
    reportedProducts: string | null
    adminNote: string | null
    resolution: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ErrorReportCountAggregateOutputType | null
    _min: ErrorReportMinAggregateOutputType | null
    _max: ErrorReportMaxAggregateOutputType | null
  }

  type GetErrorReportGroupByPayload<T extends ErrorReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ErrorReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ErrorReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ErrorReportGroupByOutputType[P]>
            : GetScalarType<T[P], ErrorReportGroupByOutputType[P]>
        }
      >
    >


  export type ErrorReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    orderId?: boolean
    productLineId?: boolean
    productName?: boolean
    originalContent?: boolean
    userNote?: boolean
    status?: boolean
    reportedProducts?: boolean
    adminNote?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["errorReport"]>



  export type ErrorReportSelectScalar = {
    id?: boolean
    userId?: boolean
    userEmail?: boolean
    orderId?: boolean
    productLineId?: boolean
    productName?: boolean
    originalContent?: boolean
    userNote?: boolean
    status?: boolean
    reportedProducts?: boolean
    adminNote?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ErrorReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userEmail" | "orderId" | "productLineId" | "productName" | "originalContent" | "userNote" | "status" | "reportedProducts" | "adminNote" | "resolution" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["errorReport"]>

  export type $ErrorReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ErrorReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userEmail: string
      orderId: string
      productLineId: string | null
      productName: string | null
      originalContent: string | null
      userNote: string | null
      status: $Enums.ErrorReportStatus
      reportedProducts: string | null
      adminNote: string | null
      resolution: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["errorReport"]>
    composites: {}
  }

  type ErrorReportGetPayload<S extends boolean | null | undefined | ErrorReportDefaultArgs> = $Result.GetResult<Prisma.$ErrorReportPayload, S>

  type ErrorReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ErrorReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ErrorReportCountAggregateInputType | true
    }

  export interface ErrorReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ErrorReport'], meta: { name: 'ErrorReport' } }
    /**
     * Find zero or one ErrorReport that matches the filter.
     * @param {ErrorReportFindUniqueArgs} args - Arguments to find a ErrorReport
     * @example
     * // Get one ErrorReport
     * const errorReport = await prisma.errorReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ErrorReportFindUniqueArgs>(args: SelectSubset<T, ErrorReportFindUniqueArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ErrorReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ErrorReportFindUniqueOrThrowArgs} args - Arguments to find a ErrorReport
     * @example
     * // Get one ErrorReport
     * const errorReport = await prisma.errorReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ErrorReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ErrorReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ErrorReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportFindFirstArgs} args - Arguments to find a ErrorReport
     * @example
     * // Get one ErrorReport
     * const errorReport = await prisma.errorReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ErrorReportFindFirstArgs>(args?: SelectSubset<T, ErrorReportFindFirstArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ErrorReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportFindFirstOrThrowArgs} args - Arguments to find a ErrorReport
     * @example
     * // Get one ErrorReport
     * const errorReport = await prisma.errorReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ErrorReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ErrorReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ErrorReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ErrorReports
     * const errorReports = await prisma.errorReport.findMany()
     * 
     * // Get first 10 ErrorReports
     * const errorReports = await prisma.errorReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const errorReportWithIdOnly = await prisma.errorReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ErrorReportFindManyArgs>(args?: SelectSubset<T, ErrorReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ErrorReport.
     * @param {ErrorReportCreateArgs} args - Arguments to create a ErrorReport.
     * @example
     * // Create one ErrorReport
     * const ErrorReport = await prisma.errorReport.create({
     *   data: {
     *     // ... data to create a ErrorReport
     *   }
     * })
     * 
     */
    create<T extends ErrorReportCreateArgs>(args: SelectSubset<T, ErrorReportCreateArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ErrorReports.
     * @param {ErrorReportCreateManyArgs} args - Arguments to create many ErrorReports.
     * @example
     * // Create many ErrorReports
     * const errorReport = await prisma.errorReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ErrorReportCreateManyArgs>(args?: SelectSubset<T, ErrorReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ErrorReport.
     * @param {ErrorReportDeleteArgs} args - Arguments to delete one ErrorReport.
     * @example
     * // Delete one ErrorReport
     * const ErrorReport = await prisma.errorReport.delete({
     *   where: {
     *     // ... filter to delete one ErrorReport
     *   }
     * })
     * 
     */
    delete<T extends ErrorReportDeleteArgs>(args: SelectSubset<T, ErrorReportDeleteArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ErrorReport.
     * @param {ErrorReportUpdateArgs} args - Arguments to update one ErrorReport.
     * @example
     * // Update one ErrorReport
     * const errorReport = await prisma.errorReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ErrorReportUpdateArgs>(args: SelectSubset<T, ErrorReportUpdateArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ErrorReports.
     * @param {ErrorReportDeleteManyArgs} args - Arguments to filter ErrorReports to delete.
     * @example
     * // Delete a few ErrorReports
     * const { count } = await prisma.errorReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ErrorReportDeleteManyArgs>(args?: SelectSubset<T, ErrorReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ErrorReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ErrorReports
     * const errorReport = await prisma.errorReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ErrorReportUpdateManyArgs>(args: SelectSubset<T, ErrorReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ErrorReport.
     * @param {ErrorReportUpsertArgs} args - Arguments to update or create a ErrorReport.
     * @example
     * // Update or create a ErrorReport
     * const errorReport = await prisma.errorReport.upsert({
     *   create: {
     *     // ... data to create a ErrorReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ErrorReport we want to update
     *   }
     * })
     */
    upsert<T extends ErrorReportUpsertArgs>(args: SelectSubset<T, ErrorReportUpsertArgs<ExtArgs>>): Prisma__ErrorReportClient<$Result.GetResult<Prisma.$ErrorReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ErrorReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportCountArgs} args - Arguments to filter ErrorReports to count.
     * @example
     * // Count the number of ErrorReports
     * const count = await prisma.errorReport.count({
     *   where: {
     *     // ... the filter for the ErrorReports we want to count
     *   }
     * })
    **/
    count<T extends ErrorReportCountArgs>(
      args?: Subset<T, ErrorReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ErrorReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ErrorReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ErrorReportAggregateArgs>(args: Subset<T, ErrorReportAggregateArgs>): Prisma.PrismaPromise<GetErrorReportAggregateType<T>>

    /**
     * Group by ErrorReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ErrorReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ErrorReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ErrorReportGroupByArgs['orderBy'] }
        : { orderBy?: ErrorReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ErrorReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErrorReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ErrorReport model
   */
  readonly fields: ErrorReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ErrorReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ErrorReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ErrorReport model
   */
  interface ErrorReportFieldRefs {
    readonly id: FieldRef<"ErrorReport", 'String'>
    readonly userId: FieldRef<"ErrorReport", 'String'>
    readonly userEmail: FieldRef<"ErrorReport", 'String'>
    readonly orderId: FieldRef<"ErrorReport", 'String'>
    readonly productLineId: FieldRef<"ErrorReport", 'String'>
    readonly productName: FieldRef<"ErrorReport", 'String'>
    readonly originalContent: FieldRef<"ErrorReport", 'String'>
    readonly userNote: FieldRef<"ErrorReport", 'String'>
    readonly status: FieldRef<"ErrorReport", 'ErrorReportStatus'>
    readonly reportedProducts: FieldRef<"ErrorReport", 'String'>
    readonly adminNote: FieldRef<"ErrorReport", 'String'>
    readonly resolution: FieldRef<"ErrorReport", 'String'>
    readonly resolvedAt: FieldRef<"ErrorReport", 'DateTime'>
    readonly createdAt: FieldRef<"ErrorReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ErrorReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ErrorReport findUnique
   */
  export type ErrorReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * Filter, which ErrorReport to fetch.
     */
    where: ErrorReportWhereUniqueInput
  }

  /**
   * ErrorReport findUniqueOrThrow
   */
  export type ErrorReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * Filter, which ErrorReport to fetch.
     */
    where: ErrorReportWhereUniqueInput
  }

  /**
   * ErrorReport findFirst
   */
  export type ErrorReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * Filter, which ErrorReport to fetch.
     */
    where?: ErrorReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorReports to fetch.
     */
    orderBy?: ErrorReportOrderByWithRelationInput | ErrorReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorReports.
     */
    cursor?: ErrorReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorReports.
     */
    distinct?: ErrorReportScalarFieldEnum | ErrorReportScalarFieldEnum[]
  }

  /**
   * ErrorReport findFirstOrThrow
   */
  export type ErrorReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * Filter, which ErrorReport to fetch.
     */
    where?: ErrorReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorReports to fetch.
     */
    orderBy?: ErrorReportOrderByWithRelationInput | ErrorReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ErrorReports.
     */
    cursor?: ErrorReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ErrorReports.
     */
    distinct?: ErrorReportScalarFieldEnum | ErrorReportScalarFieldEnum[]
  }

  /**
   * ErrorReport findMany
   */
  export type ErrorReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * Filter, which ErrorReports to fetch.
     */
    where?: ErrorReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ErrorReports to fetch.
     */
    orderBy?: ErrorReportOrderByWithRelationInput | ErrorReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ErrorReports.
     */
    cursor?: ErrorReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ErrorReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ErrorReports.
     */
    skip?: number
    distinct?: ErrorReportScalarFieldEnum | ErrorReportScalarFieldEnum[]
  }

  /**
   * ErrorReport create
   */
  export type ErrorReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * The data needed to create a ErrorReport.
     */
    data: XOR<ErrorReportCreateInput, ErrorReportUncheckedCreateInput>
  }

  /**
   * ErrorReport createMany
   */
  export type ErrorReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ErrorReports.
     */
    data: ErrorReportCreateManyInput | ErrorReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ErrorReport update
   */
  export type ErrorReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * The data needed to update a ErrorReport.
     */
    data: XOR<ErrorReportUpdateInput, ErrorReportUncheckedUpdateInput>
    /**
     * Choose, which ErrorReport to update.
     */
    where: ErrorReportWhereUniqueInput
  }

  /**
   * ErrorReport updateMany
   */
  export type ErrorReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ErrorReports.
     */
    data: XOR<ErrorReportUpdateManyMutationInput, ErrorReportUncheckedUpdateManyInput>
    /**
     * Filter which ErrorReports to update
     */
    where?: ErrorReportWhereInput
    /**
     * Limit how many ErrorReports to update.
     */
    limit?: number
  }

  /**
   * ErrorReport upsert
   */
  export type ErrorReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * The filter to search for the ErrorReport to update in case it exists.
     */
    where: ErrorReportWhereUniqueInput
    /**
     * In case the ErrorReport found by the `where` argument doesn't exist, create a new ErrorReport with this data.
     */
    create: XOR<ErrorReportCreateInput, ErrorReportUncheckedCreateInput>
    /**
     * In case the ErrorReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ErrorReportUpdateInput, ErrorReportUncheckedUpdateInput>
  }

  /**
   * ErrorReport delete
   */
  export type ErrorReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
    /**
     * Filter which ErrorReport to delete.
     */
    where: ErrorReportWhereUniqueInput
  }

  /**
   * ErrorReport deleteMany
   */
  export type ErrorReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ErrorReports to delete
     */
    where?: ErrorReportWhereInput
    /**
     * Limit how many ErrorReports to delete.
     */
    limit?: number
  }

  /**
   * ErrorReport without action
   */
  export type ErrorReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ErrorReport
     */
    select?: ErrorReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ErrorReport
     */
    omit?: ErrorReportOmit<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    orderId: string | null
    rating: number | null
    comment: string | null
    isAnonymous: boolean | null
    status: $Enums.ReviewStatus | null
    adminNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    orderId: string | null
    rating: number | null
    comment: string | null
    isAnonymous: boolean | null
    status: $Enums.ReviewStatus | null
    adminNote: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    orderId: number
    rating: number
    comment: number
    isAnonymous: number
    status: number
    adminNote: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    rating?: true
    comment?: true
    isAnonymous?: true
    status?: true
    adminNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    rating?: true
    comment?: true
    isAnonymous?: true
    status?: true
    adminNote?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    orderId?: true
    rating?: true
    comment?: true
    isAnonymous?: true
    status?: true
    adminNote?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    productId: string
    orderId: string
    rating: number
    comment: string | null
    isAnonymous: boolean
    status: $Enums.ReviewStatus
    adminNote: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    isAnonymous?: boolean
    status?: boolean
    adminNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>



  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    orderId?: boolean
    rating?: boolean
    comment?: boolean
    isAnonymous?: boolean
    status?: boolean
    adminNote?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "orderId" | "rating" | "comment" | "isAnonymous" | "status" | "adminNote" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      orderId: string
      rating: number
      comment: string | null
      isAnonymous: boolean
      status: $Enums.ReviewStatus
      adminNote: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly productId: FieldRef<"Review", 'String'>
    readonly orderId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly isAnonymous: FieldRef<"Review", 'Boolean'>
    readonly status: FieldRef<"Review", 'ReviewStatus'>
    readonly adminNote: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    order: number | null
  }

  export type BannerSumAggregateOutputType = {
    order: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    buttonText: string | null
    buttonLink: string | null
    imageUrl: string | null
    gradientFrom: string | null
    gradientTo: string | null
    features: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    buttonText: string | null
    buttonLink: string | null
    imageUrl: string | null
    gradientFrom: string | null
    gradientTo: string | null
    features: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    description: number
    buttonText: number
    buttonLink: number
    imageUrl: number
    gradientFrom: number
    gradientTo: number
    features: number
    order: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    order?: true
  }

  export type BannerSumAggregateInputType = {
    order?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    buttonText?: true
    buttonLink?: true
    imageUrl?: true
    gradientFrom?: true
    gradientTo?: true
    features?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    buttonText?: true
    buttonLink?: true
    imageUrl?: true
    gradientFrom?: true
    gradientTo?: true
    features?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    description?: true
    buttonText?: true
    buttonLink?: true
    imageUrl?: true
    gradientFrom?: true
    gradientTo?: true
    features?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: string
    title: string
    subtitle: string | null
    description: string | null
    buttonText: string
    buttonLink: string
    imageUrl: string | null
    gradientFrom: string
    gradientTo: string
    features: string | null
    order: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    imageUrl?: boolean
    gradientFrom?: boolean
    gradientTo?: boolean
    features?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>



  export type BannerSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    buttonText?: boolean
    buttonLink?: boolean
    imageUrl?: boolean
    gradientFrom?: boolean
    gradientTo?: boolean
    features?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "description" | "buttonText" | "buttonLink" | "imageUrl" | "gradientFrom" | "gradientTo" | "features" | "order" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["banner"]>

  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string | null
      description: string | null
      buttonText: string
      buttonLink: string
      imageUrl: string | null
      gradientFrom: string
      gradientTo: string
      features: string | null
      order: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }

  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BannerFindUniqueArgs>(args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Banner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs>(args: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BannerFindFirstArgs>(args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs>(args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BannerFindManyArgs>(args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
     */
    create<T extends BannerCreateArgs>(args: SelectSubset<T, BannerCreateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banners.
     * @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     * @example
     * // Create many Banners
     * const banner = await prisma.banner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BannerCreateManyArgs>(args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
     */
    delete<T extends BannerDeleteArgs>(args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BannerUpdateArgs>(args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BannerDeleteManyArgs>(args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BannerUpdateManyArgs>(args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
     */
    upsert<T extends BannerUpsertArgs>(args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Banner model
   */
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'String'>
    readonly title: FieldRef<"Banner", 'String'>
    readonly subtitle: FieldRef<"Banner", 'String'>
    readonly description: FieldRef<"Banner", 'String'>
    readonly buttonText: FieldRef<"Banner", 'String'>
    readonly buttonLink: FieldRef<"Banner", 'String'>
    readonly imageUrl: FieldRef<"Banner", 'String'>
    readonly gradientFrom: FieldRef<"Banner", 'String'>
    readonly gradientTo: FieldRef<"Banner", 'String'>
    readonly features: FieldRef<"Banner", 'String'>
    readonly order: FieldRef<"Banner", 'Int'>
    readonly active: FieldRef<"Banner", 'Boolean'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }

  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }

  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to update.
     */
    limit?: number
  }

  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }

  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }

  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
    /**
     * Limit how many Banners to delete.
     */
    limit?: number
  }

  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Banner
     */
    omit?: BannerOmit<ExtArgs> | null
  }


  /**
   * Model FeaturedUser
   */

  export type AggregateFeaturedUser = {
    _count: FeaturedUserCountAggregateOutputType | null
    _avg: FeaturedUserAvgAggregateOutputType | null
    _sum: FeaturedUserSumAggregateOutputType | null
    _min: FeaturedUserMinAggregateOutputType | null
    _max: FeaturedUserMaxAggregateOutputType | null
  }

  export type FeaturedUserAvgAggregateOutputType = {
    sales: number | null
    rating: number | null
    rank: number | null
  }

  export type FeaturedUserSumAggregateOutputType = {
    sales: number | null
    rating: number | null
    rank: number | null
  }

  export type FeaturedUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    sales: number | null
    rating: number | null
    avatarUrl: string | null
    rank: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    sales: number | null
    rating: number | null
    avatarUrl: string | null
    rank: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedUserCountAggregateOutputType = {
    id: number
    name: number
    sales: number
    rating: number
    avatarUrl: number
    rank: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedUserAvgAggregateInputType = {
    sales?: true
    rating?: true
    rank?: true
  }

  export type FeaturedUserSumAggregateInputType = {
    sales?: true
    rating?: true
    rank?: true
  }

  export type FeaturedUserMinAggregateInputType = {
    id?: true
    name?: true
    sales?: true
    rating?: true
    avatarUrl?: true
    rank?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedUserMaxAggregateInputType = {
    id?: true
    name?: true
    sales?: true
    rating?: true
    avatarUrl?: true
    rank?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedUserCountAggregateInputType = {
    id?: true
    name?: true
    sales?: true
    rating?: true
    avatarUrl?: true
    rank?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedUser to aggregate.
     */
    where?: FeaturedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedUsers to fetch.
     */
    orderBy?: FeaturedUserOrderByWithRelationInput | FeaturedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedUsers
    **/
    _count?: true | FeaturedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturedUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturedUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedUserMaxAggregateInputType
  }

  export type GetFeaturedUserAggregateType<T extends FeaturedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedUser[P]>
      : GetScalarType<T[P], AggregateFeaturedUser[P]>
  }




  export type FeaturedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedUserWhereInput
    orderBy?: FeaturedUserOrderByWithAggregationInput | FeaturedUserOrderByWithAggregationInput[]
    by: FeaturedUserScalarFieldEnum[] | FeaturedUserScalarFieldEnum
    having?: FeaturedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedUserCountAggregateInputType | true
    _avg?: FeaturedUserAvgAggregateInputType
    _sum?: FeaturedUserSumAggregateInputType
    _min?: FeaturedUserMinAggregateInputType
    _max?: FeaturedUserMaxAggregateInputType
  }

  export type FeaturedUserGroupByOutputType = {
    id: string
    name: string
    sales: number
    rating: number
    avatarUrl: string | null
    rank: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeaturedUserCountAggregateOutputType | null
    _avg: FeaturedUserAvgAggregateOutputType | null
    _sum: FeaturedUserSumAggregateOutputType | null
    _min: FeaturedUserMinAggregateOutputType | null
    _max: FeaturedUserMaxAggregateOutputType | null
  }

  type GetFeaturedUserGroupByPayload<T extends FeaturedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedUserGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedUserGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sales?: boolean
    rating?: boolean
    avatarUrl?: boolean
    rank?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["featuredUser"]>



  export type FeaturedUserSelectScalar = {
    id?: boolean
    name?: boolean
    sales?: boolean
    rating?: boolean
    avatarUrl?: boolean
    rank?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sales" | "rating" | "avatarUrl" | "rank" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredUser"]>

  export type $FeaturedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      sales: number
      rating: number
      avatarUrl: string | null
      rank: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredUser"]>
    composites: {}
  }

  type FeaturedUserGetPayload<S extends boolean | null | undefined | FeaturedUserDefaultArgs> = $Result.GetResult<Prisma.$FeaturedUserPayload, S>

  type FeaturedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedUserCountAggregateInputType | true
    }

  export interface FeaturedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedUser'], meta: { name: 'FeaturedUser' } }
    /**
     * Find zero or one FeaturedUser that matches the filter.
     * @param {FeaturedUserFindUniqueArgs} args - Arguments to find a FeaturedUser
     * @example
     * // Get one FeaturedUser
     * const featuredUser = await prisma.featuredUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedUserFindUniqueArgs>(args: SelectSubset<T, FeaturedUserFindUniqueArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedUserFindUniqueOrThrowArgs} args - Arguments to find a FeaturedUser
     * @example
     * // Get one FeaturedUser
     * const featuredUser = await prisma.featuredUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserFindFirstArgs} args - Arguments to find a FeaturedUser
     * @example
     * // Get one FeaturedUser
     * const featuredUser = await prisma.featuredUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedUserFindFirstArgs>(args?: SelectSubset<T, FeaturedUserFindFirstArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserFindFirstOrThrowArgs} args - Arguments to find a FeaturedUser
     * @example
     * // Get one FeaturedUser
     * const featuredUser = await prisma.featuredUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedUsers
     * const featuredUsers = await prisma.featuredUser.findMany()
     * 
     * // Get first 10 FeaturedUsers
     * const featuredUsers = await prisma.featuredUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredUserWithIdOnly = await prisma.featuredUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedUserFindManyArgs>(args?: SelectSubset<T, FeaturedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedUser.
     * @param {FeaturedUserCreateArgs} args - Arguments to create a FeaturedUser.
     * @example
     * // Create one FeaturedUser
     * const FeaturedUser = await prisma.featuredUser.create({
     *   data: {
     *     // ... data to create a FeaturedUser
     *   }
     * })
     * 
     */
    create<T extends FeaturedUserCreateArgs>(args: SelectSubset<T, FeaturedUserCreateArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedUsers.
     * @param {FeaturedUserCreateManyArgs} args - Arguments to create many FeaturedUsers.
     * @example
     * // Create many FeaturedUsers
     * const featuredUser = await prisma.featuredUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedUserCreateManyArgs>(args?: SelectSubset<T, FeaturedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeaturedUser.
     * @param {FeaturedUserDeleteArgs} args - Arguments to delete one FeaturedUser.
     * @example
     * // Delete one FeaturedUser
     * const FeaturedUser = await prisma.featuredUser.delete({
     *   where: {
     *     // ... filter to delete one FeaturedUser
     *   }
     * })
     * 
     */
    delete<T extends FeaturedUserDeleteArgs>(args: SelectSubset<T, FeaturedUserDeleteArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedUser.
     * @param {FeaturedUserUpdateArgs} args - Arguments to update one FeaturedUser.
     * @example
     * // Update one FeaturedUser
     * const featuredUser = await prisma.featuredUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedUserUpdateArgs>(args: SelectSubset<T, FeaturedUserUpdateArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedUsers.
     * @param {FeaturedUserDeleteManyArgs} args - Arguments to filter FeaturedUsers to delete.
     * @example
     * // Delete a few FeaturedUsers
     * const { count } = await prisma.featuredUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedUserDeleteManyArgs>(args?: SelectSubset<T, FeaturedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedUsers
     * const featuredUser = await prisma.featuredUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedUserUpdateManyArgs>(args: SelectSubset<T, FeaturedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeaturedUser.
     * @param {FeaturedUserUpsertArgs} args - Arguments to update or create a FeaturedUser.
     * @example
     * // Update or create a FeaturedUser
     * const featuredUser = await prisma.featuredUser.upsert({
     *   create: {
     *     // ... data to create a FeaturedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedUser we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedUserUpsertArgs>(args: SelectSubset<T, FeaturedUserUpsertArgs<ExtArgs>>): Prisma__FeaturedUserClient<$Result.GetResult<Prisma.$FeaturedUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserCountArgs} args - Arguments to filter FeaturedUsers to count.
     * @example
     * // Count the number of FeaturedUsers
     * const count = await prisma.featuredUser.count({
     *   where: {
     *     // ... the filter for the FeaturedUsers we want to count
     *   }
     * })
    **/
    count<T extends FeaturedUserCountArgs>(
      args?: Subset<T, FeaturedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedUserAggregateArgs>(args: Subset<T, FeaturedUserAggregateArgs>): Prisma.PrismaPromise<GetFeaturedUserAggregateType<T>>

    /**
     * Group by FeaturedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedUserGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedUser model
   */
  readonly fields: FeaturedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedUser model
   */
  interface FeaturedUserFieldRefs {
    readonly id: FieldRef<"FeaturedUser", 'String'>
    readonly name: FieldRef<"FeaturedUser", 'String'>
    readonly sales: FieldRef<"FeaturedUser", 'Int'>
    readonly rating: FieldRef<"FeaturedUser", 'Float'>
    readonly avatarUrl: FieldRef<"FeaturedUser", 'String'>
    readonly rank: FieldRef<"FeaturedUser", 'Int'>
    readonly active: FieldRef<"FeaturedUser", 'Boolean'>
    readonly createdAt: FieldRef<"FeaturedUser", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedUser findUnique
   */
  export type FeaturedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * Filter, which FeaturedUser to fetch.
     */
    where: FeaturedUserWhereUniqueInput
  }

  /**
   * FeaturedUser findUniqueOrThrow
   */
  export type FeaturedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * Filter, which FeaturedUser to fetch.
     */
    where: FeaturedUserWhereUniqueInput
  }

  /**
   * FeaturedUser findFirst
   */
  export type FeaturedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * Filter, which FeaturedUser to fetch.
     */
    where?: FeaturedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedUsers to fetch.
     */
    orderBy?: FeaturedUserOrderByWithRelationInput | FeaturedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedUsers.
     */
    cursor?: FeaturedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedUsers.
     */
    distinct?: FeaturedUserScalarFieldEnum | FeaturedUserScalarFieldEnum[]
  }

  /**
   * FeaturedUser findFirstOrThrow
   */
  export type FeaturedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * Filter, which FeaturedUser to fetch.
     */
    where?: FeaturedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedUsers to fetch.
     */
    orderBy?: FeaturedUserOrderByWithRelationInput | FeaturedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedUsers.
     */
    cursor?: FeaturedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedUsers.
     */
    distinct?: FeaturedUserScalarFieldEnum | FeaturedUserScalarFieldEnum[]
  }

  /**
   * FeaturedUser findMany
   */
  export type FeaturedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * Filter, which FeaturedUsers to fetch.
     */
    where?: FeaturedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedUsers to fetch.
     */
    orderBy?: FeaturedUserOrderByWithRelationInput | FeaturedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedUsers.
     */
    cursor?: FeaturedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedUsers.
     */
    skip?: number
    distinct?: FeaturedUserScalarFieldEnum | FeaturedUserScalarFieldEnum[]
  }

  /**
   * FeaturedUser create
   */
  export type FeaturedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * The data needed to create a FeaturedUser.
     */
    data: XOR<FeaturedUserCreateInput, FeaturedUserUncheckedCreateInput>
  }

  /**
   * FeaturedUser createMany
   */
  export type FeaturedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedUsers.
     */
    data: FeaturedUserCreateManyInput | FeaturedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedUser update
   */
  export type FeaturedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * The data needed to update a FeaturedUser.
     */
    data: XOR<FeaturedUserUpdateInput, FeaturedUserUncheckedUpdateInput>
    /**
     * Choose, which FeaturedUser to update.
     */
    where: FeaturedUserWhereUniqueInput
  }

  /**
   * FeaturedUser updateMany
   */
  export type FeaturedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedUsers.
     */
    data: XOR<FeaturedUserUpdateManyMutationInput, FeaturedUserUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedUsers to update
     */
    where?: FeaturedUserWhereInput
    /**
     * Limit how many FeaturedUsers to update.
     */
    limit?: number
  }

  /**
   * FeaturedUser upsert
   */
  export type FeaturedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * The filter to search for the FeaturedUser to update in case it exists.
     */
    where: FeaturedUserWhereUniqueInput
    /**
     * In case the FeaturedUser found by the `where` argument doesn't exist, create a new FeaturedUser with this data.
     */
    create: XOR<FeaturedUserCreateInput, FeaturedUserUncheckedCreateInput>
    /**
     * In case the FeaturedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedUserUpdateInput, FeaturedUserUncheckedUpdateInput>
  }

  /**
   * FeaturedUser delete
   */
  export type FeaturedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
    /**
     * Filter which FeaturedUser to delete.
     */
    where: FeaturedUserWhereUniqueInput
  }

  /**
   * FeaturedUser deleteMany
   */
  export type FeaturedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedUsers to delete
     */
    where?: FeaturedUserWhereInput
    /**
     * Limit how many FeaturedUsers to delete.
     */
    limit?: number
  }

  /**
   * FeaturedUser without action
   */
  export type FeaturedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedUser
     */
    select?: FeaturedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedUser
     */
    omit?: FeaturedUserOmit<ExtArgs> | null
  }


  /**
   * Model SearchKeyword
   */

  export type AggregateSearchKeyword = {
    _count: SearchKeywordCountAggregateOutputType | null
    _avg: SearchKeywordAvgAggregateOutputType | null
    _sum: SearchKeywordSumAggregateOutputType | null
    _min: SearchKeywordMinAggregateOutputType | null
    _max: SearchKeywordMaxAggregateOutputType | null
  }

  export type SearchKeywordAvgAggregateOutputType = {
    order: number | null
  }

  export type SearchKeywordSumAggregateOutputType = {
    order: number | null
  }

  export type SearchKeywordMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    subtitle: string | null
    icon: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchKeywordMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    subtitle: string | null
    icon: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchKeywordCountAggregateOutputType = {
    id: number
    keyword: number
    subtitle: number
    icon: number
    order: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SearchKeywordAvgAggregateInputType = {
    order?: true
  }

  export type SearchKeywordSumAggregateInputType = {
    order?: true
  }

  export type SearchKeywordMinAggregateInputType = {
    id?: true
    keyword?: true
    subtitle?: true
    icon?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchKeywordMaxAggregateInputType = {
    id?: true
    keyword?: true
    subtitle?: true
    icon?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchKeywordCountAggregateInputType = {
    id?: true
    keyword?: true
    subtitle?: true
    icon?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SearchKeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchKeyword to aggregate.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchKeywords
    **/
    _count?: true | SearchKeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchKeywordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchKeywordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchKeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchKeywordMaxAggregateInputType
  }

  export type GetSearchKeywordAggregateType<T extends SearchKeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchKeyword[P]>
      : GetScalarType<T[P], AggregateSearchKeyword[P]>
  }




  export type SearchKeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchKeywordWhereInput
    orderBy?: SearchKeywordOrderByWithAggregationInput | SearchKeywordOrderByWithAggregationInput[]
    by: SearchKeywordScalarFieldEnum[] | SearchKeywordScalarFieldEnum
    having?: SearchKeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchKeywordCountAggregateInputType | true
    _avg?: SearchKeywordAvgAggregateInputType
    _sum?: SearchKeywordSumAggregateInputType
    _min?: SearchKeywordMinAggregateInputType
    _max?: SearchKeywordMaxAggregateInputType
  }

  export type SearchKeywordGroupByOutputType = {
    id: string
    keyword: string
    subtitle: string | null
    icon: string
    order: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: SearchKeywordCountAggregateOutputType | null
    _avg: SearchKeywordAvgAggregateOutputType | null
    _sum: SearchKeywordSumAggregateOutputType | null
    _min: SearchKeywordMinAggregateOutputType | null
    _max: SearchKeywordMaxAggregateOutputType | null
  }

  type GetSearchKeywordGroupByPayload<T extends SearchKeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchKeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchKeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchKeywordGroupByOutputType[P]>
            : GetScalarType<T[P], SearchKeywordGroupByOutputType[P]>
        }
      >
    >


  export type SearchKeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    subtitle?: boolean
    icon?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["searchKeyword"]>



  export type SearchKeywordSelectScalar = {
    id?: boolean
    keyword?: boolean
    subtitle?: boolean
    icon?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SearchKeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "subtitle" | "icon" | "order" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["searchKeyword"]>

  export type $SearchKeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchKeyword"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      subtitle: string | null
      icon: string
      order: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["searchKeyword"]>
    composites: {}
  }

  type SearchKeywordGetPayload<S extends boolean | null | undefined | SearchKeywordDefaultArgs> = $Result.GetResult<Prisma.$SearchKeywordPayload, S>

  type SearchKeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchKeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchKeywordCountAggregateInputType | true
    }

  export interface SearchKeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchKeyword'], meta: { name: 'SearchKeyword' } }
    /**
     * Find zero or one SearchKeyword that matches the filter.
     * @param {SearchKeywordFindUniqueArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchKeywordFindUniqueArgs>(args: SelectSubset<T, SearchKeywordFindUniqueArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchKeyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchKeywordFindUniqueOrThrowArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchKeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchKeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchKeyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordFindFirstArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchKeywordFindFirstArgs>(args?: SelectSubset<T, SearchKeywordFindFirstArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchKeyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordFindFirstOrThrowArgs} args - Arguments to find a SearchKeyword
     * @example
     * // Get one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchKeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchKeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchKeywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchKeywords
     * const searchKeywords = await prisma.searchKeyword.findMany()
     * 
     * // Get first 10 SearchKeywords
     * const searchKeywords = await prisma.searchKeyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchKeywordWithIdOnly = await prisma.searchKeyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchKeywordFindManyArgs>(args?: SelectSubset<T, SearchKeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchKeyword.
     * @param {SearchKeywordCreateArgs} args - Arguments to create a SearchKeyword.
     * @example
     * // Create one SearchKeyword
     * const SearchKeyword = await prisma.searchKeyword.create({
     *   data: {
     *     // ... data to create a SearchKeyword
     *   }
     * })
     * 
     */
    create<T extends SearchKeywordCreateArgs>(args: SelectSubset<T, SearchKeywordCreateArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchKeywords.
     * @param {SearchKeywordCreateManyArgs} args - Arguments to create many SearchKeywords.
     * @example
     * // Create many SearchKeywords
     * const searchKeyword = await prisma.searchKeyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchKeywordCreateManyArgs>(args?: SelectSubset<T, SearchKeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SearchKeyword.
     * @param {SearchKeywordDeleteArgs} args - Arguments to delete one SearchKeyword.
     * @example
     * // Delete one SearchKeyword
     * const SearchKeyword = await prisma.searchKeyword.delete({
     *   where: {
     *     // ... filter to delete one SearchKeyword
     *   }
     * })
     * 
     */
    delete<T extends SearchKeywordDeleteArgs>(args: SelectSubset<T, SearchKeywordDeleteArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchKeyword.
     * @param {SearchKeywordUpdateArgs} args - Arguments to update one SearchKeyword.
     * @example
     * // Update one SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchKeywordUpdateArgs>(args: SelectSubset<T, SearchKeywordUpdateArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchKeywords.
     * @param {SearchKeywordDeleteManyArgs} args - Arguments to filter SearchKeywords to delete.
     * @example
     * // Delete a few SearchKeywords
     * const { count } = await prisma.searchKeyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchKeywordDeleteManyArgs>(args?: SelectSubset<T, SearchKeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchKeywords
     * const searchKeyword = await prisma.searchKeyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchKeywordUpdateManyArgs>(args: SelectSubset<T, SearchKeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchKeyword.
     * @param {SearchKeywordUpsertArgs} args - Arguments to update or create a SearchKeyword.
     * @example
     * // Update or create a SearchKeyword
     * const searchKeyword = await prisma.searchKeyword.upsert({
     *   create: {
     *     // ... data to create a SearchKeyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchKeyword we want to update
     *   }
     * })
     */
    upsert<T extends SearchKeywordUpsertArgs>(args: SelectSubset<T, SearchKeywordUpsertArgs<ExtArgs>>): Prisma__SearchKeywordClient<$Result.GetResult<Prisma.$SearchKeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordCountArgs} args - Arguments to filter SearchKeywords to count.
     * @example
     * // Count the number of SearchKeywords
     * const count = await prisma.searchKeyword.count({
     *   where: {
     *     // ... the filter for the SearchKeywords we want to count
     *   }
     * })
    **/
    count<T extends SearchKeywordCountArgs>(
      args?: Subset<T, SearchKeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchKeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchKeywordAggregateArgs>(args: Subset<T, SearchKeywordAggregateArgs>): Prisma.PrismaPromise<GetSearchKeywordAggregateType<T>>

    /**
     * Group by SearchKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchKeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchKeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchKeywordGroupByArgs['orderBy'] }
        : { orderBy?: SearchKeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchKeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchKeyword model
   */
  readonly fields: SearchKeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchKeyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchKeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchKeyword model
   */
  interface SearchKeywordFieldRefs {
    readonly id: FieldRef<"SearchKeyword", 'String'>
    readonly keyword: FieldRef<"SearchKeyword", 'String'>
    readonly subtitle: FieldRef<"SearchKeyword", 'String'>
    readonly icon: FieldRef<"SearchKeyword", 'String'>
    readonly order: FieldRef<"SearchKeyword", 'Int'>
    readonly active: FieldRef<"SearchKeyword", 'Boolean'>
    readonly createdAt: FieldRef<"SearchKeyword", 'DateTime'>
    readonly updatedAt: FieldRef<"SearchKeyword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchKeyword findUnique
   */
  export type SearchKeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword findUniqueOrThrow
   */
  export type SearchKeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword findFirst
   */
  export type SearchKeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchKeywords.
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchKeywords.
     */
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * SearchKeyword findFirstOrThrow
   */
  export type SearchKeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Filter, which SearchKeyword to fetch.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchKeywords.
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchKeywords.
     */
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * SearchKeyword findMany
   */
  export type SearchKeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Filter, which SearchKeywords to fetch.
     */
    where?: SearchKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchKeywords to fetch.
     */
    orderBy?: SearchKeywordOrderByWithRelationInput | SearchKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchKeywords.
     */
    cursor?: SearchKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchKeywords.
     */
    skip?: number
    distinct?: SearchKeywordScalarFieldEnum | SearchKeywordScalarFieldEnum[]
  }

  /**
   * SearchKeyword create
   */
  export type SearchKeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * The data needed to create a SearchKeyword.
     */
    data: XOR<SearchKeywordCreateInput, SearchKeywordUncheckedCreateInput>
  }

  /**
   * SearchKeyword createMany
   */
  export type SearchKeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchKeywords.
     */
    data: SearchKeywordCreateManyInput | SearchKeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchKeyword update
   */
  export type SearchKeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * The data needed to update a SearchKeyword.
     */
    data: XOR<SearchKeywordUpdateInput, SearchKeywordUncheckedUpdateInput>
    /**
     * Choose, which SearchKeyword to update.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword updateMany
   */
  export type SearchKeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchKeywords.
     */
    data: XOR<SearchKeywordUpdateManyMutationInput, SearchKeywordUncheckedUpdateManyInput>
    /**
     * Filter which SearchKeywords to update
     */
    where?: SearchKeywordWhereInput
    /**
     * Limit how many SearchKeywords to update.
     */
    limit?: number
  }

  /**
   * SearchKeyword upsert
   */
  export type SearchKeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * The filter to search for the SearchKeyword to update in case it exists.
     */
    where: SearchKeywordWhereUniqueInput
    /**
     * In case the SearchKeyword found by the `where` argument doesn't exist, create a new SearchKeyword with this data.
     */
    create: XOR<SearchKeywordCreateInput, SearchKeywordUncheckedCreateInput>
    /**
     * In case the SearchKeyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchKeywordUpdateInput, SearchKeywordUncheckedUpdateInput>
  }

  /**
   * SearchKeyword delete
   */
  export type SearchKeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
    /**
     * Filter which SearchKeyword to delete.
     */
    where: SearchKeywordWhereUniqueInput
  }

  /**
   * SearchKeyword deleteMany
   */
  export type SearchKeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchKeywords to delete
     */
    where?: SearchKeywordWhereInput
    /**
     * Limit how many SearchKeywords to delete.
     */
    limit?: number
  }

  /**
   * SearchKeyword without action
   */
  export type SearchKeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchKeyword
     */
    select?: SearchKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchKeyword
     */
    omit?: SearchKeywordOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referralCode: 'referralCode',
    referredById: 'referredById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balanceVnd: 'balanceVnd',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    icon: 'icon',
    order: 'order',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    priceVnd: 'priceVnd',
    stock: 'stock',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    totalLines: 'totalLines',
    usedLines: 'usedLines',
    images: 'images',
    active: 'active',
    fakeSold: 'fakeSold',
    fakeRating: 'fakeRating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductLogScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    userId: 'userId',
    orderId: 'orderId',
    action: 'action',
    quantity: 'quantity',
    lineIndices: 'lineIndices',
    content: 'content',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ProductLogScalarFieldEnum = (typeof ProductLogScalarFieldEnum)[keyof typeof ProductLogScalarFieldEnum]


  export const ProductLineItemScalarFieldEnum: {
    id: 'id',
    productLogId: 'productLogId',
    orderId: 'orderId',
    productName: 'productName',
    content: 'content',
    priceVnd: 'priceVnd',
    status: 'status',
    errorReported: 'errorReported',
    replacement: 'replacement',
    adminNote: 'adminNote',
    rejectedAt: 'rejectedAt',
    replacedAt: 'replacedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductLineItemScalarFieldEnum = (typeof ProductLineItemScalarFieldEnum)[keyof typeof ProductLineItemScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    s3Key: 's3Key',
    size: 'size',
    checksum: 'checksum',
    createdAt: 'createdAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    codeOrJwt: 'codeOrJwt',
    status: 'status',
    boundEmail: 'boundEmail',
    issuedAt: 'issuedAt',
    createdAt: 'createdAt'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    totalAmountVnd: 'totalAmountVnd',
    discountVnd: 'discountVnd',
    couponCode: 'couponCode',
    currency: 'currency',
    itemsJson: 'itemsJson',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    priceVnd: 'priceVnd'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    provider: 'provider',
    providerTxid: 'providerTxid',
    amountVnd: 'amountVnd',
    rawJson: 'rawJson',
    matchedBy: 'matchedBy',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ManualDepositRequestScalarFieldEnum: {
    id: 'id',
    internalId: 'internalId',
    userId: 'userId',
    amountVnd: 'amountVnd',
    note: 'note',
    qrCode: 'qrCode',
    transferContent: 'transferContent',
    status: 'status',
    adminNote: 'adminNote',
    decidedAt: 'decidedAt',
    createdAt: 'createdAt'
  };

  export type ManualDepositRequestScalarFieldEnum = (typeof ManualDepositRequestScalarFieldEnum)[keyof typeof ManualDepositRequestScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    maxDiscountVnd: 'maxDiscountVnd',
    minOrderVnd: 'minOrderVnd',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    startDate: 'startDate',
    expiryDate: 'expiryDate',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    websiteName: 'websiteName',
    websiteTitle: 'websiteTitle',
    websiteDescription: 'websiteDescription',
    websiteKeywords: 'websiteKeywords',
    websiteLogo: 'websiteLogo',
    websiteFavicon: 'websiteFavicon',
    copyrightYear: 'copyrightYear',
    supportEmail: 'supportEmail',
    contactInfo: 'contactInfo',
    paymentMethods: 'paymentMethods',
    bankInfo: 'bankInfo',
    topupRules: 'topupRules',
    tpbankConfig: 'tpbankConfig',
    depositBonusTiers: 'depositBonusTiers',
    referralSettings: 'referralSettings',
    uiTexts: 'uiTexts',
    themeSettings: 'themeSettings',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const DownloadLogScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    fileId: 'fileId',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type DownloadLogScalarFieldEnum = (typeof DownloadLogScalarFieldEnum)[keyof typeof DownloadLogScalarFieldEnum]


  export const AdminActionLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    diffJson: 'diffJson',
    createdAt: 'createdAt'
  };

  export type AdminActionLogScalarFieldEnum = (typeof AdminActionLogScalarFieldEnum)[keyof typeof AdminActionLogScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amountVnd: 'amountVnd',
    balanceAfterVnd: 'balanceAfterVnd',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const WebsiteSettingsScalarFieldEnum: {
    key: 'key',
    value: 'value',
    updatedAt: 'updatedAt'
  };

  export type WebsiteSettingsScalarFieldEnum = (typeof WebsiteSettingsScalarFieldEnum)[keyof typeof WebsiteSettingsScalarFieldEnum]


  export const AutoTopupLogScalarFieldEnum: {
    id: 'id',
    bankTransactionId: 'bankTransactionId',
    bankName: 'bankName',
    depositRequestId: 'depositRequestId',
    userId: 'userId',
    topupCode: 'topupCode',
    amountVnd: 'amountVnd',
    description: 'description',
    status: 'status',
    errorMessage: 'errorMessage',
    transactionDate: 'transactionDate',
    createdAt: 'createdAt'
  };

  export type AutoTopupLogScalarFieldEnum = (typeof AutoTopupLogScalarFieldEnum)[keyof typeof AutoTopupLogScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    referralCode: 'referralCode',
    referrerRewardVnd: 'referrerRewardVnd',
    refereeRewardVnd: 'refereeRewardVnd',
    rewardPaid: 'rewardPaid',
    rewardPaidAt: 'rewardPaidAt',
    firstDepositVnd: 'firstDepositVnd',
    firstDepositAt: 'firstDepositAt',
    createdAt: 'createdAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const UserActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    metadata: 'metadata',
    ip: 'ip',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type UserActivityLogScalarFieldEnum = (typeof UserActivityLogScalarFieldEnum)[keyof typeof UserActivityLogScalarFieldEnum]


  export const TwoFactorAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    issuer: 'issuer',
    secret: 'secret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwoFactorAccountScalarFieldEnum = (typeof TwoFactorAccountScalarFieldEnum)[keyof typeof TwoFactorAccountScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    used: 'used'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const AdvertisementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    placement: 'placement',
    content: 'content',
    imageUrl: 'imageUrl',
    clickUrl: 'clickUrl',
    order: 'order',
    enabled: 'enabled',
    impressions: 'impressions',
    clicks: 'clicks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    amount: 'amount',
    description: 'description',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const ErrorReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    orderId: 'orderId',
    productLineId: 'productLineId',
    productName: 'productName',
    originalContent: 'originalContent',
    userNote: 'userNote',
    status: 'status',
    reportedProducts: 'reportedProducts',
    adminNote: 'adminNote',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ErrorReportScalarFieldEnum = (typeof ErrorReportScalarFieldEnum)[keyof typeof ErrorReportScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    orderId: 'orderId',
    rating: 'rating',
    comment: 'comment',
    isAnonymous: 'isAnonymous',
    status: 'status',
    adminNote: 'adminNote',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    buttonText: 'buttonText',
    buttonLink: 'buttonLink',
    imageUrl: 'imageUrl',
    gradientFrom: 'gradientFrom',
    gradientTo: 'gradientTo',
    features: 'features',
    order: 'order',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const FeaturedUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sales: 'sales',
    rating: 'rating',
    avatarUrl: 'avatarUrl',
    rank: 'rank',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedUserScalarFieldEnum = (typeof FeaturedUserScalarFieldEnum)[keyof typeof FeaturedUserScalarFieldEnum]


  export const SearchKeywordScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    subtitle: 'subtitle',
    icon: 'icon',
    order: 'order',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SearchKeywordScalarFieldEnum = (typeof SearchKeywordScalarFieldEnum)[keyof typeof SearchKeywordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    referralCode: 'referralCode',
    referredById: 'referredById'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const WalletOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type WalletOrderByRelevanceFieldEnum = (typeof WalletOrderByRelevanceFieldEnum)[keyof typeof WalletOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    icon: 'icon'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    images: 'images'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const ProductLogOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    userId: 'userId',
    orderId: 'orderId',
    action: 'action',
    lineIndices: 'lineIndices',
    content: 'content',
    notes: 'notes'
  };

  export type ProductLogOrderByRelevanceFieldEnum = (typeof ProductLogOrderByRelevanceFieldEnum)[keyof typeof ProductLogOrderByRelevanceFieldEnum]


  export const ProductLineItemOrderByRelevanceFieldEnum: {
    id: 'id',
    productLogId: 'productLogId',
    orderId: 'orderId',
    productName: 'productName',
    content: 'content',
    replacement: 'replacement',
    adminNote: 'adminNote'
  };

  export type ProductLineItemOrderByRelevanceFieldEnum = (typeof ProductLineItemOrderByRelevanceFieldEnum)[keyof typeof ProductLineItemOrderByRelevanceFieldEnum]


  export const FileOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    s3Key: 's3Key',
    checksum: 'checksum'
  };

  export type FileOrderByRelevanceFieldEnum = (typeof FileOrderByRelevanceFieldEnum)[keyof typeof FileOrderByRelevanceFieldEnum]


  export const LicenseOrderByRelevanceFieldEnum: {
    id: 'id',
    productId: 'productId',
    codeOrJwt: 'codeOrJwt',
    boundEmail: 'boundEmail'
  };

  export type LicenseOrderByRelevanceFieldEnum = (typeof LicenseOrderByRelevanceFieldEnum)[keyof typeof LicenseOrderByRelevanceFieldEnum]


  export const OrderOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    couponCode: 'couponCode',
    currency: 'currency',
    itemsJson: 'itemsJson'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const OrderItemOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId'
  };

  export type OrderItemOrderByRelevanceFieldEnum = (typeof OrderItemOrderByRelevanceFieldEnum)[keyof typeof OrderItemOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    providerTxid: 'providerTxid',
    rawJson: 'rawJson',
    matchedBy: 'matchedBy'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const ManualDepositRequestOrderByRelevanceFieldEnum: {
    internalId: 'internalId',
    userId: 'userId',
    note: 'note',
    qrCode: 'qrCode',
    transferContent: 'transferContent',
    adminNote: 'adminNote'
  };

  export type ManualDepositRequestOrderByRelevanceFieldEnum = (typeof ManualDepositRequestOrderByRelevanceFieldEnum)[keyof typeof ManualDepositRequestOrderByRelevanceFieldEnum]


  export const CouponOrderByRelevanceFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description'
  };

  export type CouponOrderByRelevanceFieldEnum = (typeof CouponOrderByRelevanceFieldEnum)[keyof typeof CouponOrderByRelevanceFieldEnum]


  export const SettingsOrderByRelevanceFieldEnum: {
    id: 'id',
    websiteName: 'websiteName',
    websiteTitle: 'websiteTitle',
    websiteDescription: 'websiteDescription',
    websiteKeywords: 'websiteKeywords',
    websiteLogo: 'websiteLogo',
    websiteFavicon: 'websiteFavicon',
    copyrightYear: 'copyrightYear',
    supportEmail: 'supportEmail',
    contactInfo: 'contactInfo',
    paymentMethods: 'paymentMethods',
    bankInfo: 'bankInfo',
    topupRules: 'topupRules',
    tpbankConfig: 'tpbankConfig',
    depositBonusTiers: 'depositBonusTiers',
    referralSettings: 'referralSettings',
    uiTexts: 'uiTexts',
    themeSettings: 'themeSettings'
  };

  export type SettingsOrderByRelevanceFieldEnum = (typeof SettingsOrderByRelevanceFieldEnum)[keyof typeof SettingsOrderByRelevanceFieldEnum]


  export const DownloadLogOrderByRelevanceFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    fileId: 'fileId',
    ip: 'ip',
    userAgent: 'userAgent'
  };

  export type DownloadLogOrderByRelevanceFieldEnum = (typeof DownloadLogOrderByRelevanceFieldEnum)[keyof typeof DownloadLogOrderByRelevanceFieldEnum]


  export const AdminActionLogOrderByRelevanceFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    diffJson: 'diffJson'
  };

  export type AdminActionLogOrderByRelevanceFieldEnum = (typeof AdminActionLogOrderByRelevanceFieldEnum)[keyof typeof AdminActionLogOrderByRelevanceFieldEnum]


  export const WalletTransactionOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    description: 'description',
    metadata: 'metadata'
  };

  export type WalletTransactionOrderByRelevanceFieldEnum = (typeof WalletTransactionOrderByRelevanceFieldEnum)[keyof typeof WalletTransactionOrderByRelevanceFieldEnum]


  export const WebsiteSettingsOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type WebsiteSettingsOrderByRelevanceFieldEnum = (typeof WebsiteSettingsOrderByRelevanceFieldEnum)[keyof typeof WebsiteSettingsOrderByRelevanceFieldEnum]


  export const AutoTopupLogOrderByRelevanceFieldEnum: {
    id: 'id',
    bankTransactionId: 'bankTransactionId',
    bankName: 'bankName',
    userId: 'userId',
    topupCode: 'topupCode',
    description: 'description',
    errorMessage: 'errorMessage'
  };

  export type AutoTopupLogOrderByRelevanceFieldEnum = (typeof AutoTopupLogOrderByRelevanceFieldEnum)[keyof typeof AutoTopupLogOrderByRelevanceFieldEnum]


  export const ReferralOrderByRelevanceFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    referralCode: 'referralCode'
  };

  export type ReferralOrderByRelevanceFieldEnum = (typeof ReferralOrderByRelevanceFieldEnum)[keyof typeof ReferralOrderByRelevanceFieldEnum]


  export const UserActivityLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    metadata: 'metadata',
    ip: 'ip',
    userAgent: 'userAgent'
  };

  export type UserActivityLogOrderByRelevanceFieldEnum = (typeof UserActivityLogOrderByRelevanceFieldEnum)[keyof typeof UserActivityLogOrderByRelevanceFieldEnum]


  export const TwoFactorAccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    issuer: 'issuer',
    secret: 'secret'
  };

  export type TwoFactorAccountOrderByRelevanceFieldEnum = (typeof TwoFactorAccountOrderByRelevanceFieldEnum)[keyof typeof TwoFactorAccountOrderByRelevanceFieldEnum]


  export const PasswordResetTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token'
  };

  export type PasswordResetTokenOrderByRelevanceFieldEnum = (typeof PasswordResetTokenOrderByRelevanceFieldEnum)[keyof typeof PasswordResetTokenOrderByRelevanceFieldEnum]


  export const AdvertisementOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    imageUrl: 'imageUrl',
    clickUrl: 'clickUrl'
  };

  export type AdvertisementOrderByRelevanceFieldEnum = (typeof AdvertisementOrderByRelevanceFieldEnum)[keyof typeof AdvertisementOrderByRelevanceFieldEnum]


  export const SystemLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    targetType: 'targetType',
    targetId: 'targetId',
    description: 'description',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SystemLogOrderByRelevanceFieldEnum = (typeof SystemLogOrderByRelevanceFieldEnum)[keyof typeof SystemLogOrderByRelevanceFieldEnum]


  export const ErrorReportOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    userEmail: 'userEmail',
    orderId: 'orderId',
    productLineId: 'productLineId',
    productName: 'productName',
    originalContent: 'originalContent',
    userNote: 'userNote',
    reportedProducts: 'reportedProducts',
    adminNote: 'adminNote',
    resolution: 'resolution'
  };

  export type ErrorReportOrderByRelevanceFieldEnum = (typeof ErrorReportOrderByRelevanceFieldEnum)[keyof typeof ErrorReportOrderByRelevanceFieldEnum]


  export const ReviewOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    orderId: 'orderId',
    comment: 'comment',
    adminNote: 'adminNote'
  };

  export type ReviewOrderByRelevanceFieldEnum = (typeof ReviewOrderByRelevanceFieldEnum)[keyof typeof ReviewOrderByRelevanceFieldEnum]


  export const BannerOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    buttonText: 'buttonText',
    buttonLink: 'buttonLink',
    imageUrl: 'imageUrl',
    gradientFrom: 'gradientFrom',
    gradientTo: 'gradientTo',
    features: 'features'
  };

  export type BannerOrderByRelevanceFieldEnum = (typeof BannerOrderByRelevanceFieldEnum)[keyof typeof BannerOrderByRelevanceFieldEnum]


  export const FeaturedUserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    avatarUrl: 'avatarUrl'
  };

  export type FeaturedUserOrderByRelevanceFieldEnum = (typeof FeaturedUserOrderByRelevanceFieldEnum)[keyof typeof FeaturedUserOrderByRelevanceFieldEnum]


  export const SearchKeywordOrderByRelevanceFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    subtitle: 'subtitle',
    icon: 'icon'
  };

  export type SearchKeywordOrderByRelevanceFieldEnum = (typeof SearchKeywordOrderByRelevanceFieldEnum)[keyof typeof SearchKeywordOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ProductLineStatus'
   */
  export type EnumProductLineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductLineStatus'>
    


  /**
   * Reference to a field of type 'LicenseStatus'
   */
  export type EnumLicenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'DepositStatus'
   */
  export type EnumDepositStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositStatus'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'WalletTransactionType'
   */
  export type EnumWalletTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletTransactionType'>
    


  /**
   * Reference to a field of type 'AutoTopupStatus'
   */
  export type EnumAutoTopupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AutoTopupStatus'>
    


  /**
   * Reference to a field of type 'AdType'
   */
  export type EnumAdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdType'>
    


  /**
   * Reference to a field of type 'AdPlacement'
   */
  export type EnumAdPlacementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdPlacement'>
    


  /**
   * Reference to a field of type 'SystemLogAction'
   */
  export type EnumSystemLogActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SystemLogAction'>
    


  /**
   * Reference to a field of type 'ErrorReportStatus'
   */
  export type EnumErrorReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ErrorReportStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringNullableFilter<"User"> | string | null
    referredById?: StringNullableFilter<"User"> | string | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    orders?: OrderListRelationFilter
    depositRequests?: ManualDepositRequestListRelationFilter
    adminActions?: AdminActionLogListRelationFilter
    productLogs?: ProductLogListRelationFilter
    twoFactorAccounts?: TwoFactorAccountListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    referrals?: ReferralListRelationFilter
    referredBy?: XOR<ReferralNullableScalarRelationFilter, ReferralWhereInput> | null
    reviews?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredById?: SortOrderInput | SortOrder
    wallet?: WalletOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    depositRequests?: ManualDepositRequestOrderByRelationAggregateInput
    adminActions?: AdminActionLogOrderByRelationAggregateInput
    productLogs?: ProductLogOrderByRelationAggregateInput
    twoFactorAccounts?: TwoFactorAccountOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    referredBy?: ReferralOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referredById?: StringNullableFilter<"User"> | string | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    orders?: OrderListRelationFilter
    depositRequests?: ManualDepositRequestListRelationFilter
    adminActions?: AdminActionLogListRelationFilter
    productLogs?: ProductLogListRelationFilter
    twoFactorAccounts?: TwoFactorAccountListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    referrals?: ReferralListRelationFilter
    referredBy?: XOR<ReferralNullableScalarRelationFilter, ReferralWhereInput> | null
    reviews?: ReviewListRelationFilter
  }, "id" | "email" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referredById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    referredById?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    balanceVnd?: FloatFilter<"Wallet"> | number
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balanceVnd?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: WalletOrderByRelevanceInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balanceVnd?: FloatFilter<"Wallet"> | number
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balanceVnd?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    balanceVnd?: FloatWithAggregatesFilter<"Wallet"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    icon?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    active?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    active?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    slug?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    order?: IntWithAggregatesFilter<"Category"> | number
    active?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    categoryId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    priceVnd?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    fileUrl?: StringNullableFilter<"Product"> | string | null
    fileName?: StringNullableFilter<"Product"> | string | null
    totalLines?: IntFilter<"Product"> | number
    usedLines?: IntFilter<"Product"> | number
    images?: StringNullableFilter<"Product"> | string | null
    active?: BoolFilter<"Product"> | boolean
    fakeSold?: IntFilter<"Product"> | number
    fakeRating?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    orderItems?: OrderItemListRelationFilter
    productLogs?: ProductLogListRelationFilter
    files?: FileListRelationFilter
    licenses?: LicenseListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    priceVnd?: SortOrder
    stock?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    images?: SortOrderInput | SortOrder
    active?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    productLogs?: ProductLogOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    licenses?: LicenseOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    categoryId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    priceVnd?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    fileUrl?: StringNullableFilter<"Product"> | string | null
    fileName?: StringNullableFilter<"Product"> | string | null
    totalLines?: IntFilter<"Product"> | number
    usedLines?: IntFilter<"Product"> | number
    images?: StringNullableFilter<"Product"> | string | null
    active?: BoolFilter<"Product"> | boolean
    fakeSold?: IntFilter<"Product"> | number
    fakeRating?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    orderItems?: OrderItemListRelationFilter
    productLogs?: ProductLogListRelationFilter
    files?: FileListRelationFilter
    licenses?: LicenseListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "slug">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    priceVnd?: SortOrder
    stock?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    images?: SortOrderInput | SortOrder
    active?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    categoryId?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    priceVnd?: FloatWithAggregatesFilter<"Product"> | number
    stock?: IntWithAggregatesFilter<"Product"> | number
    fileUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    totalLines?: IntWithAggregatesFilter<"Product"> | number
    usedLines?: IntWithAggregatesFilter<"Product"> | number
    images?: StringNullableWithAggregatesFilter<"Product"> | string | null
    active?: BoolWithAggregatesFilter<"Product"> | boolean
    fakeSold?: IntWithAggregatesFilter<"Product"> | number
    fakeRating?: FloatWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductLogWhereInput = {
    AND?: ProductLogWhereInput | ProductLogWhereInput[]
    OR?: ProductLogWhereInput[]
    NOT?: ProductLogWhereInput | ProductLogWhereInput[]
    id?: StringFilter<"ProductLog"> | string
    productId?: StringFilter<"ProductLog"> | string
    userId?: StringFilter<"ProductLog"> | string
    orderId?: StringFilter<"ProductLog"> | string
    action?: StringFilter<"ProductLog"> | string
    quantity?: IntFilter<"ProductLog"> | number
    lineIndices?: StringNullableFilter<"ProductLog"> | string | null
    content?: StringNullableFilter<"ProductLog"> | string | null
    notes?: StringNullableFilter<"ProductLog"> | string | null
    createdAt?: DateTimeFilter<"ProductLog"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    productLines?: ProductLineItemListRelationFilter
  }

  export type ProductLogOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    lineIndices?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    productLines?: ProductLineItemOrderByRelationAggregateInput
    _relevance?: ProductLogOrderByRelevanceInput
  }

  export type ProductLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductLogWhereInput | ProductLogWhereInput[]
    OR?: ProductLogWhereInput[]
    NOT?: ProductLogWhereInput | ProductLogWhereInput[]
    productId?: StringFilter<"ProductLog"> | string
    userId?: StringFilter<"ProductLog"> | string
    orderId?: StringFilter<"ProductLog"> | string
    action?: StringFilter<"ProductLog"> | string
    quantity?: IntFilter<"ProductLog"> | number
    lineIndices?: StringNullableFilter<"ProductLog"> | string | null
    content?: StringNullableFilter<"ProductLog"> | string | null
    notes?: StringNullableFilter<"ProductLog"> | string | null
    createdAt?: DateTimeFilter<"ProductLog"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    productLines?: ProductLineItemListRelationFilter
  }, "id">

  export type ProductLogOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    lineIndices?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductLogCountOrderByAggregateInput
    _avg?: ProductLogAvgOrderByAggregateInput
    _max?: ProductLogMaxOrderByAggregateInput
    _min?: ProductLogMinOrderByAggregateInput
    _sum?: ProductLogSumOrderByAggregateInput
  }

  export type ProductLogScalarWhereWithAggregatesInput = {
    AND?: ProductLogScalarWhereWithAggregatesInput | ProductLogScalarWhereWithAggregatesInput[]
    OR?: ProductLogScalarWhereWithAggregatesInput[]
    NOT?: ProductLogScalarWhereWithAggregatesInput | ProductLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductLog"> | string
    productId?: StringWithAggregatesFilter<"ProductLog"> | string
    userId?: StringWithAggregatesFilter<"ProductLog"> | string
    orderId?: StringWithAggregatesFilter<"ProductLog"> | string
    action?: StringWithAggregatesFilter<"ProductLog"> | string
    quantity?: IntWithAggregatesFilter<"ProductLog"> | number
    lineIndices?: StringNullableWithAggregatesFilter<"ProductLog"> | string | null
    content?: StringNullableWithAggregatesFilter<"ProductLog"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ProductLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductLog"> | Date | string
  }

  export type ProductLineItemWhereInput = {
    AND?: ProductLineItemWhereInput | ProductLineItemWhereInput[]
    OR?: ProductLineItemWhereInput[]
    NOT?: ProductLineItemWhereInput | ProductLineItemWhereInput[]
    id?: StringFilter<"ProductLineItem"> | string
    productLogId?: StringFilter<"ProductLineItem"> | string
    orderId?: StringFilter<"ProductLineItem"> | string
    productName?: StringFilter<"ProductLineItem"> | string
    content?: StringFilter<"ProductLineItem"> | string
    priceVnd?: FloatFilter<"ProductLineItem"> | number
    status?: EnumProductLineStatusFilter<"ProductLineItem"> | $Enums.ProductLineStatus
    errorReported?: BoolFilter<"ProductLineItem"> | boolean
    replacement?: StringNullableFilter<"ProductLineItem"> | string | null
    adminNote?: StringNullableFilter<"ProductLineItem"> | string | null
    rejectedAt?: DateTimeNullableFilter<"ProductLineItem"> | Date | string | null
    replacedAt?: DateTimeNullableFilter<"ProductLineItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductLineItem"> | Date | string
    productLog?: XOR<ProductLogScalarRelationFilter, ProductLogWhereInput>
  }

  export type ProductLineItemOrderByWithRelationInput = {
    id?: SortOrder
    productLogId?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    content?: SortOrder
    priceVnd?: SortOrder
    status?: SortOrder
    errorReported?: SortOrder
    replacement?: SortOrderInput | SortOrder
    adminNote?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    replacedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productLog?: ProductLogOrderByWithRelationInput
    _relevance?: ProductLineItemOrderByRelevanceInput
  }

  export type ProductLineItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductLineItemWhereInput | ProductLineItemWhereInput[]
    OR?: ProductLineItemWhereInput[]
    NOT?: ProductLineItemWhereInput | ProductLineItemWhereInput[]
    productLogId?: StringFilter<"ProductLineItem"> | string
    orderId?: StringFilter<"ProductLineItem"> | string
    productName?: StringFilter<"ProductLineItem"> | string
    content?: StringFilter<"ProductLineItem"> | string
    priceVnd?: FloatFilter<"ProductLineItem"> | number
    status?: EnumProductLineStatusFilter<"ProductLineItem"> | $Enums.ProductLineStatus
    errorReported?: BoolFilter<"ProductLineItem"> | boolean
    replacement?: StringNullableFilter<"ProductLineItem"> | string | null
    adminNote?: StringNullableFilter<"ProductLineItem"> | string | null
    rejectedAt?: DateTimeNullableFilter<"ProductLineItem"> | Date | string | null
    replacedAt?: DateTimeNullableFilter<"ProductLineItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductLineItem"> | Date | string
    productLog?: XOR<ProductLogScalarRelationFilter, ProductLogWhereInput>
  }, "id">

  export type ProductLineItemOrderByWithAggregationInput = {
    id?: SortOrder
    productLogId?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    content?: SortOrder
    priceVnd?: SortOrder
    status?: SortOrder
    errorReported?: SortOrder
    replacement?: SortOrderInput | SortOrder
    adminNote?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    replacedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductLineItemCountOrderByAggregateInput
    _avg?: ProductLineItemAvgOrderByAggregateInput
    _max?: ProductLineItemMaxOrderByAggregateInput
    _min?: ProductLineItemMinOrderByAggregateInput
    _sum?: ProductLineItemSumOrderByAggregateInput
  }

  export type ProductLineItemScalarWhereWithAggregatesInput = {
    AND?: ProductLineItemScalarWhereWithAggregatesInput | ProductLineItemScalarWhereWithAggregatesInput[]
    OR?: ProductLineItemScalarWhereWithAggregatesInput[]
    NOT?: ProductLineItemScalarWhereWithAggregatesInput | ProductLineItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductLineItem"> | string
    productLogId?: StringWithAggregatesFilter<"ProductLineItem"> | string
    orderId?: StringWithAggregatesFilter<"ProductLineItem"> | string
    productName?: StringWithAggregatesFilter<"ProductLineItem"> | string
    content?: StringWithAggregatesFilter<"ProductLineItem"> | string
    priceVnd?: FloatWithAggregatesFilter<"ProductLineItem"> | number
    status?: EnumProductLineStatusWithAggregatesFilter<"ProductLineItem"> | $Enums.ProductLineStatus
    errorReported?: BoolWithAggregatesFilter<"ProductLineItem"> | boolean
    replacement?: StringNullableWithAggregatesFilter<"ProductLineItem"> | string | null
    adminNote?: StringNullableWithAggregatesFilter<"ProductLineItem"> | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"ProductLineItem"> | Date | string | null
    replacedAt?: DateTimeNullableWithAggregatesFilter<"ProductLineItem"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductLineItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductLineItem"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    productId?: StringFilter<"File"> | string
    s3Key?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    checksum?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    downloadLogs?: DownloadLogListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    s3Key?: SortOrder
    size?: SortOrder
    checksum?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    downloadLogs?: DownloadLogOrderByRelationAggregateInput
    _relevance?: FileOrderByRelevanceInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    productId?: StringFilter<"File"> | string
    s3Key?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    checksum?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    downloadLogs?: DownloadLogListRelationFilter
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    s3Key?: SortOrder
    size?: SortOrder
    checksum?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    productId?: StringWithAggregatesFilter<"File"> | string
    s3Key?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    checksum?: StringNullableWithAggregatesFilter<"File"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    id?: StringFilter<"License"> | string
    productId?: StringFilter<"License"> | string
    codeOrJwt?: StringFilter<"License"> | string
    status?: EnumLicenseStatusFilter<"License"> | $Enums.LicenseStatus
    boundEmail?: StringNullableFilter<"License"> | string | null
    issuedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type LicenseOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    codeOrJwt?: SortOrder
    status?: SortOrder
    boundEmail?: SortOrderInput | SortOrder
    issuedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    _relevance?: LicenseOrderByRelevanceInput
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codeOrJwt?: string
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    productId?: StringFilter<"License"> | string
    status?: EnumLicenseStatusFilter<"License"> | $Enums.LicenseStatus
    boundEmail?: StringNullableFilter<"License"> | string | null
    issuedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "codeOrJwt">

  export type LicenseOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    codeOrJwt?: SortOrder
    status?: SortOrder
    boundEmail?: SortOrderInput | SortOrder
    issuedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"License"> | string
    productId?: StringWithAggregatesFilter<"License"> | string
    codeOrJwt?: StringWithAggregatesFilter<"License"> | string
    status?: EnumLicenseStatusWithAggregatesFilter<"License"> | $Enums.LicenseStatus
    boundEmail?: StringNullableWithAggregatesFilter<"License"> | string | null
    issuedAt?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmountVnd?: FloatFilter<"Order"> | number
    discountVnd?: FloatFilter<"Order"> | number
    couponCode?: StringNullableFilter<"Order"> | string | null
    currency?: StringFilter<"Order"> | string
    itemsJson?: StringFilter<"Order"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
    orderItems?: OrderItemListRelationFilter
    downloadLogs?: DownloadLogListRelationFilter
    productLogs?: ProductLogListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
    couponCode?: SortOrderInput | SortOrder
    currency?: SortOrder
    itemsJson?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    downloadLogs?: DownloadLogOrderByRelationAggregateInput
    productLogs?: ProductLogOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmountVnd?: FloatFilter<"Order"> | number
    discountVnd?: FloatFilter<"Order"> | number
    couponCode?: StringNullableFilter<"Order"> | string | null
    currency?: StringFilter<"Order"> | string
    itemsJson?: StringFilter<"Order"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
    orderItems?: OrderItemListRelationFilter
    downloadLogs?: DownloadLogListRelationFilter
    productLogs?: ProductLogListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
    couponCode?: SortOrderInput | SortOrder
    currency?: SortOrder
    itemsJson?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    totalAmountVnd?: FloatWithAggregatesFilter<"Order"> | number
    discountVnd?: FloatWithAggregatesFilter<"Order"> | number
    couponCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    currency?: StringWithAggregatesFilter<"Order"> | string
    itemsJson?: StringWithAggregatesFilter<"Order"> | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Order"> | $Enums.PaymentMethod
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    priceVnd?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceVnd?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    _relevance?: OrderItemOrderByRelevanceInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    priceVnd?: FloatFilter<"OrderItem"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceVnd?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    priceVnd?: FloatWithAggregatesFilter<"OrderItem"> | number
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    provider?: EnumPaymentProviderFilter<"Payment"> | $Enums.PaymentProvider
    providerTxid?: StringNullableFilter<"Payment"> | string | null
    amountVnd?: FloatFilter<"Payment"> | number
    rawJson?: StringNullableFilter<"Payment"> | string | null
    matchedBy?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    providerTxid?: SortOrderInput | SortOrder
    amountVnd?: SortOrder
    rawJson?: SortOrderInput | SortOrder
    matchedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orderId?: StringFilter<"Payment"> | string
    provider?: EnumPaymentProviderFilter<"Payment"> | $Enums.PaymentProvider
    providerTxid?: StringNullableFilter<"Payment"> | string | null
    amountVnd?: FloatFilter<"Payment"> | number
    rawJson?: StringNullableFilter<"Payment"> | string | null
    matchedBy?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    providerTxid?: SortOrderInput | SortOrder
    amountVnd?: SortOrder
    rawJson?: SortOrderInput | SortOrder
    matchedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"Payment"> | $Enums.PaymentProvider
    providerTxid?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amountVnd?: FloatWithAggregatesFilter<"Payment"> | number
    rawJson?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    matchedBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ManualDepositRequestWhereInput = {
    AND?: ManualDepositRequestWhereInput | ManualDepositRequestWhereInput[]
    OR?: ManualDepositRequestWhereInput[]
    NOT?: ManualDepositRequestWhereInput | ManualDepositRequestWhereInput[]
    id?: IntFilter<"ManualDepositRequest"> | number
    internalId?: StringNullableFilter<"ManualDepositRequest"> | string | null
    userId?: StringFilter<"ManualDepositRequest"> | string
    amountVnd?: FloatFilter<"ManualDepositRequest"> | number
    note?: StringNullableFilter<"ManualDepositRequest"> | string | null
    qrCode?: StringNullableFilter<"ManualDepositRequest"> | string | null
    transferContent?: StringNullableFilter<"ManualDepositRequest"> | string | null
    status?: EnumDepositStatusFilter<"ManualDepositRequest"> | $Enums.DepositStatus
    adminNote?: StringNullableFilter<"ManualDepositRequest"> | string | null
    decidedAt?: DateTimeNullableFilter<"ManualDepositRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ManualDepositRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ManualDepositRequestOrderByWithRelationInput = {
    id?: SortOrder
    internalId?: SortOrderInput | SortOrder
    userId?: SortOrder
    amountVnd?: SortOrder
    note?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    transferContent?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    decidedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: ManualDepositRequestOrderByRelevanceInput
  }

  export type ManualDepositRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    internalId?: string
    AND?: ManualDepositRequestWhereInput | ManualDepositRequestWhereInput[]
    OR?: ManualDepositRequestWhereInput[]
    NOT?: ManualDepositRequestWhereInput | ManualDepositRequestWhereInput[]
    userId?: StringFilter<"ManualDepositRequest"> | string
    amountVnd?: FloatFilter<"ManualDepositRequest"> | number
    note?: StringNullableFilter<"ManualDepositRequest"> | string | null
    qrCode?: StringNullableFilter<"ManualDepositRequest"> | string | null
    transferContent?: StringNullableFilter<"ManualDepositRequest"> | string | null
    status?: EnumDepositStatusFilter<"ManualDepositRequest"> | $Enums.DepositStatus
    adminNote?: StringNullableFilter<"ManualDepositRequest"> | string | null
    decidedAt?: DateTimeNullableFilter<"ManualDepositRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ManualDepositRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "internalId">

  export type ManualDepositRequestOrderByWithAggregationInput = {
    id?: SortOrder
    internalId?: SortOrderInput | SortOrder
    userId?: SortOrder
    amountVnd?: SortOrder
    note?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    transferContent?: SortOrderInput | SortOrder
    status?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    decidedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ManualDepositRequestCountOrderByAggregateInput
    _avg?: ManualDepositRequestAvgOrderByAggregateInput
    _max?: ManualDepositRequestMaxOrderByAggregateInput
    _min?: ManualDepositRequestMinOrderByAggregateInput
    _sum?: ManualDepositRequestSumOrderByAggregateInput
  }

  export type ManualDepositRequestScalarWhereWithAggregatesInput = {
    AND?: ManualDepositRequestScalarWhereWithAggregatesInput | ManualDepositRequestScalarWhereWithAggregatesInput[]
    OR?: ManualDepositRequestScalarWhereWithAggregatesInput[]
    NOT?: ManualDepositRequestScalarWhereWithAggregatesInput | ManualDepositRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ManualDepositRequest"> | number
    internalId?: StringNullableWithAggregatesFilter<"ManualDepositRequest"> | string | null
    userId?: StringWithAggregatesFilter<"ManualDepositRequest"> | string
    amountVnd?: FloatWithAggregatesFilter<"ManualDepositRequest"> | number
    note?: StringNullableWithAggregatesFilter<"ManualDepositRequest"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"ManualDepositRequest"> | string | null
    transferContent?: StringNullableWithAggregatesFilter<"ManualDepositRequest"> | string | null
    status?: EnumDepositStatusWithAggregatesFilter<"ManualDepositRequest"> | $Enums.DepositStatus
    adminNote?: StringNullableWithAggregatesFilter<"ManualDepositRequest"> | string | null
    decidedAt?: DateTimeNullableWithAggregatesFilter<"ManualDepositRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ManualDepositRequest"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    description?: StringNullableFilter<"Coupon"> | string | null
    discountType?: EnumDiscountTypeFilter<"Coupon"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Coupon"> | number
    maxDiscountVnd?: FloatNullableFilter<"Coupon"> | number | null
    minOrderVnd?: FloatFilter<"Coupon"> | number
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    usedCount?: IntFilter<"Coupon"> | number
    startDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    active?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrderInput | SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    startDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CouponOrderByRelevanceInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    description?: StringNullableFilter<"Coupon"> | string | null
    discountType?: EnumDiscountTypeFilter<"Coupon"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Coupon"> | number
    maxDiscountVnd?: FloatNullableFilter<"Coupon"> | number | null
    minOrderVnd?: FloatFilter<"Coupon"> | number
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    usedCount?: IntFilter<"Coupon"> | number
    startDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    active?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrderInput | SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    startDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    description?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Coupon"> | $Enums.DiscountType
    discountValue?: FloatWithAggregatesFilter<"Coupon"> | number
    maxDiscountVnd?: FloatNullableWithAggregatesFilter<"Coupon"> | number | null
    minOrderVnd?: FloatWithAggregatesFilter<"Coupon"> | number
    maxUses?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    usedCount?: IntWithAggregatesFilter<"Coupon"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Coupon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    websiteName?: StringFilter<"Settings"> | string
    websiteTitle?: StringFilter<"Settings"> | string
    websiteDescription?: StringFilter<"Settings"> | string
    websiteKeywords?: StringFilter<"Settings"> | string
    websiteLogo?: StringNullableFilter<"Settings"> | string | null
    websiteFavicon?: StringNullableFilter<"Settings"> | string | null
    copyrightYear?: StringFilter<"Settings"> | string
    supportEmail?: StringFilter<"Settings"> | string
    contactInfo?: StringFilter<"Settings"> | string
    paymentMethods?: StringFilter<"Settings"> | string
    bankInfo?: StringFilter<"Settings"> | string
    topupRules?: StringFilter<"Settings"> | string
    tpbankConfig?: StringFilter<"Settings"> | string
    depositBonusTiers?: StringFilter<"Settings"> | string
    referralSettings?: StringFilter<"Settings"> | string
    uiTexts?: StringFilter<"Settings"> | string
    themeSettings?: StringFilter<"Settings"> | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    websiteName?: SortOrder
    websiteTitle?: SortOrder
    websiteDescription?: SortOrder
    websiteKeywords?: SortOrder
    websiteLogo?: SortOrderInput | SortOrder
    websiteFavicon?: SortOrderInput | SortOrder
    copyrightYear?: SortOrder
    supportEmail?: SortOrder
    contactInfo?: SortOrder
    paymentMethods?: SortOrder
    bankInfo?: SortOrder
    topupRules?: SortOrder
    tpbankConfig?: SortOrder
    depositBonusTiers?: SortOrder
    referralSettings?: SortOrder
    uiTexts?: SortOrder
    themeSettings?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SettingsOrderByRelevanceInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    websiteName?: StringFilter<"Settings"> | string
    websiteTitle?: StringFilter<"Settings"> | string
    websiteDescription?: StringFilter<"Settings"> | string
    websiteKeywords?: StringFilter<"Settings"> | string
    websiteLogo?: StringNullableFilter<"Settings"> | string | null
    websiteFavicon?: StringNullableFilter<"Settings"> | string | null
    copyrightYear?: StringFilter<"Settings"> | string
    supportEmail?: StringFilter<"Settings"> | string
    contactInfo?: StringFilter<"Settings"> | string
    paymentMethods?: StringFilter<"Settings"> | string
    bankInfo?: StringFilter<"Settings"> | string
    topupRules?: StringFilter<"Settings"> | string
    tpbankConfig?: StringFilter<"Settings"> | string
    depositBonusTiers?: StringFilter<"Settings"> | string
    referralSettings?: StringFilter<"Settings"> | string
    uiTexts?: StringFilter<"Settings"> | string
    themeSettings?: StringFilter<"Settings"> | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    websiteName?: SortOrder
    websiteTitle?: SortOrder
    websiteDescription?: SortOrder
    websiteKeywords?: SortOrder
    websiteLogo?: SortOrderInput | SortOrder
    websiteFavicon?: SortOrderInput | SortOrder
    copyrightYear?: SortOrder
    supportEmail?: SortOrder
    contactInfo?: SortOrder
    paymentMethods?: SortOrder
    bankInfo?: SortOrder
    topupRules?: SortOrder
    tpbankConfig?: SortOrder
    depositBonusTiers?: SortOrder
    referralSettings?: SortOrder
    uiTexts?: SortOrder
    themeSettings?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    websiteName?: StringWithAggregatesFilter<"Settings"> | string
    websiteTitle?: StringWithAggregatesFilter<"Settings"> | string
    websiteDescription?: StringWithAggregatesFilter<"Settings"> | string
    websiteKeywords?: StringWithAggregatesFilter<"Settings"> | string
    websiteLogo?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    websiteFavicon?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    copyrightYear?: StringWithAggregatesFilter<"Settings"> | string
    supportEmail?: StringWithAggregatesFilter<"Settings"> | string
    contactInfo?: StringWithAggregatesFilter<"Settings"> | string
    paymentMethods?: StringWithAggregatesFilter<"Settings"> | string
    bankInfo?: StringWithAggregatesFilter<"Settings"> | string
    topupRules?: StringWithAggregatesFilter<"Settings"> | string
    tpbankConfig?: StringWithAggregatesFilter<"Settings"> | string
    depositBonusTiers?: StringWithAggregatesFilter<"Settings"> | string
    referralSettings?: StringWithAggregatesFilter<"Settings"> | string
    uiTexts?: StringWithAggregatesFilter<"Settings"> | string
    themeSettings?: StringWithAggregatesFilter<"Settings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type DownloadLogWhereInput = {
    AND?: DownloadLogWhereInput | DownloadLogWhereInput[]
    OR?: DownloadLogWhereInput[]
    NOT?: DownloadLogWhereInput | DownloadLogWhereInput[]
    id?: StringFilter<"DownloadLog"> | string
    orderId?: StringFilter<"DownloadLog"> | string
    fileId?: StringNullableFilter<"DownloadLog"> | string | null
    ip?: StringNullableFilter<"DownloadLog"> | string | null
    userAgent?: StringNullableFilter<"DownloadLog"> | string | null
    createdAt?: DateTimeFilter<"DownloadLog"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
  }

  export type DownloadLogOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fileId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    file?: FileOrderByWithRelationInput
    _relevance?: DownloadLogOrderByRelevanceInput
  }

  export type DownloadLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DownloadLogWhereInput | DownloadLogWhereInput[]
    OR?: DownloadLogWhereInput[]
    NOT?: DownloadLogWhereInput | DownloadLogWhereInput[]
    orderId?: StringFilter<"DownloadLog"> | string
    fileId?: StringNullableFilter<"DownloadLog"> | string | null
    ip?: StringNullableFilter<"DownloadLog"> | string | null
    userAgent?: StringNullableFilter<"DownloadLog"> | string | null
    createdAt?: DateTimeFilter<"DownloadLog"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
  }, "id">

  export type DownloadLogOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    fileId?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DownloadLogCountOrderByAggregateInput
    _max?: DownloadLogMaxOrderByAggregateInput
    _min?: DownloadLogMinOrderByAggregateInput
  }

  export type DownloadLogScalarWhereWithAggregatesInput = {
    AND?: DownloadLogScalarWhereWithAggregatesInput | DownloadLogScalarWhereWithAggregatesInput[]
    OR?: DownloadLogScalarWhereWithAggregatesInput[]
    NOT?: DownloadLogScalarWhereWithAggregatesInput | DownloadLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DownloadLog"> | string
    orderId?: StringWithAggregatesFilter<"DownloadLog"> | string
    fileId?: StringNullableWithAggregatesFilter<"DownloadLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"DownloadLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"DownloadLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DownloadLog"> | Date | string
  }

  export type AdminActionLogWhereInput = {
    AND?: AdminActionLogWhereInput | AdminActionLogWhereInput[]
    OR?: AdminActionLogWhereInput[]
    NOT?: AdminActionLogWhereInput | AdminActionLogWhereInput[]
    id?: StringFilter<"AdminActionLog"> | string
    adminId?: StringFilter<"AdminActionLog"> | string
    action?: StringFilter<"AdminActionLog"> | string
    targetType?: StringNullableFilter<"AdminActionLog"> | string | null
    targetId?: StringNullableFilter<"AdminActionLog"> | string | null
    diffJson?: StringNullableFilter<"AdminActionLog"> | string | null
    createdAt?: DateTimeFilter<"AdminActionLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminActionLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    diffJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
    _relevance?: AdminActionLogOrderByRelevanceInput
  }

  export type AdminActionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminActionLogWhereInput | AdminActionLogWhereInput[]
    OR?: AdminActionLogWhereInput[]
    NOT?: AdminActionLogWhereInput | AdminActionLogWhereInput[]
    adminId?: StringFilter<"AdminActionLog"> | string
    action?: StringFilter<"AdminActionLog"> | string
    targetType?: StringNullableFilter<"AdminActionLog"> | string | null
    targetId?: StringNullableFilter<"AdminActionLog"> | string | null
    diffJson?: StringNullableFilter<"AdminActionLog"> | string | null
    createdAt?: DateTimeFilter<"AdminActionLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminActionLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    diffJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminActionLogCountOrderByAggregateInput
    _max?: AdminActionLogMaxOrderByAggregateInput
    _min?: AdminActionLogMinOrderByAggregateInput
  }

  export type AdminActionLogScalarWhereWithAggregatesInput = {
    AND?: AdminActionLogScalarWhereWithAggregatesInput | AdminActionLogScalarWhereWithAggregatesInput[]
    OR?: AdminActionLogScalarWhereWithAggregatesInput[]
    NOT?: AdminActionLogScalarWhereWithAggregatesInput | AdminActionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminActionLog"> | string
    adminId?: StringWithAggregatesFilter<"AdminActionLog"> | string
    action?: StringWithAggregatesFilter<"AdminActionLog"> | string
    targetType?: StringNullableWithAggregatesFilter<"AdminActionLog"> | string | null
    targetId?: StringNullableWithAggregatesFilter<"AdminActionLog"> | string | null
    diffJson?: StringNullableWithAggregatesFilter<"AdminActionLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminActionLog"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    userId?: StringFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amountVnd?: FloatFilter<"WalletTransaction"> | number
    balanceAfterVnd?: FloatFilter<"WalletTransaction"> | number
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    metadata?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: WalletTransactionOrderByRelevanceInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    userId?: StringFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amountVnd?: FloatFilter<"WalletTransaction"> | number
    balanceAfterVnd?: FloatFilter<"WalletTransaction"> | number
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    metadata?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }, "id">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    userId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeWithAggregatesFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amountVnd?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    balanceAfterVnd?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    description?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type WebsiteSettingsWhereInput = {
    AND?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    OR?: WebsiteSettingsWhereInput[]
    NOT?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    key?: StringFilter<"WebsiteSettings"> | string
    value?: StringFilter<"WebsiteSettings"> | string
    updatedAt?: DateTimeFilter<"WebsiteSettings"> | Date | string
  }

  export type WebsiteSettingsOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _relevance?: WebsiteSettingsOrderByRelevanceInput
  }

  export type WebsiteSettingsWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    OR?: WebsiteSettingsWhereInput[]
    NOT?: WebsiteSettingsWhereInput | WebsiteSettingsWhereInput[]
    value?: StringFilter<"WebsiteSettings"> | string
    updatedAt?: DateTimeFilter<"WebsiteSettings"> | Date | string
  }, "key">

  export type WebsiteSettingsOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsiteSettingsCountOrderByAggregateInput
    _max?: WebsiteSettingsMaxOrderByAggregateInput
    _min?: WebsiteSettingsMinOrderByAggregateInput
  }

  export type WebsiteSettingsScalarWhereWithAggregatesInput = {
    AND?: WebsiteSettingsScalarWhereWithAggregatesInput | WebsiteSettingsScalarWhereWithAggregatesInput[]
    OR?: WebsiteSettingsScalarWhereWithAggregatesInput[]
    NOT?: WebsiteSettingsScalarWhereWithAggregatesInput | WebsiteSettingsScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    value?: StringWithAggregatesFilter<"WebsiteSettings"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebsiteSettings"> | Date | string
  }

  export type AutoTopupLogWhereInput = {
    AND?: AutoTopupLogWhereInput | AutoTopupLogWhereInput[]
    OR?: AutoTopupLogWhereInput[]
    NOT?: AutoTopupLogWhereInput | AutoTopupLogWhereInput[]
    id?: StringFilter<"AutoTopupLog"> | string
    bankTransactionId?: StringFilter<"AutoTopupLog"> | string
    bankName?: StringFilter<"AutoTopupLog"> | string
    depositRequestId?: IntNullableFilter<"AutoTopupLog"> | number | null
    userId?: StringNullableFilter<"AutoTopupLog"> | string | null
    topupCode?: StringFilter<"AutoTopupLog"> | string
    amountVnd?: FloatFilter<"AutoTopupLog"> | number
    description?: StringFilter<"AutoTopupLog"> | string
    status?: EnumAutoTopupStatusFilter<"AutoTopupLog"> | $Enums.AutoTopupStatus
    errorMessage?: StringNullableFilter<"AutoTopupLog"> | string | null
    transactionDate?: DateTimeFilter<"AutoTopupLog"> | Date | string
    createdAt?: DateTimeFilter<"AutoTopupLog"> | Date | string
  }

  export type AutoTopupLogOrderByWithRelationInput = {
    id?: SortOrder
    bankTransactionId?: SortOrder
    bankName?: SortOrder
    depositRequestId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    topupCode?: SortOrder
    amountVnd?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    _relevance?: AutoTopupLogOrderByRelevanceInput
  }

  export type AutoTopupLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bankTransactionId?: string
    AND?: AutoTopupLogWhereInput | AutoTopupLogWhereInput[]
    OR?: AutoTopupLogWhereInput[]
    NOT?: AutoTopupLogWhereInput | AutoTopupLogWhereInput[]
    bankName?: StringFilter<"AutoTopupLog"> | string
    depositRequestId?: IntNullableFilter<"AutoTopupLog"> | number | null
    userId?: StringNullableFilter<"AutoTopupLog"> | string | null
    topupCode?: StringFilter<"AutoTopupLog"> | string
    amountVnd?: FloatFilter<"AutoTopupLog"> | number
    description?: StringFilter<"AutoTopupLog"> | string
    status?: EnumAutoTopupStatusFilter<"AutoTopupLog"> | $Enums.AutoTopupStatus
    errorMessage?: StringNullableFilter<"AutoTopupLog"> | string | null
    transactionDate?: DateTimeFilter<"AutoTopupLog"> | Date | string
    createdAt?: DateTimeFilter<"AutoTopupLog"> | Date | string
  }, "id" | "bankTransactionId">

  export type AutoTopupLogOrderByWithAggregationInput = {
    id?: SortOrder
    bankTransactionId?: SortOrder
    bankName?: SortOrder
    depositRequestId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    topupCode?: SortOrder
    amountVnd?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
    _count?: AutoTopupLogCountOrderByAggregateInput
    _avg?: AutoTopupLogAvgOrderByAggregateInput
    _max?: AutoTopupLogMaxOrderByAggregateInput
    _min?: AutoTopupLogMinOrderByAggregateInput
    _sum?: AutoTopupLogSumOrderByAggregateInput
  }

  export type AutoTopupLogScalarWhereWithAggregatesInput = {
    AND?: AutoTopupLogScalarWhereWithAggregatesInput | AutoTopupLogScalarWhereWithAggregatesInput[]
    OR?: AutoTopupLogScalarWhereWithAggregatesInput[]
    NOT?: AutoTopupLogScalarWhereWithAggregatesInput | AutoTopupLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutoTopupLog"> | string
    bankTransactionId?: StringWithAggregatesFilter<"AutoTopupLog"> | string
    bankName?: StringWithAggregatesFilter<"AutoTopupLog"> | string
    depositRequestId?: IntNullableWithAggregatesFilter<"AutoTopupLog"> | number | null
    userId?: StringNullableWithAggregatesFilter<"AutoTopupLog"> | string | null
    topupCode?: StringWithAggregatesFilter<"AutoTopupLog"> | string
    amountVnd?: FloatWithAggregatesFilter<"AutoTopupLog"> | number
    description?: StringWithAggregatesFilter<"AutoTopupLog"> | string
    status?: EnumAutoTopupStatusWithAggregatesFilter<"AutoTopupLog"> | $Enums.AutoTopupStatus
    errorMessage?: StringNullableWithAggregatesFilter<"AutoTopupLog"> | string | null
    transactionDate?: DateTimeWithAggregatesFilter<"AutoTopupLog"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AutoTopupLog"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringFilter<"Referral"> | string
    referralCode?: StringFilter<"Referral"> | string
    referrerRewardVnd?: FloatFilter<"Referral"> | number
    refereeRewardVnd?: FloatFilter<"Referral"> | number
    rewardPaid?: BoolFilter<"Referral"> | boolean
    rewardPaidAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    firstDepositVnd?: FloatNullableFilter<"Referral"> | number | null
    firstDepositAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    rewardPaid?: SortOrder
    rewardPaidAt?: SortOrderInput | SortOrder
    firstDepositVnd?: SortOrderInput | SortOrder
    firstDepositAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referee?: UserOrderByWithRelationInput
    _relevance?: ReferralOrderByRelevanceInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refereeId?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    referralCode?: StringFilter<"Referral"> | string
    referrerRewardVnd?: FloatFilter<"Referral"> | number
    refereeRewardVnd?: FloatFilter<"Referral"> | number
    rewardPaid?: BoolFilter<"Referral"> | boolean
    rewardPaidAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    firstDepositVnd?: FloatNullableFilter<"Referral"> | number | null
    firstDepositAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "refereeId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    rewardPaid?: SortOrder
    rewardPaidAt?: SortOrderInput | SortOrder
    firstDepositVnd?: SortOrderInput | SortOrder
    firstDepositAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    refereeId?: StringWithAggregatesFilter<"Referral"> | string
    referralCode?: StringWithAggregatesFilter<"Referral"> | string
    referrerRewardVnd?: FloatWithAggregatesFilter<"Referral"> | number
    refereeRewardVnd?: FloatWithAggregatesFilter<"Referral"> | number
    rewardPaid?: BoolWithAggregatesFilter<"Referral"> | boolean
    rewardPaidAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    firstDepositVnd?: FloatNullableWithAggregatesFilter<"Referral"> | number | null
    firstDepositAt?: DateTimeNullableWithAggregatesFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type UserActivityLogWhereInput = {
    AND?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    OR?: UserActivityLogWhereInput[]
    NOT?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    id?: StringFilter<"UserActivityLog"> | string
    userId?: StringFilter<"UserActivityLog"> | string
    action?: StringFilter<"UserActivityLog"> | string
    targetType?: StringNullableFilter<"UserActivityLog"> | string | null
    targetId?: StringNullableFilter<"UserActivityLog"> | string | null
    metadata?: StringNullableFilter<"UserActivityLog"> | string | null
    ip?: StringNullableFilter<"UserActivityLog"> | string | null
    userAgent?: StringNullableFilter<"UserActivityLog"> | string | null
    createdAt?: DateTimeFilter<"UserActivityLog"> | Date | string
  }

  export type UserActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetType?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: UserActivityLogOrderByRelevanceInput
  }

  export type UserActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    OR?: UserActivityLogWhereInput[]
    NOT?: UserActivityLogWhereInput | UserActivityLogWhereInput[]
    userId?: StringFilter<"UserActivityLog"> | string
    action?: StringFilter<"UserActivityLog"> | string
    targetType?: StringNullableFilter<"UserActivityLog"> | string | null
    targetId?: StringNullableFilter<"UserActivityLog"> | string | null
    metadata?: StringNullableFilter<"UserActivityLog"> | string | null
    ip?: StringNullableFilter<"UserActivityLog"> | string | null
    userAgent?: StringNullableFilter<"UserActivityLog"> | string | null
    createdAt?: DateTimeFilter<"UserActivityLog"> | Date | string
  }, "id">

  export type UserActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetType?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserActivityLogCountOrderByAggregateInput
    _max?: UserActivityLogMaxOrderByAggregateInput
    _min?: UserActivityLogMinOrderByAggregateInput
  }

  export type UserActivityLogScalarWhereWithAggregatesInput = {
    AND?: UserActivityLogScalarWhereWithAggregatesInput | UserActivityLogScalarWhereWithAggregatesInput[]
    OR?: UserActivityLogScalarWhereWithAggregatesInput[]
    NOT?: UserActivityLogScalarWhereWithAggregatesInput | UserActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserActivityLog"> | string
    userId?: StringWithAggregatesFilter<"UserActivityLog"> | string
    action?: StringWithAggregatesFilter<"UserActivityLog"> | string
    targetType?: StringNullableWithAggregatesFilter<"UserActivityLog"> | string | null
    targetId?: StringNullableWithAggregatesFilter<"UserActivityLog"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"UserActivityLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"UserActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserActivityLog"> | Date | string
  }

  export type TwoFactorAccountWhereInput = {
    AND?: TwoFactorAccountWhereInput | TwoFactorAccountWhereInput[]
    OR?: TwoFactorAccountWhereInput[]
    NOT?: TwoFactorAccountWhereInput | TwoFactorAccountWhereInput[]
    id?: StringFilter<"TwoFactorAccount"> | string
    userId?: StringFilter<"TwoFactorAccount"> | string
    name?: StringFilter<"TwoFactorAccount"> | string
    issuer?: StringFilter<"TwoFactorAccount"> | string
    secret?: StringFilter<"TwoFactorAccount"> | string
    createdAt?: DateTimeFilter<"TwoFactorAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TwoFactorAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: TwoFactorAccountOrderByRelevanceInput
  }

  export type TwoFactorAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TwoFactorAccountWhereInput | TwoFactorAccountWhereInput[]
    OR?: TwoFactorAccountWhereInput[]
    NOT?: TwoFactorAccountWhereInput | TwoFactorAccountWhereInput[]
    userId?: StringFilter<"TwoFactorAccount"> | string
    name?: StringFilter<"TwoFactorAccount"> | string
    issuer?: StringFilter<"TwoFactorAccount"> | string
    secret?: StringFilter<"TwoFactorAccount"> | string
    createdAt?: DateTimeFilter<"TwoFactorAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TwoFactorAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwoFactorAccountCountOrderByAggregateInput
    _max?: TwoFactorAccountMaxOrderByAggregateInput
    _min?: TwoFactorAccountMinOrderByAggregateInput
  }

  export type TwoFactorAccountScalarWhereWithAggregatesInput = {
    AND?: TwoFactorAccountScalarWhereWithAggregatesInput | TwoFactorAccountScalarWhereWithAggregatesInput[]
    OR?: TwoFactorAccountScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorAccountScalarWhereWithAggregatesInput | TwoFactorAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactorAccount"> | string
    userId?: StringWithAggregatesFilter<"TwoFactorAccount"> | string
    name?: StringWithAggregatesFilter<"TwoFactorAccount"> | string
    issuer?: StringWithAggregatesFilter<"TwoFactorAccount"> | string
    secret?: StringWithAggregatesFilter<"TwoFactorAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactorAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TwoFactorAccount"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    used?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: PasswordResetTokenOrderByRelevanceInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    used?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    used?: BoolWithAggregatesFilter<"PasswordResetToken"> | boolean
  }

  export type AdvertisementWhereInput = {
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    id?: StringFilter<"Advertisement"> | string
    name?: StringFilter<"Advertisement"> | string
    type?: EnumAdTypeFilter<"Advertisement"> | $Enums.AdType
    placement?: EnumAdPlacementFilter<"Advertisement"> | $Enums.AdPlacement
    content?: StringFilter<"Advertisement"> | string
    imageUrl?: StringNullableFilter<"Advertisement"> | string | null
    clickUrl?: StringNullableFilter<"Advertisement"> | string | null
    order?: IntFilter<"Advertisement"> | number
    enabled?: BoolFilter<"Advertisement"> | boolean
    impressions?: IntFilter<"Advertisement"> | number
    clicks?: IntFilter<"Advertisement"> | number
    createdAt?: DateTimeFilter<"Advertisement"> | Date | string
    updatedAt?: DateTimeFilter<"Advertisement"> | Date | string
  }

  export type AdvertisementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placement?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    clickUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    enabled?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AdvertisementOrderByRelevanceInput
  }

  export type AdvertisementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    name?: StringFilter<"Advertisement"> | string
    type?: EnumAdTypeFilter<"Advertisement"> | $Enums.AdType
    placement?: EnumAdPlacementFilter<"Advertisement"> | $Enums.AdPlacement
    content?: StringFilter<"Advertisement"> | string
    imageUrl?: StringNullableFilter<"Advertisement"> | string | null
    clickUrl?: StringNullableFilter<"Advertisement"> | string | null
    order?: IntFilter<"Advertisement"> | number
    enabled?: BoolFilter<"Advertisement"> | boolean
    impressions?: IntFilter<"Advertisement"> | number
    clicks?: IntFilter<"Advertisement"> | number
    createdAt?: DateTimeFilter<"Advertisement"> | Date | string
    updatedAt?: DateTimeFilter<"Advertisement"> | Date | string
  }, "id">

  export type AdvertisementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placement?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    clickUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    enabled?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdvertisementCountOrderByAggregateInput
    _avg?: AdvertisementAvgOrderByAggregateInput
    _max?: AdvertisementMaxOrderByAggregateInput
    _min?: AdvertisementMinOrderByAggregateInput
    _sum?: AdvertisementSumOrderByAggregateInput
  }

  export type AdvertisementScalarWhereWithAggregatesInput = {
    AND?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    OR?: AdvertisementScalarWhereWithAggregatesInput[]
    NOT?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Advertisement"> | string
    name?: StringWithAggregatesFilter<"Advertisement"> | string
    type?: EnumAdTypeWithAggregatesFilter<"Advertisement"> | $Enums.AdType
    placement?: EnumAdPlacementWithAggregatesFilter<"Advertisement"> | $Enums.AdPlacement
    content?: StringWithAggregatesFilter<"Advertisement"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Advertisement"> | string | null
    clickUrl?: StringNullableWithAggregatesFilter<"Advertisement"> | string | null
    order?: IntWithAggregatesFilter<"Advertisement"> | number
    enabled?: BoolWithAggregatesFilter<"Advertisement"> | boolean
    impressions?: IntWithAggregatesFilter<"Advertisement"> | number
    clicks?: IntWithAggregatesFilter<"Advertisement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Advertisement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Advertisement"> | Date | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    userId?: StringNullableFilter<"SystemLog"> | string | null
    userEmail?: StringNullableFilter<"SystemLog"> | string | null
    action?: EnumSystemLogActionFilter<"SystemLog"> | $Enums.SystemLogAction
    targetType?: StringNullableFilter<"SystemLog"> | string | null
    targetId?: StringNullableFilter<"SystemLog"> | string | null
    amount?: FloatNullableFilter<"SystemLog"> | number | null
    description?: StringFilter<"SystemLog"> | string
    metadata?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    action?: SortOrder
    targetType?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: SystemLogOrderByRelevanceInput
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    userId?: StringNullableFilter<"SystemLog"> | string | null
    userEmail?: StringNullableFilter<"SystemLog"> | string | null
    action?: EnumSystemLogActionFilter<"SystemLog"> | $Enums.SystemLogAction
    targetType?: StringNullableFilter<"SystemLog"> | string | null
    targetId?: StringNullableFilter<"SystemLog"> | string | null
    amount?: FloatNullableFilter<"SystemLog"> | number | null
    description?: StringFilter<"SystemLog"> | string
    metadata?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    userEmail?: SortOrderInput | SortOrder
    action?: SortOrder
    targetType?: SortOrderInput | SortOrder
    targetId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _avg?: SystemLogAvgOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
    _sum?: SystemLogSumOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    userId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    action?: EnumSystemLogActionWithAggregatesFilter<"SystemLog"> | $Enums.SystemLogAction
    targetType?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    targetId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    amount?: FloatNullableWithAggregatesFilter<"SystemLog"> | number | null
    description?: StringWithAggregatesFilter<"SystemLog"> | string
    metadata?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
  }

  export type ErrorReportWhereInput = {
    AND?: ErrorReportWhereInput | ErrorReportWhereInput[]
    OR?: ErrorReportWhereInput[]
    NOT?: ErrorReportWhereInput | ErrorReportWhereInput[]
    id?: StringFilter<"ErrorReport"> | string
    userId?: StringFilter<"ErrorReport"> | string
    userEmail?: StringFilter<"ErrorReport"> | string
    orderId?: StringFilter<"ErrorReport"> | string
    productLineId?: StringNullableFilter<"ErrorReport"> | string | null
    productName?: StringNullableFilter<"ErrorReport"> | string | null
    originalContent?: StringNullableFilter<"ErrorReport"> | string | null
    userNote?: StringNullableFilter<"ErrorReport"> | string | null
    status?: EnumErrorReportStatusFilter<"ErrorReport"> | $Enums.ErrorReportStatus
    reportedProducts?: StringNullableFilter<"ErrorReport"> | string | null
    adminNote?: StringNullableFilter<"ErrorReport"> | string | null
    resolution?: StringNullableFilter<"ErrorReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ErrorReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ErrorReport"> | Date | string
    updatedAt?: DateTimeFilter<"ErrorReport"> | Date | string
  }

  export type ErrorReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    orderId?: SortOrder
    productLineId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    originalContent?: SortOrderInput | SortOrder
    userNote?: SortOrderInput | SortOrder
    status?: SortOrder
    reportedProducts?: SortOrderInput | SortOrder
    adminNote?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ErrorReportOrderByRelevanceInput
  }

  export type ErrorReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ErrorReportWhereInput | ErrorReportWhereInput[]
    OR?: ErrorReportWhereInput[]
    NOT?: ErrorReportWhereInput | ErrorReportWhereInput[]
    userId?: StringFilter<"ErrorReport"> | string
    userEmail?: StringFilter<"ErrorReport"> | string
    orderId?: StringFilter<"ErrorReport"> | string
    productLineId?: StringNullableFilter<"ErrorReport"> | string | null
    productName?: StringNullableFilter<"ErrorReport"> | string | null
    originalContent?: StringNullableFilter<"ErrorReport"> | string | null
    userNote?: StringNullableFilter<"ErrorReport"> | string | null
    status?: EnumErrorReportStatusFilter<"ErrorReport"> | $Enums.ErrorReportStatus
    reportedProducts?: StringNullableFilter<"ErrorReport"> | string | null
    adminNote?: StringNullableFilter<"ErrorReport"> | string | null
    resolution?: StringNullableFilter<"ErrorReport"> | string | null
    resolvedAt?: DateTimeNullableFilter<"ErrorReport"> | Date | string | null
    createdAt?: DateTimeFilter<"ErrorReport"> | Date | string
    updatedAt?: DateTimeFilter<"ErrorReport"> | Date | string
  }, "id">

  export type ErrorReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    orderId?: SortOrder
    productLineId?: SortOrderInput | SortOrder
    productName?: SortOrderInput | SortOrder
    originalContent?: SortOrderInput | SortOrder
    userNote?: SortOrderInput | SortOrder
    status?: SortOrder
    reportedProducts?: SortOrderInput | SortOrder
    adminNote?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ErrorReportCountOrderByAggregateInput
    _max?: ErrorReportMaxOrderByAggregateInput
    _min?: ErrorReportMinOrderByAggregateInput
  }

  export type ErrorReportScalarWhereWithAggregatesInput = {
    AND?: ErrorReportScalarWhereWithAggregatesInput | ErrorReportScalarWhereWithAggregatesInput[]
    OR?: ErrorReportScalarWhereWithAggregatesInput[]
    NOT?: ErrorReportScalarWhereWithAggregatesInput | ErrorReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ErrorReport"> | string
    userId?: StringWithAggregatesFilter<"ErrorReport"> | string
    userEmail?: StringWithAggregatesFilter<"ErrorReport"> | string
    orderId?: StringWithAggregatesFilter<"ErrorReport"> | string
    productLineId?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    productName?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    originalContent?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    userNote?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    status?: EnumErrorReportStatusWithAggregatesFilter<"ErrorReport"> | $Enums.ErrorReportStatus
    reportedProducts?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    adminNote?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"ErrorReport"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"ErrorReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ErrorReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ErrorReport"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    orderId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    isAnonymous?: BoolFilter<"Review"> | boolean
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    adminNote?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    _relevance?: ReviewOrderByRelevanceInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_productId?: ReviewUserIdProductIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    orderId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    isAnonymous?: BoolFilter<"Review"> | boolean
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    adminNote?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "userId_productId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    adminNote?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    productId?: StringWithAggregatesFilter<"Review"> | string
    orderId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isAnonymous?: BoolWithAggregatesFilter<"Review"> | boolean
    status?: EnumReviewStatusWithAggregatesFilter<"Review"> | $Enums.ReviewStatus
    adminNote?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: StringFilter<"Banner"> | string
    title?: StringFilter<"Banner"> | string
    subtitle?: StringNullableFilter<"Banner"> | string | null
    description?: StringNullableFilter<"Banner"> | string | null
    buttonText?: StringFilter<"Banner"> | string
    buttonLink?: StringFilter<"Banner"> | string
    imageUrl?: StringNullableFilter<"Banner"> | string | null
    gradientFrom?: StringFilter<"Banner"> | string
    gradientTo?: StringFilter<"Banner"> | string
    features?: StringNullableFilter<"Banner"> | string | null
    order?: IntFilter<"Banner"> | number
    active?: BoolFilter<"Banner"> | boolean
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    gradientFrom?: SortOrder
    gradientTo?: SortOrder
    features?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BannerOrderByRelevanceInput
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    title?: StringFilter<"Banner"> | string
    subtitle?: StringNullableFilter<"Banner"> | string | null
    description?: StringNullableFilter<"Banner"> | string | null
    buttonText?: StringFilter<"Banner"> | string
    buttonLink?: StringFilter<"Banner"> | string
    imageUrl?: StringNullableFilter<"Banner"> | string | null
    gradientFrom?: StringFilter<"Banner"> | string
    gradientTo?: StringFilter<"Banner"> | string
    features?: StringNullableFilter<"Banner"> | string | null
    order?: IntFilter<"Banner"> | number
    active?: BoolFilter<"Banner"> | boolean
    createdAt?: DateTimeFilter<"Banner"> | Date | string
    updatedAt?: DateTimeFilter<"Banner"> | Date | string
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    gradientFrom?: SortOrder
    gradientTo?: SortOrder
    features?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Banner"> | string
    title?: StringWithAggregatesFilter<"Banner"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    description?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    buttonText?: StringWithAggregatesFilter<"Banner"> | string
    buttonLink?: StringWithAggregatesFilter<"Banner"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    gradientFrom?: StringWithAggregatesFilter<"Banner"> | string
    gradientTo?: StringWithAggregatesFilter<"Banner"> | string
    features?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    order?: IntWithAggregatesFilter<"Banner"> | number
    active?: BoolWithAggregatesFilter<"Banner"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Banner"> | Date | string
  }

  export type FeaturedUserWhereInput = {
    AND?: FeaturedUserWhereInput | FeaturedUserWhereInput[]
    OR?: FeaturedUserWhereInput[]
    NOT?: FeaturedUserWhereInput | FeaturedUserWhereInput[]
    id?: StringFilter<"FeaturedUser"> | string
    name?: StringFilter<"FeaturedUser"> | string
    sales?: IntFilter<"FeaturedUser"> | number
    rating?: FloatFilter<"FeaturedUser"> | number
    avatarUrl?: StringNullableFilter<"FeaturedUser"> | string | null
    rank?: IntFilter<"FeaturedUser"> | number
    active?: BoolFilter<"FeaturedUser"> | boolean
    createdAt?: DateTimeFilter<"FeaturedUser"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedUser"> | Date | string
  }

  export type FeaturedUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sales?: SortOrder
    rating?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    rank?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: FeaturedUserOrderByRelevanceInput
  }

  export type FeaturedUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeaturedUserWhereInput | FeaturedUserWhereInput[]
    OR?: FeaturedUserWhereInput[]
    NOT?: FeaturedUserWhereInput | FeaturedUserWhereInput[]
    name?: StringFilter<"FeaturedUser"> | string
    sales?: IntFilter<"FeaturedUser"> | number
    rating?: FloatFilter<"FeaturedUser"> | number
    avatarUrl?: StringNullableFilter<"FeaturedUser"> | string | null
    rank?: IntFilter<"FeaturedUser"> | number
    active?: BoolFilter<"FeaturedUser"> | boolean
    createdAt?: DateTimeFilter<"FeaturedUser"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedUser"> | Date | string
  }, "id">

  export type FeaturedUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sales?: SortOrder
    rating?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    rank?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedUserCountOrderByAggregateInput
    _avg?: FeaturedUserAvgOrderByAggregateInput
    _max?: FeaturedUserMaxOrderByAggregateInput
    _min?: FeaturedUserMinOrderByAggregateInput
    _sum?: FeaturedUserSumOrderByAggregateInput
  }

  export type FeaturedUserScalarWhereWithAggregatesInput = {
    AND?: FeaturedUserScalarWhereWithAggregatesInput | FeaturedUserScalarWhereWithAggregatesInput[]
    OR?: FeaturedUserScalarWhereWithAggregatesInput[]
    NOT?: FeaturedUserScalarWhereWithAggregatesInput | FeaturedUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedUser"> | string
    name?: StringWithAggregatesFilter<"FeaturedUser"> | string
    sales?: IntWithAggregatesFilter<"FeaturedUser"> | number
    rating?: FloatWithAggregatesFilter<"FeaturedUser"> | number
    avatarUrl?: StringNullableWithAggregatesFilter<"FeaturedUser"> | string | null
    rank?: IntWithAggregatesFilter<"FeaturedUser"> | number
    active?: BoolWithAggregatesFilter<"FeaturedUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedUser"> | Date | string
  }

  export type SearchKeywordWhereInput = {
    AND?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    OR?: SearchKeywordWhereInput[]
    NOT?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    id?: StringFilter<"SearchKeyword"> | string
    keyword?: StringFilter<"SearchKeyword"> | string
    subtitle?: StringNullableFilter<"SearchKeyword"> | string | null
    icon?: StringFilter<"SearchKeyword"> | string
    order?: IntFilter<"SearchKeyword"> | number
    active?: BoolFilter<"SearchKeyword"> | boolean
    createdAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SearchKeyword"> | Date | string
  }

  export type SearchKeywordOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SearchKeywordOrderByRelevanceInput
  }

  export type SearchKeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    OR?: SearchKeywordWhereInput[]
    NOT?: SearchKeywordWhereInput | SearchKeywordWhereInput[]
    keyword?: StringFilter<"SearchKeyword"> | string
    subtitle?: StringNullableFilter<"SearchKeyword"> | string | null
    icon?: StringFilter<"SearchKeyword"> | string
    order?: IntFilter<"SearchKeyword"> | number
    active?: BoolFilter<"SearchKeyword"> | boolean
    createdAt?: DateTimeFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeFilter<"SearchKeyword"> | Date | string
  }, "id">

  export type SearchKeywordOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SearchKeywordCountOrderByAggregateInput
    _avg?: SearchKeywordAvgOrderByAggregateInput
    _max?: SearchKeywordMaxOrderByAggregateInput
    _min?: SearchKeywordMinOrderByAggregateInput
    _sum?: SearchKeywordSumOrderByAggregateInput
  }

  export type SearchKeywordScalarWhereWithAggregatesInput = {
    AND?: SearchKeywordScalarWhereWithAggregatesInput | SearchKeywordScalarWhereWithAggregatesInput[]
    OR?: SearchKeywordScalarWhereWithAggregatesInput[]
    NOT?: SearchKeywordScalarWhereWithAggregatesInput | SearchKeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchKeyword"> | string
    keyword?: StringWithAggregatesFilter<"SearchKeyword"> | string
    subtitle?: StringNullableWithAggregatesFilter<"SearchKeyword"> | string | null
    icon?: StringWithAggregatesFilter<"SearchKeyword"> | string
    order?: IntWithAggregatesFilter<"SearchKeyword"> | number
    active?: BoolWithAggregatesFilter<"SearchKeyword"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SearchKeyword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SearchKeyword"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletCreateInput = {
    id?: string
    balanceVnd?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    balanceVnd?: number
    updatedAt?: Date | string
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceVnd?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balanceVnd?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    balanceVnd?: number
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceVnd?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balanceVnd?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productLogs?: ProductLogCreateNestedManyWithoutProductInput
    files?: FileCreateNestedManyWithoutProductInput
    licenses?: LicenseCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutProductInput
    files?: FileUncheckedCreateNestedManyWithoutProductInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUpdateManyWithoutProductNestedInput
    files?: FileUpdateManyWithoutProductNestedInput
    licenses?: LicenseUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutProductNestedInput
    files?: FileUncheckedUpdateManyWithoutProductNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLogCreateInput = {
    id?: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductLogsInput
    user: UserCreateNestedOneWithoutProductLogsInput
    order: OrderCreateNestedOneWithoutProductLogsInput
    productLines?: ProductLineItemCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogUncheckedCreateInput = {
    id?: string
    productId: string
    userId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    productLines?: ProductLineItemUncheckedCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductLogsNestedInput
    user?: UserUpdateOneRequiredWithoutProductLogsNestedInput
    order?: OrderUpdateOneRequiredWithoutProductLogsNestedInput
    productLines?: ProductLineItemUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productLines?: ProductLineItemUncheckedUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogCreateManyInput = {
    id?: string
    productId: string
    userId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProductLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLineItemCreateInput = {
    id?: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status?: $Enums.ProductLineStatus
    errorReported?: boolean
    replacement?: string | null
    adminNote?: string | null
    rejectedAt?: Date | string | null
    replacedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productLog: ProductLogCreateNestedOneWithoutProductLinesInput
  }

  export type ProductLineItemUncheckedCreateInput = {
    id?: string
    productLogId: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status?: $Enums.ProductLineStatus
    errorReported?: boolean
    replacement?: string | null
    adminNote?: string | null
    rejectedAt?: Date | string | null
    replacedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductLineItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productLog?: ProductLogUpdateOneRequiredWithoutProductLinesNestedInput
  }

  export type ProductLineItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productLogId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLineItemCreateManyInput = {
    id?: string
    productLogId: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status?: $Enums.ProductLineStatus
    errorReported?: boolean
    replacement?: string | null
    adminNote?: string | null
    rejectedAt?: Date | string | null
    replacedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductLineItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLineItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productLogId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutFilesInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    productId: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFilesNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    productId: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateInput = {
    id?: string
    codeOrJwt: string
    status?: $Enums.LicenseStatus
    boundEmail?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutLicensesInput
  }

  export type LicenseUncheckedCreateInput = {
    id?: string
    productId: string
    codeOrJwt: string
    status?: $Enums.LicenseStatus
    boundEmail?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutLicensesNestedInput
  }

  export type LicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseCreateManyInput = {
    id?: string
    productId: string
    codeOrJwt: string
    status?: $Enums.LicenseStatus
    boundEmail?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity?: number
    priceVnd: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity?: number
    priceVnd: number
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity?: number
    priceVnd: number
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    providerTxid?: string | null
    amountVnd: number
    rawJson?: string | null
    matchedBy?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    provider: $Enums.PaymentProvider
    providerTxid?: string | null
    amountVnd: number
    rawJson?: string | null
    matchedBy?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    provider: $Enums.PaymentProvider
    providerTxid?: string | null
    amountVnd: number
    rawJson?: string | null
    matchedBy?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDepositRequestCreateInput = {
    internalId?: string | null
    amountVnd: number
    note?: string | null
    qrCode?: string | null
    transferContent?: string | null
    status?: $Enums.DepositStatus
    adminNote?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDepositRequestsInput
  }

  export type ManualDepositRequestUncheckedCreateInput = {
    id?: number
    internalId?: string | null
    userId: string
    amountVnd: number
    note?: string | null
    qrCode?: string | null
    transferContent?: string | null
    status?: $Enums.DepositStatus
    adminNote?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ManualDepositRequestUpdateInput = {
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDepositRequestsNestedInput
  }

  export type ManualDepositRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDepositRequestCreateManyInput = {
    id?: number
    internalId?: string | null
    userId: string
    amountVnd: number
    note?: string | null
    qrCode?: string | null
    transferContent?: string | null
    status?: $Enums.DepositStatus
    adminNote?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ManualDepositRequestUpdateManyMutationInput = {
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDepositRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    maxDiscountVnd?: number | null
    minOrderVnd?: number
    maxUses?: number | null
    usedCount?: number
    startDate?: Date | string | null
    expiryDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    maxDiscountVnd?: number | null
    minOrderVnd?: number
    maxUses?: number | null
    usedCount?: number
    startDate?: Date | string | null
    expiryDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxDiscountVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    minOrderVnd?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxDiscountVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    minOrderVnd?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    maxDiscountVnd?: number | null
    minOrderVnd?: number
    maxUses?: number | null
    usedCount?: number
    startDate?: Date | string | null
    expiryDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxDiscountVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    minOrderVnd?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    maxDiscountVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    minOrderVnd?: FloatFieldUpdateOperationsInput | number
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    websiteName?: string
    websiteTitle?: string
    websiteDescription?: string
    websiteKeywords?: string
    websiteLogo?: string | null
    websiteFavicon?: string | null
    copyrightYear?: string
    supportEmail?: string
    contactInfo?: string
    paymentMethods?: string
    bankInfo?: string
    topupRules?: string
    tpbankConfig?: string
    depositBonusTiers?: string
    referralSettings?: string
    uiTexts?: string
    themeSettings?: string
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    websiteName?: string
    websiteTitle?: string
    websiteDescription?: string
    websiteKeywords?: string
    websiteLogo?: string | null
    websiteFavicon?: string | null
    copyrightYear?: string
    supportEmail?: string
    contactInfo?: string
    paymentMethods?: string
    bankInfo?: string
    topupRules?: string
    tpbankConfig?: string
    depositBonusTiers?: string
    referralSettings?: string
    uiTexts?: string
    themeSettings?: string
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteName?: StringFieldUpdateOperationsInput | string
    websiteTitle?: StringFieldUpdateOperationsInput | string
    websiteDescription?: StringFieldUpdateOperationsInput | string
    websiteKeywords?: StringFieldUpdateOperationsInput | string
    websiteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    websiteFavicon?: NullableStringFieldUpdateOperationsInput | string | null
    copyrightYear?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    paymentMethods?: StringFieldUpdateOperationsInput | string
    bankInfo?: StringFieldUpdateOperationsInput | string
    topupRules?: StringFieldUpdateOperationsInput | string
    tpbankConfig?: StringFieldUpdateOperationsInput | string
    depositBonusTiers?: StringFieldUpdateOperationsInput | string
    referralSettings?: StringFieldUpdateOperationsInput | string
    uiTexts?: StringFieldUpdateOperationsInput | string
    themeSettings?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteName?: StringFieldUpdateOperationsInput | string
    websiteTitle?: StringFieldUpdateOperationsInput | string
    websiteDescription?: StringFieldUpdateOperationsInput | string
    websiteKeywords?: StringFieldUpdateOperationsInput | string
    websiteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    websiteFavicon?: NullableStringFieldUpdateOperationsInput | string | null
    copyrightYear?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    paymentMethods?: StringFieldUpdateOperationsInput | string
    bankInfo?: StringFieldUpdateOperationsInput | string
    topupRules?: StringFieldUpdateOperationsInput | string
    tpbankConfig?: StringFieldUpdateOperationsInput | string
    depositBonusTiers?: StringFieldUpdateOperationsInput | string
    referralSettings?: StringFieldUpdateOperationsInput | string
    uiTexts?: StringFieldUpdateOperationsInput | string
    themeSettings?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    websiteName?: string
    websiteTitle?: string
    websiteDescription?: string
    websiteKeywords?: string
    websiteLogo?: string | null
    websiteFavicon?: string | null
    copyrightYear?: string
    supportEmail?: string
    contactInfo?: string
    paymentMethods?: string
    bankInfo?: string
    topupRules?: string
    tpbankConfig?: string
    depositBonusTiers?: string
    referralSettings?: string
    uiTexts?: string
    themeSettings?: string
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteName?: StringFieldUpdateOperationsInput | string
    websiteTitle?: StringFieldUpdateOperationsInput | string
    websiteDescription?: StringFieldUpdateOperationsInput | string
    websiteKeywords?: StringFieldUpdateOperationsInput | string
    websiteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    websiteFavicon?: NullableStringFieldUpdateOperationsInput | string | null
    copyrightYear?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    paymentMethods?: StringFieldUpdateOperationsInput | string
    bankInfo?: StringFieldUpdateOperationsInput | string
    topupRules?: StringFieldUpdateOperationsInput | string
    tpbankConfig?: StringFieldUpdateOperationsInput | string
    depositBonusTiers?: StringFieldUpdateOperationsInput | string
    referralSettings?: StringFieldUpdateOperationsInput | string
    uiTexts?: StringFieldUpdateOperationsInput | string
    themeSettings?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteName?: StringFieldUpdateOperationsInput | string
    websiteTitle?: StringFieldUpdateOperationsInput | string
    websiteDescription?: StringFieldUpdateOperationsInput | string
    websiteKeywords?: StringFieldUpdateOperationsInput | string
    websiteLogo?: NullableStringFieldUpdateOperationsInput | string | null
    websiteFavicon?: NullableStringFieldUpdateOperationsInput | string | null
    copyrightYear?: StringFieldUpdateOperationsInput | string
    supportEmail?: StringFieldUpdateOperationsInput | string
    contactInfo?: StringFieldUpdateOperationsInput | string
    paymentMethods?: StringFieldUpdateOperationsInput | string
    bankInfo?: StringFieldUpdateOperationsInput | string
    topupRules?: StringFieldUpdateOperationsInput | string
    tpbankConfig?: StringFieldUpdateOperationsInput | string
    depositBonusTiers?: StringFieldUpdateOperationsInput | string
    referralSettings?: StringFieldUpdateOperationsInput | string
    uiTexts?: StringFieldUpdateOperationsInput | string
    themeSettings?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadLogCreateInput = {
    id?: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutDownloadLogsInput
    file?: FileCreateNestedOneWithoutDownloadLogsInput
  }

  export type DownloadLogUncheckedCreateInput = {
    id?: string
    orderId: string
    fileId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DownloadLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDownloadLogsNestedInput
    file?: FileUpdateOneWithoutDownloadLogsNestedInput
  }

  export type DownloadLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadLogCreateManyInput = {
    id?: string
    orderId: string
    fileId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DownloadLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionLogCreateInput = {
    id?: string
    action: string
    targetType?: string | null
    targetId?: string | null
    diffJson?: string | null
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutAdminActionsInput
  }

  export type AdminActionLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    targetType?: string | null
    targetId?: string | null
    diffJson?: string | null
    createdAt?: Date | string
  }

  export type AdminActionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAdminActionsNestedInput
  }

  export type AdminActionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionLogCreateManyInput = {
    id?: string
    adminId: string
    action: string
    targetType?: string | null
    targetId?: string | null
    diffJson?: string | null
    createdAt?: Date | string
  }

  export type AdminActionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amountVnd: number
    balanceAfterVnd: number
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amountVnd: number
    balanceAfterVnd: number
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amountVnd?: FloatFieldUpdateOperationsInput | number
    balanceAfterVnd?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amountVnd?: FloatFieldUpdateOperationsInput | number
    balanceAfterVnd?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amountVnd: number
    balanceAfterVnd: number
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amountVnd?: FloatFieldUpdateOperationsInput | number
    balanceAfterVnd?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amountVnd?: FloatFieldUpdateOperationsInput | number
    balanceAfterVnd?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsCreateInput = {
    key: string
    value: string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsUncheckedCreateInput = {
    key: string
    value: string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsCreateManyInput = {
    key: string
    value: string
    updatedAt?: Date | string
  }

  export type WebsiteSettingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteSettingsUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoTopupLogCreateInput = {
    id?: string
    bankTransactionId: string
    bankName: string
    depositRequestId?: number | null
    userId?: string | null
    topupCode: string
    amountVnd: number
    description: string
    status: $Enums.AutoTopupStatus
    errorMessage?: string | null
    transactionDate: Date | string
    createdAt?: Date | string
  }

  export type AutoTopupLogUncheckedCreateInput = {
    id?: string
    bankTransactionId: string
    bankName: string
    depositRequestId?: number | null
    userId?: string | null
    topupCode: string
    amountVnd: number
    description: string
    status: $Enums.AutoTopupStatus
    errorMessage?: string | null
    transactionDate: Date | string
    createdAt?: Date | string
  }

  export type AutoTopupLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankTransactionId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    depositRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topupCode?: StringFieldUpdateOperationsInput | string
    amountVnd?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoTopupStatusFieldUpdateOperationsInput | $Enums.AutoTopupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoTopupLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankTransactionId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    depositRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topupCode?: StringFieldUpdateOperationsInput | string
    amountVnd?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoTopupStatusFieldUpdateOperationsInput | $Enums.AutoTopupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoTopupLogCreateManyInput = {
    id?: string
    bankTransactionId: string
    bankName: string
    depositRequestId?: number | null
    userId?: string | null
    topupCode: string
    amountVnd: number
    description: string
    status: $Enums.AutoTopupStatus
    errorMessage?: string | null
    transactionDate: Date | string
    createdAt?: Date | string
  }

  export type AutoTopupLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankTransactionId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    depositRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topupCode?: StringFieldUpdateOperationsInput | string
    amountVnd?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoTopupStatusFieldUpdateOperationsInput | $Enums.AutoTopupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutoTopupLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankTransactionId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    depositRequestId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    topupCode?: StringFieldUpdateOperationsInput | string
    amountVnd?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumAutoTopupStatusFieldUpdateOperationsInput | $Enums.AutoTopupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsInput
    referee: UserCreateNestedOneWithoutReferredByInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    refereeId: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
    referee?: UserUpdateOneRequiredWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    refereeId: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogCreateInput = {
    id?: string
    userId: string
    action: string
    targetType?: string | null
    targetId?: string | null
    metadata?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserActivityLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    targetType?: string | null
    targetId?: string | null
    metadata?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    targetType?: string | null
    targetId?: string | null
    metadata?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAccountCreateInput = {
    id?: string
    name: string
    issuer: string
    secret: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTwoFactorAccountsInput
  }

  export type TwoFactorAccountUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    issuer: string
    secret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTwoFactorAccountsNestedInput
  }

  export type TwoFactorAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAccountCreateManyInput = {
    id?: string
    userId: string
    name: string
    issuer: string
    secret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    used?: boolean
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    used?: boolean
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    used?: boolean
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdvertisementCreateInput = {
    id?: string
    name: string
    type: $Enums.AdType
    placement: $Enums.AdPlacement
    content: string
    imageUrl?: string | null
    clickUrl?: string | null
    order?: number
    enabled?: boolean
    impressions?: number
    clicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvertisementUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.AdType
    placement: $Enums.AdPlacement
    content: string
    imageUrl?: string | null
    clickUrl?: string | null
    order?: number
    enabled?: boolean
    impressions?: number
    clicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvertisementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    placement?: EnumAdPlacementFieldUpdateOperationsInput | $Enums.AdPlacement
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    placement?: EnumAdPlacementFieldUpdateOperationsInput | $Enums.AdPlacement
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementCreateManyInput = {
    id?: string
    name: string
    type: $Enums.AdType
    placement: $Enums.AdPlacement
    content: string
    imageUrl?: string | null
    clickUrl?: string | null
    order?: number
    enabled?: boolean
    impressions?: number
    clicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdvertisementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    placement?: EnumAdPlacementFieldUpdateOperationsInput | $Enums.AdPlacement
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAdTypeFieldUpdateOperationsInput | $Enums.AdType
    placement?: EnumAdPlacementFieldUpdateOperationsInput | $Enums.AdPlacement
    content?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clickUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateInput = {
    id?: string
    userId?: string | null
    userEmail?: string | null
    action: $Enums.SystemLogAction
    targetType?: string | null
    targetId?: string | null
    amount?: number | null
    description: string
    metadata?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    userEmail?: string | null
    action: $Enums.SystemLogAction
    targetType?: string | null
    targetId?: string | null
    amount?: number | null
    description: string
    metadata?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumSystemLogActionFieldUpdateOperationsInput | $Enums.SystemLogAction
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumSystemLogActionFieldUpdateOperationsInput | $Enums.SystemLogAction
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateManyInput = {
    id?: string
    userId?: string | null
    userEmail?: string | null
    action: $Enums.SystemLogAction
    targetType?: string | null
    targetId?: string | null
    amount?: number | null
    description: string
    metadata?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumSystemLogActionFieldUpdateOperationsInput | $Enums.SystemLogAction
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumSystemLogActionFieldUpdateOperationsInput | $Enums.SystemLogAction
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorReportCreateInput = {
    id?: string
    userId: string
    userEmail: string
    orderId: string
    productLineId?: string | null
    productName?: string | null
    originalContent?: string | null
    userNote?: string | null
    status?: $Enums.ErrorReportStatus
    reportedProducts?: string | null
    adminNote?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorReportUncheckedCreateInput = {
    id?: string
    userId: string
    userEmail: string
    orderId: string
    productLineId?: string | null
    productName?: string | null
    originalContent?: string | null
    userNote?: string | null
    status?: $Enums.ErrorReportStatus
    reportedProducts?: string | null
    adminNote?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productLineId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    userNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumErrorReportStatusFieldUpdateOperationsInput | $Enums.ErrorReportStatus
    reportedProducts?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productLineId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    userNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumErrorReportStatusFieldUpdateOperationsInput | $Enums.ErrorReportStatus
    reportedProducts?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorReportCreateManyInput = {
    id?: string
    userId: string
    userEmail: string
    orderId: string
    productLineId?: string | null
    productName?: string | null
    originalContent?: string | null
    userNote?: string | null
    status?: $Enums.ErrorReportStatus
    reportedProducts?: string | null
    adminNote?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ErrorReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productLineId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    userNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumErrorReportStatusFieldUpdateOperationsInput | $Enums.ErrorReportStatus
    reportedProducts?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ErrorReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productLineId?: NullableStringFieldUpdateOperationsInput | string | null
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    originalContent?: NullableStringFieldUpdateOperationsInput | string | null
    userNote?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumErrorReportStatusFieldUpdateOperationsInput | $Enums.ErrorReportStatus
    reportedProducts?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
    order: OrderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    orderId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    order?: OrderUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    productId: string
    orderId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    description?: string | null
    buttonText?: string
    buttonLink?: string
    imageUrl?: string | null
    gradientFrom?: string
    gradientTo?: string
    features?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUncheckedCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    description?: string | null
    buttonText?: string
    buttonLink?: string
    imageUrl?: string | null
    gradientFrom?: string
    gradientTo?: string
    features?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gradientFrom?: StringFieldUpdateOperationsInput | string
    gradientTo?: StringFieldUpdateOperationsInput | string
    features?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gradientFrom?: StringFieldUpdateOperationsInput | string
    gradientTo?: StringFieldUpdateOperationsInput | string
    features?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerCreateManyInput = {
    id?: string
    title: string
    subtitle?: string | null
    description?: string | null
    buttonText?: string
    buttonLink?: string
    imageUrl?: string | null
    gradientFrom?: string
    gradientTo?: string
    features?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gradientFrom?: StringFieldUpdateOperationsInput | string
    gradientTo?: StringFieldUpdateOperationsInput | string
    features?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    buttonText?: StringFieldUpdateOperationsInput | string
    buttonLink?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gradientFrom?: StringFieldUpdateOperationsInput | string
    gradientTo?: StringFieldUpdateOperationsInput | string
    features?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedUserCreateInput = {
    id?: string
    name: string
    sales?: number
    rating?: number
    avatarUrl?: string | null
    rank?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedUserUncheckedCreateInput = {
    id?: string
    name: string
    sales?: number
    rating?: number
    avatarUrl?: string | null
    rank?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sales?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sales?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedUserCreateManyInput = {
    id?: string
    name: string
    sales?: number
    rating?: number
    avatarUrl?: string | null
    rank?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sales?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sales?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchKeywordCreateInput = {
    id?: string
    keyword: string
    subtitle?: string | null
    icon?: string
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchKeywordUncheckedCreateInput = {
    id?: string
    keyword: string
    subtitle?: string | null
    icon?: string
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchKeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchKeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchKeywordCreateManyInput = {
    id?: string
    keyword: string
    subtitle?: string | null
    icon?: string
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchKeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchKeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ManualDepositRequestListRelationFilter = {
    every?: ManualDepositRequestWhereInput
    some?: ManualDepositRequestWhereInput
    none?: ManualDepositRequestWhereInput
  }

  export type AdminActionLogListRelationFilter = {
    every?: AdminActionLogWhereInput
    some?: AdminActionLogWhereInput
    none?: AdminActionLogWhereInput
  }

  export type ProductLogListRelationFilter = {
    every?: ProductLogWhereInput
    some?: ProductLogWhereInput
    none?: ProductLogWhereInput
  }

  export type TwoFactorAccountListRelationFilter = {
    every?: TwoFactorAccountWhereInput
    some?: TwoFactorAccountWhereInput
    none?: TwoFactorAccountWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralNullableScalarRelationFilter = {
    is?: ReferralWhereInput | null
    isNot?: ReferralWhereInput | null
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualDepositRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminActionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFactorAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referredById?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WalletOrderByRelevanceInput = {
    fields: WalletOrderByRelevanceFieldEnum | WalletOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balanceVnd?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balanceVnd?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balanceVnd?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balanceVnd?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balanceVnd?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type LicenseListRelationFilter = {
    every?: LicenseWhereInput
    some?: LicenseWhereInput
    none?: LicenseWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceVnd?: SortOrder
    stock?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    images?: SortOrder
    active?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    priceVnd?: SortOrder
    stock?: SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceVnd?: SortOrder
    stock?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    images?: SortOrder
    active?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    priceVnd?: SortOrder
    stock?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    images?: SortOrder
    active?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    priceVnd?: SortOrder
    stock?: SortOrder
    totalLines?: SortOrder
    usedLines?: SortOrder
    fakeSold?: SortOrder
    fakeRating?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductLineItemListRelationFilter = {
    every?: ProductLineItemWhereInput
    some?: ProductLineItemWhereInput
    none?: ProductLineItemWhereInput
  }

  export type ProductLineItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductLogOrderByRelevanceInput = {
    fields: ProductLogOrderByRelevanceFieldEnum | ProductLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductLogCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    lineIndices?: SortOrder
    content?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductLogAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ProductLogMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    lineIndices?: SortOrder
    content?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductLogMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    action?: SortOrder
    quantity?: SortOrder
    lineIndices?: SortOrder
    content?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductLogSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumProductLineStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLineStatus | EnumProductLineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLineStatus[]
    notIn?: $Enums.ProductLineStatus[]
    not?: NestedEnumProductLineStatusFilter<$PrismaModel> | $Enums.ProductLineStatus
  }

  export type ProductLogScalarRelationFilter = {
    is?: ProductLogWhereInput
    isNot?: ProductLogWhereInput
  }

  export type ProductLineItemOrderByRelevanceInput = {
    fields: ProductLineItemOrderByRelevanceFieldEnum | ProductLineItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductLineItemCountOrderByAggregateInput = {
    id?: SortOrder
    productLogId?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    content?: SortOrder
    priceVnd?: SortOrder
    status?: SortOrder
    errorReported?: SortOrder
    replacement?: SortOrder
    adminNote?: SortOrder
    rejectedAt?: SortOrder
    replacedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductLineItemAvgOrderByAggregateInput = {
    priceVnd?: SortOrder
  }

  export type ProductLineItemMaxOrderByAggregateInput = {
    id?: SortOrder
    productLogId?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    content?: SortOrder
    priceVnd?: SortOrder
    status?: SortOrder
    errorReported?: SortOrder
    replacement?: SortOrder
    adminNote?: SortOrder
    rejectedAt?: SortOrder
    replacedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductLineItemMinOrderByAggregateInput = {
    id?: SortOrder
    productLogId?: SortOrder
    orderId?: SortOrder
    productName?: SortOrder
    content?: SortOrder
    priceVnd?: SortOrder
    status?: SortOrder
    errorReported?: SortOrder
    replacement?: SortOrder
    adminNote?: SortOrder
    rejectedAt?: SortOrder
    replacedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductLineItemSumOrderByAggregateInput = {
    priceVnd?: SortOrder
  }

  export type EnumProductLineStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLineStatus | EnumProductLineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLineStatus[]
    notIn?: $Enums.ProductLineStatus[]
    not?: NestedEnumProductLineStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductLineStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductLineStatusFilter<$PrismaModel>
    _max?: NestedEnumProductLineStatusFilter<$PrismaModel>
  }

  export type DownloadLogListRelationFilter = {
    every?: DownloadLogWhereInput
    some?: DownloadLogWhereInput
    none?: DownloadLogWhereInput
  }

  export type DownloadLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelevanceInput = {
    fields: FileOrderByRelevanceFieldEnum | FileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    s3Key?: SortOrder
    size?: SortOrder
    checksum?: SortOrder
    createdAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    s3Key?: SortOrder
    size?: SortOrder
    checksum?: SortOrder
    createdAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    s3Key?: SortOrder
    size?: SortOrder
    checksum?: SortOrder
    createdAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumLicenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusFilter<$PrismaModel> | $Enums.LicenseStatus
  }

  export type LicenseOrderByRelevanceInput = {
    fields: LicenseOrderByRelevanceFieldEnum | LicenseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LicenseCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    codeOrJwt?: SortOrder
    status?: SortOrder
    boundEmail?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    codeOrJwt?: SortOrder
    status?: SortOrder
    boundEmail?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    codeOrJwt?: SortOrder
    status?: SortOrder
    boundEmail?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLicenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelevanceInput = {
    fields: OrderOrderByRelevanceFieldEnum | OrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
    couponCode?: SortOrder
    currency?: SortOrder
    itemsJson?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
    couponCode?: SortOrder
    currency?: SortOrder
    itemsJson?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
    couponCode?: SortOrder
    currency?: SortOrder
    itemsJson?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalAmountVnd?: SortOrder
    discountVnd?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type OrderItemOrderByRelevanceInput = {
    fields: OrderItemOrderByRelevanceFieldEnum | OrderItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceVnd?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    priceVnd?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceVnd?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceVnd?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    priceVnd?: SortOrder
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    providerTxid?: SortOrder
    amountVnd?: SortOrder
    rawJson?: SortOrder
    matchedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amountVnd?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    providerTxid?: SortOrder
    amountVnd?: SortOrder
    rawJson?: SortOrder
    matchedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    provider?: SortOrder
    providerTxid?: SortOrder
    amountVnd?: SortOrder
    rawJson?: SortOrder
    matchedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amountVnd?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type EnumDepositStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[]
    notIn?: $Enums.DepositStatus[]
    not?: NestedEnumDepositStatusFilter<$PrismaModel> | $Enums.DepositStatus
  }

  export type ManualDepositRequestOrderByRelevanceInput = {
    fields: ManualDepositRequestOrderByRelevanceFieldEnum | ManualDepositRequestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ManualDepositRequestCountOrderByAggregateInput = {
    id?: SortOrder
    internalId?: SortOrder
    userId?: SortOrder
    amountVnd?: SortOrder
    note?: SortOrder
    qrCode?: SortOrder
    transferContent?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    decidedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualDepositRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    amountVnd?: SortOrder
  }

  export type ManualDepositRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    internalId?: SortOrder
    userId?: SortOrder
    amountVnd?: SortOrder
    note?: SortOrder
    qrCode?: SortOrder
    transferContent?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    decidedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualDepositRequestMinOrderByAggregateInput = {
    id?: SortOrder
    internalId?: SortOrder
    userId?: SortOrder
    amountVnd?: SortOrder
    note?: SortOrder
    qrCode?: SortOrder
    transferContent?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    decidedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualDepositRequestSumOrderByAggregateInput = {
    id?: SortOrder
    amountVnd?: SortOrder
  }

  export type EnumDepositStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[]
    notIn?: $Enums.DepositStatus[]
    not?: NestedEnumDepositStatusWithAggregatesFilter<$PrismaModel> | $Enums.DepositStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositStatusFilter<$PrismaModel>
    _max?: NestedEnumDepositStatusFilter<$PrismaModel>
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CouponOrderByRelevanceInput = {
    fields: CouponOrderByRelevanceFieldEnum | CouponOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    discountValue?: SortOrder
    maxDiscountVnd?: SortOrder
    minOrderVnd?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SettingsOrderByRelevanceInput = {
    fields: SettingsOrderByRelevanceFieldEnum | SettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    websiteName?: SortOrder
    websiteTitle?: SortOrder
    websiteDescription?: SortOrder
    websiteKeywords?: SortOrder
    websiteLogo?: SortOrder
    websiteFavicon?: SortOrder
    copyrightYear?: SortOrder
    supportEmail?: SortOrder
    contactInfo?: SortOrder
    paymentMethods?: SortOrder
    bankInfo?: SortOrder
    topupRules?: SortOrder
    tpbankConfig?: SortOrder
    depositBonusTiers?: SortOrder
    referralSettings?: SortOrder
    uiTexts?: SortOrder
    themeSettings?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    websiteName?: SortOrder
    websiteTitle?: SortOrder
    websiteDescription?: SortOrder
    websiteKeywords?: SortOrder
    websiteLogo?: SortOrder
    websiteFavicon?: SortOrder
    copyrightYear?: SortOrder
    supportEmail?: SortOrder
    contactInfo?: SortOrder
    paymentMethods?: SortOrder
    bankInfo?: SortOrder
    topupRules?: SortOrder
    tpbankConfig?: SortOrder
    depositBonusTiers?: SortOrder
    referralSettings?: SortOrder
    uiTexts?: SortOrder
    themeSettings?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    websiteName?: SortOrder
    websiteTitle?: SortOrder
    websiteDescription?: SortOrder
    websiteKeywords?: SortOrder
    websiteLogo?: SortOrder
    websiteFavicon?: SortOrder
    copyrightYear?: SortOrder
    supportEmail?: SortOrder
    contactInfo?: SortOrder
    paymentMethods?: SortOrder
    bankInfo?: SortOrder
    topupRules?: SortOrder
    tpbankConfig?: SortOrder
    depositBonusTiers?: SortOrder
    referralSettings?: SortOrder
    uiTexts?: SortOrder
    themeSettings?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileNullableScalarRelationFilter = {
    is?: FileWhereInput | null
    isNot?: FileWhereInput | null
  }

  export type DownloadLogOrderByRelevanceInput = {
    fields: DownloadLogOrderByRelevanceFieldEnum | DownloadLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DownloadLogCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fileId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type DownloadLogMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fileId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type DownloadLogMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    fileId?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminActionLogOrderByRelevanceInput = {
    fields: AdminActionLogOrderByRelevanceFieldEnum | AdminActionLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminActionLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    diffJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminActionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    diffJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminActionLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    diffJson?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWalletTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[]
    notIn?: $Enums.WalletTransactionType[]
    not?: NestedEnumWalletTransactionTypeFilter<$PrismaModel> | $Enums.WalletTransactionType
  }

  export type WalletTransactionOrderByRelevanceInput = {
    fields: WalletTransactionOrderByRelevanceFieldEnum | WalletTransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amountVnd?: SortOrder
    balanceAfterVnd?: SortOrder
  }

  export type EnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[]
    notIn?: $Enums.WalletTransactionType[]
    not?: NestedEnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.WalletTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
  }

  export type WebsiteSettingsOrderByRelevanceInput = {
    fields: WebsiteSettingsOrderByRelevanceFieldEnum | WebsiteSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebsiteSettingsCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSettingsMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteSettingsMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAutoTopupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoTopupStatus | EnumAutoTopupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoTopupStatus[]
    notIn?: $Enums.AutoTopupStatus[]
    not?: NestedEnumAutoTopupStatusFilter<$PrismaModel> | $Enums.AutoTopupStatus
  }

  export type AutoTopupLogOrderByRelevanceInput = {
    fields: AutoTopupLogOrderByRelevanceFieldEnum | AutoTopupLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AutoTopupLogCountOrderByAggregateInput = {
    id?: SortOrder
    bankTransactionId?: SortOrder
    bankName?: SortOrder
    depositRequestId?: SortOrder
    userId?: SortOrder
    topupCode?: SortOrder
    amountVnd?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AutoTopupLogAvgOrderByAggregateInput = {
    depositRequestId?: SortOrder
    amountVnd?: SortOrder
  }

  export type AutoTopupLogMaxOrderByAggregateInput = {
    id?: SortOrder
    bankTransactionId?: SortOrder
    bankName?: SortOrder
    depositRequestId?: SortOrder
    userId?: SortOrder
    topupCode?: SortOrder
    amountVnd?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AutoTopupLogMinOrderByAggregateInput = {
    id?: SortOrder
    bankTransactionId?: SortOrder
    bankName?: SortOrder
    depositRequestId?: SortOrder
    userId?: SortOrder
    topupCode?: SortOrder
    amountVnd?: SortOrder
    description?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    transactionDate?: SortOrder
    createdAt?: SortOrder
  }

  export type AutoTopupLogSumOrderByAggregateInput = {
    depositRequestId?: SortOrder
    amountVnd?: SortOrder
  }

  export type EnumAutoTopupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoTopupStatus | EnumAutoTopupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoTopupStatus[]
    notIn?: $Enums.AutoTopupStatus[]
    not?: NestedEnumAutoTopupStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutoTopupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutoTopupStatusFilter<$PrismaModel>
    _max?: NestedEnumAutoTopupStatusFilter<$PrismaModel>
  }

  export type ReferralOrderByRelevanceInput = {
    fields: ReferralOrderByRelevanceFieldEnum | ReferralOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    rewardPaid?: SortOrder
    rewardPaidAt?: SortOrder
    firstDepositVnd?: SortOrder
    firstDepositAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    firstDepositVnd?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    rewardPaid?: SortOrder
    rewardPaidAt?: SortOrder
    firstDepositVnd?: SortOrder
    firstDepositAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    referralCode?: SortOrder
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    rewardPaid?: SortOrder
    rewardPaidAt?: SortOrder
    firstDepositVnd?: SortOrder
    firstDepositAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    referrerRewardVnd?: SortOrder
    refereeRewardVnd?: SortOrder
    firstDepositVnd?: SortOrder
  }

  export type UserActivityLogOrderByRelevanceInput = {
    fields: UserActivityLogOrderByRelevanceFieldEnum | UserActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    metadata?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    metadata?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type UserActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    metadata?: SortOrder
    ip?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type TwoFactorAccountOrderByRelevanceInput = {
    fields: TwoFactorAccountOrderByRelevanceFieldEnum | TwoFactorAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TwoFactorAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    issuer?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetTokenOrderByRelevanceInput = {
    fields: PasswordResetTokenOrderByRelevanceFieldEnum | PasswordResetTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    used?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    used?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    used?: SortOrder
  }

  export type EnumAdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[]
    notIn?: $Enums.AdType[]
    not?: NestedEnumAdTypeFilter<$PrismaModel> | $Enums.AdType
  }

  export type EnumAdPlacementFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPlacement | EnumAdPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPlacement[]
    notIn?: $Enums.AdPlacement[]
    not?: NestedEnumAdPlacementFilter<$PrismaModel> | $Enums.AdPlacement
  }

  export type AdvertisementOrderByRelevanceInput = {
    fields: AdvertisementOrderByRelevanceFieldEnum | AdvertisementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdvertisementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placement?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    clickUrl?: SortOrder
    order?: SortOrder
    enabled?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvertisementAvgOrderByAggregateInput = {
    order?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type AdvertisementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placement?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    clickUrl?: SortOrder
    order?: SortOrder
    enabled?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvertisementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    placement?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    clickUrl?: SortOrder
    order?: SortOrder
    enabled?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdvertisementSumOrderByAggregateInput = {
    order?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
  }

  export type EnumAdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[]
    notIn?: $Enums.AdType[]
    not?: NestedEnumAdTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdTypeFilter<$PrismaModel>
    _max?: NestedEnumAdTypeFilter<$PrismaModel>
  }

  export type EnumAdPlacementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPlacement | EnumAdPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPlacement[]
    notIn?: $Enums.AdPlacement[]
    not?: NestedEnumAdPlacementWithAggregatesFilter<$PrismaModel> | $Enums.AdPlacement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdPlacementFilter<$PrismaModel>
    _max?: NestedEnumAdPlacementFilter<$PrismaModel>
  }

  export type EnumSystemLogActionFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemLogAction | EnumSystemLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.SystemLogAction[]
    notIn?: $Enums.SystemLogAction[]
    not?: NestedEnumSystemLogActionFilter<$PrismaModel> | $Enums.SystemLogAction
  }

  export type SystemLogOrderByRelevanceInput = {
    fields: SystemLogOrderByRelevanceFieldEnum | SystemLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumSystemLogActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemLogAction | EnumSystemLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.SystemLogAction[]
    notIn?: $Enums.SystemLogAction[]
    not?: NestedEnumSystemLogActionWithAggregatesFilter<$PrismaModel> | $Enums.SystemLogAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSystemLogActionFilter<$PrismaModel>
    _max?: NestedEnumSystemLogActionFilter<$PrismaModel>
  }

  export type EnumErrorReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorReportStatus | EnumErrorReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorReportStatus[]
    notIn?: $Enums.ErrorReportStatus[]
    not?: NestedEnumErrorReportStatusFilter<$PrismaModel> | $Enums.ErrorReportStatus
  }

  export type ErrorReportOrderByRelevanceInput = {
    fields: ErrorReportOrderByRelevanceFieldEnum | ErrorReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ErrorReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    orderId?: SortOrder
    productLineId?: SortOrder
    productName?: SortOrder
    originalContent?: SortOrder
    userNote?: SortOrder
    status?: SortOrder
    reportedProducts?: SortOrder
    adminNote?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ErrorReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    orderId?: SortOrder
    productLineId?: SortOrder
    productName?: SortOrder
    originalContent?: SortOrder
    userNote?: SortOrder
    status?: SortOrder
    reportedProducts?: SortOrder
    adminNote?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ErrorReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userEmail?: SortOrder
    orderId?: SortOrder
    productLineId?: SortOrder
    productName?: SortOrder
    originalContent?: SortOrder
    userNote?: SortOrder
    status?: SortOrder
    reportedProducts?: SortOrder
    adminNote?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumErrorReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorReportStatus | EnumErrorReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorReportStatus[]
    notIn?: $Enums.ErrorReportStatus[]
    not?: NestedEnumErrorReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ErrorReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumErrorReportStatusFilter<$PrismaModel>
    _max?: NestedEnumErrorReportStatusFilter<$PrismaModel>
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[]
    notIn?: $Enums.ReviewStatus[]
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type ReviewOrderByRelevanceInput = {
    fields: ReviewOrderByRelevanceFieldEnum | ReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReviewUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    orderId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    adminNote?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[]
    notIn?: $Enums.ReviewStatus[]
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type BannerOrderByRelevanceInput = {
    fields: BannerOrderByRelevanceFieldEnum | BannerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    imageUrl?: SortOrder
    gradientFrom?: SortOrder
    gradientTo?: SortOrder
    features?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    imageUrl?: SortOrder
    gradientFrom?: SortOrder
    gradientTo?: SortOrder
    features?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    buttonText?: SortOrder
    buttonLink?: SortOrder
    imageUrl?: SortOrder
    gradientFrom?: SortOrder
    gradientTo?: SortOrder
    features?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FeaturedUserOrderByRelevanceInput = {
    fields: FeaturedUserOrderByRelevanceFieldEnum | FeaturedUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeaturedUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sales?: SortOrder
    rating?: SortOrder
    avatarUrl?: SortOrder
    rank?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedUserAvgOrderByAggregateInput = {
    sales?: SortOrder
    rating?: SortOrder
    rank?: SortOrder
  }

  export type FeaturedUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sales?: SortOrder
    rating?: SortOrder
    avatarUrl?: SortOrder
    rank?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sales?: SortOrder
    rating?: SortOrder
    avatarUrl?: SortOrder
    rank?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedUserSumOrderByAggregateInput = {
    sales?: SortOrder
    rating?: SortOrder
    rank?: SortOrder
  }

  export type SearchKeywordOrderByRelevanceInput = {
    fields: SearchKeywordOrderByRelevanceFieldEnum | SearchKeywordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SearchKeywordCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    subtitle?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchKeywordAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SearchKeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    subtitle?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchKeywordMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    subtitle?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchKeywordSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ManualDepositRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<ManualDepositRequestCreateWithoutUserInput, ManualDepositRequestUncheckedCreateWithoutUserInput> | ManualDepositRequestCreateWithoutUserInput[] | ManualDepositRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ManualDepositRequestCreateOrConnectWithoutUserInput | ManualDepositRequestCreateOrConnectWithoutUserInput[]
    createMany?: ManualDepositRequestCreateManyUserInputEnvelope
    connect?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
  }

  export type AdminActionLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActionLogCreateWithoutAdminInput, AdminActionLogUncheckedCreateWithoutAdminInput> | AdminActionLogCreateWithoutAdminInput[] | AdminActionLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionLogCreateOrConnectWithoutAdminInput | AdminActionLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActionLogCreateManyAdminInputEnvelope
    connect?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
  }

  export type ProductLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductLogCreateWithoutUserInput, ProductLogUncheckedCreateWithoutUserInput> | ProductLogCreateWithoutUserInput[] | ProductLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutUserInput | ProductLogCreateOrConnectWithoutUserInput[]
    createMany?: ProductLogCreateManyUserInputEnvelope
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
  }

  export type TwoFactorAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorAccountCreateWithoutUserInput, TwoFactorAccountUncheckedCreateWithoutUserInput> | TwoFactorAccountCreateWithoutUserInput[] | TwoFactorAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAccountCreateOrConnectWithoutUserInput | TwoFactorAccountCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorAccountCreateManyUserInputEnvelope
    connect?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    connect?: ReferralWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ManualDepositRequestCreateWithoutUserInput, ManualDepositRequestUncheckedCreateWithoutUserInput> | ManualDepositRequestCreateWithoutUserInput[] | ManualDepositRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ManualDepositRequestCreateOrConnectWithoutUserInput | ManualDepositRequestCreateOrConnectWithoutUserInput[]
    createMany?: ManualDepositRequestCreateManyUserInputEnvelope
    connect?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
  }

  export type AdminActionLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActionLogCreateWithoutAdminInput, AdminActionLogUncheckedCreateWithoutAdminInput> | AdminActionLogCreateWithoutAdminInput[] | AdminActionLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionLogCreateOrConnectWithoutAdminInput | AdminActionLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActionLogCreateManyAdminInputEnvelope
    connect?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
  }

  export type ProductLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductLogCreateWithoutUserInput, ProductLogUncheckedCreateWithoutUserInput> | ProductLogCreateWithoutUserInput[] | ProductLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutUserInput | ProductLogCreateOrConnectWithoutUserInput[]
    createMany?: ProductLogCreateManyUserInputEnvelope
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
  }

  export type TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorAccountCreateWithoutUserInput, TwoFactorAccountUncheckedCreateWithoutUserInput> | TwoFactorAccountCreateWithoutUserInput[] | TwoFactorAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAccountCreateOrConnectWithoutUserInput | TwoFactorAccountCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorAccountCreateManyUserInputEnvelope
    connect?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    connect?: ReferralWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ManualDepositRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ManualDepositRequestCreateWithoutUserInput, ManualDepositRequestUncheckedCreateWithoutUserInput> | ManualDepositRequestCreateWithoutUserInput[] | ManualDepositRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ManualDepositRequestCreateOrConnectWithoutUserInput | ManualDepositRequestCreateOrConnectWithoutUserInput[]
    upsert?: ManualDepositRequestUpsertWithWhereUniqueWithoutUserInput | ManualDepositRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ManualDepositRequestCreateManyUserInputEnvelope
    set?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    disconnect?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    delete?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    connect?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    update?: ManualDepositRequestUpdateWithWhereUniqueWithoutUserInput | ManualDepositRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ManualDepositRequestUpdateManyWithWhereWithoutUserInput | ManualDepositRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ManualDepositRequestScalarWhereInput | ManualDepositRequestScalarWhereInput[]
  }

  export type AdminActionLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActionLogCreateWithoutAdminInput, AdminActionLogUncheckedCreateWithoutAdminInput> | AdminActionLogCreateWithoutAdminInput[] | AdminActionLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionLogCreateOrConnectWithoutAdminInput | AdminActionLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActionLogUpsertWithWhereUniqueWithoutAdminInput | AdminActionLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActionLogCreateManyAdminInputEnvelope
    set?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    disconnect?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    delete?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    connect?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    update?: AdminActionLogUpdateWithWhereUniqueWithoutAdminInput | AdminActionLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActionLogUpdateManyWithWhereWithoutAdminInput | AdminActionLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActionLogScalarWhereInput | AdminActionLogScalarWhereInput[]
  }

  export type ProductLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductLogCreateWithoutUserInput, ProductLogUncheckedCreateWithoutUserInput> | ProductLogCreateWithoutUserInput[] | ProductLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutUserInput | ProductLogCreateOrConnectWithoutUserInput[]
    upsert?: ProductLogUpsertWithWhereUniqueWithoutUserInput | ProductLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductLogCreateManyUserInputEnvelope
    set?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    disconnect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    delete?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    update?: ProductLogUpdateWithWhereUniqueWithoutUserInput | ProductLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductLogUpdateManyWithWhereWithoutUserInput | ProductLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
  }

  export type TwoFactorAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorAccountCreateWithoutUserInput, TwoFactorAccountUncheckedCreateWithoutUserInput> | TwoFactorAccountCreateWithoutUserInput[] | TwoFactorAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAccountCreateOrConnectWithoutUserInput | TwoFactorAccountCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorAccountUpsertWithWhereUniqueWithoutUserInput | TwoFactorAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorAccountCreateManyUserInputEnvelope
    set?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    disconnect?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    delete?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    connect?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    update?: TwoFactorAccountUpdateWithWhereUniqueWithoutUserInput | TwoFactorAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorAccountUpdateManyWithWhereWithoutUserInput | TwoFactorAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorAccountScalarWhereInput | TwoFactorAccountScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    upsert?: ReferralUpsertWithoutRefereeInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutRefereeInput, ReferralUpdateWithoutRefereeInput>, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ManualDepositRequestCreateWithoutUserInput, ManualDepositRequestUncheckedCreateWithoutUserInput> | ManualDepositRequestCreateWithoutUserInput[] | ManualDepositRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ManualDepositRequestCreateOrConnectWithoutUserInput | ManualDepositRequestCreateOrConnectWithoutUserInput[]
    upsert?: ManualDepositRequestUpsertWithWhereUniqueWithoutUserInput | ManualDepositRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ManualDepositRequestCreateManyUserInputEnvelope
    set?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    disconnect?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    delete?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    connect?: ManualDepositRequestWhereUniqueInput | ManualDepositRequestWhereUniqueInput[]
    update?: ManualDepositRequestUpdateWithWhereUniqueWithoutUserInput | ManualDepositRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ManualDepositRequestUpdateManyWithWhereWithoutUserInput | ManualDepositRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ManualDepositRequestScalarWhereInput | ManualDepositRequestScalarWhereInput[]
  }

  export type AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActionLogCreateWithoutAdminInput, AdminActionLogUncheckedCreateWithoutAdminInput> | AdminActionLogCreateWithoutAdminInput[] | AdminActionLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionLogCreateOrConnectWithoutAdminInput | AdminActionLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActionLogUpsertWithWhereUniqueWithoutAdminInput | AdminActionLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActionLogCreateManyAdminInputEnvelope
    set?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    disconnect?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    delete?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    connect?: AdminActionLogWhereUniqueInput | AdminActionLogWhereUniqueInput[]
    update?: AdminActionLogUpdateWithWhereUniqueWithoutAdminInput | AdminActionLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActionLogUpdateManyWithWhereWithoutAdminInput | AdminActionLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActionLogScalarWhereInput | AdminActionLogScalarWhereInput[]
  }

  export type ProductLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductLogCreateWithoutUserInput, ProductLogUncheckedCreateWithoutUserInput> | ProductLogCreateWithoutUserInput[] | ProductLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutUserInput | ProductLogCreateOrConnectWithoutUserInput[]
    upsert?: ProductLogUpsertWithWhereUniqueWithoutUserInput | ProductLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductLogCreateManyUserInputEnvelope
    set?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    disconnect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    delete?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    update?: ProductLogUpdateWithWhereUniqueWithoutUserInput | ProductLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductLogUpdateManyWithWhereWithoutUserInput | ProductLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
  }

  export type TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorAccountCreateWithoutUserInput, TwoFactorAccountUncheckedCreateWithoutUserInput> | TwoFactorAccountCreateWithoutUserInput[] | TwoFactorAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorAccountCreateOrConnectWithoutUserInput | TwoFactorAccountCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorAccountUpsertWithWhereUniqueWithoutUserInput | TwoFactorAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorAccountCreateManyUserInputEnvelope
    set?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    disconnect?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    delete?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    connect?: TwoFactorAccountWhereUniqueInput | TwoFactorAccountWhereUniqueInput[]
    update?: TwoFactorAccountUpdateWithWhereUniqueWithoutUserInput | TwoFactorAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorAccountUpdateManyWithWhereWithoutUserInput | TwoFactorAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorAccountScalarWhereInput | TwoFactorAccountScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    upsert?: ReferralUpsertWithoutRefereeInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutRefereeInput, ReferralUpdateWithoutRefereeInput>, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductLogCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductLogCreateWithoutProductInput, ProductLogUncheckedCreateWithoutProductInput> | ProductLogCreateWithoutProductInput[] | ProductLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutProductInput | ProductLogCreateOrConnectWithoutProductInput[]
    createMany?: ProductLogCreateManyProductInputEnvelope
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutProductInput = {
    create?: XOR<FileCreateWithoutProductInput, FileUncheckedCreateWithoutProductInput> | FileCreateWithoutProductInput[] | FileUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProductInput | FileCreateOrConnectWithoutProductInput[]
    createMany?: FileCreateManyProductInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type LicenseCreateNestedManyWithoutProductInput = {
    create?: XOR<LicenseCreateWithoutProductInput, LicenseUncheckedCreateWithoutProductInput> | LicenseCreateWithoutProductInput[] | LicenseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutProductInput | LicenseCreateOrConnectWithoutProductInput[]
    createMany?: LicenseCreateManyProductInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductLogUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductLogCreateWithoutProductInput, ProductLogUncheckedCreateWithoutProductInput> | ProductLogCreateWithoutProductInput[] | ProductLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutProductInput | ProductLogCreateOrConnectWithoutProductInput[]
    createMany?: ProductLogCreateManyProductInputEnvelope
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<FileCreateWithoutProductInput, FileUncheckedCreateWithoutProductInput> | FileCreateWithoutProductInput[] | FileUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProductInput | FileCreateOrConnectWithoutProductInput[]
    createMany?: FileCreateManyProductInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type LicenseUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<LicenseCreateWithoutProductInput, LicenseUncheckedCreateWithoutProductInput> | LicenseCreateWithoutProductInput[] | LicenseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutProductInput | LicenseCreateOrConnectWithoutProductInput[]
    createMany?: LicenseCreateManyProductInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductLogUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductLogCreateWithoutProductInput, ProductLogUncheckedCreateWithoutProductInput> | ProductLogCreateWithoutProductInput[] | ProductLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutProductInput | ProductLogCreateOrConnectWithoutProductInput[]
    upsert?: ProductLogUpsertWithWhereUniqueWithoutProductInput | ProductLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductLogCreateManyProductInputEnvelope
    set?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    disconnect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    delete?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    update?: ProductLogUpdateWithWhereUniqueWithoutProductInput | ProductLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductLogUpdateManyWithWhereWithoutProductInput | ProductLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
  }

  export type FileUpdateManyWithoutProductNestedInput = {
    create?: XOR<FileCreateWithoutProductInput, FileUncheckedCreateWithoutProductInput> | FileCreateWithoutProductInput[] | FileUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProductInput | FileCreateOrConnectWithoutProductInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutProductInput | FileUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FileCreateManyProductInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutProductInput | FileUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FileUpdateManyWithWhereWithoutProductInput | FileUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type LicenseUpdateManyWithoutProductNestedInput = {
    create?: XOR<LicenseCreateWithoutProductInput, LicenseUncheckedCreateWithoutProductInput> | LicenseCreateWithoutProductInput[] | LicenseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutProductInput | LicenseCreateOrConnectWithoutProductInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutProductInput | LicenseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: LicenseCreateManyProductInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutProductInput | LicenseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutProductInput | LicenseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductLogUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductLogCreateWithoutProductInput, ProductLogUncheckedCreateWithoutProductInput> | ProductLogCreateWithoutProductInput[] | ProductLogUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutProductInput | ProductLogCreateOrConnectWithoutProductInput[]
    upsert?: ProductLogUpsertWithWhereUniqueWithoutProductInput | ProductLogUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductLogCreateManyProductInputEnvelope
    set?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    disconnect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    delete?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    update?: ProductLogUpdateWithWhereUniqueWithoutProductInput | ProductLogUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductLogUpdateManyWithWhereWithoutProductInput | ProductLogUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<FileCreateWithoutProductInput, FileUncheckedCreateWithoutProductInput> | FileCreateWithoutProductInput[] | FileUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FileCreateOrConnectWithoutProductInput | FileCreateOrConnectWithoutProductInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutProductInput | FileUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FileCreateManyProductInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutProductInput | FileUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FileUpdateManyWithWhereWithoutProductInput | FileUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type LicenseUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<LicenseCreateWithoutProductInput, LicenseUncheckedCreateWithoutProductInput> | LicenseCreateWithoutProductInput[] | LicenseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutProductInput | LicenseCreateOrConnectWithoutProductInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutProductInput | LicenseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: LicenseCreateManyProductInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutProductInput | LicenseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutProductInput | LicenseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductLogsInput = {
    create?: XOR<ProductCreateWithoutProductLogsInput, ProductUncheckedCreateWithoutProductLogsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductLogsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProductLogsInput = {
    create?: XOR<UserCreateWithoutProductLogsInput, UserUncheckedCreateWithoutProductLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductLogsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutProductLogsInput = {
    create?: XOR<OrderCreateWithoutProductLogsInput, OrderUncheckedCreateWithoutProductLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductLogsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductLineItemCreateNestedManyWithoutProductLogInput = {
    create?: XOR<ProductLineItemCreateWithoutProductLogInput, ProductLineItemUncheckedCreateWithoutProductLogInput> | ProductLineItemCreateWithoutProductLogInput[] | ProductLineItemUncheckedCreateWithoutProductLogInput[]
    connectOrCreate?: ProductLineItemCreateOrConnectWithoutProductLogInput | ProductLineItemCreateOrConnectWithoutProductLogInput[]
    createMany?: ProductLineItemCreateManyProductLogInputEnvelope
    connect?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
  }

  export type ProductLineItemUncheckedCreateNestedManyWithoutProductLogInput = {
    create?: XOR<ProductLineItemCreateWithoutProductLogInput, ProductLineItemUncheckedCreateWithoutProductLogInput> | ProductLineItemCreateWithoutProductLogInput[] | ProductLineItemUncheckedCreateWithoutProductLogInput[]
    connectOrCreate?: ProductLineItemCreateOrConnectWithoutProductLogInput | ProductLineItemCreateOrConnectWithoutProductLogInput[]
    createMany?: ProductLineItemCreateManyProductLogInputEnvelope
    connect?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductLogsNestedInput = {
    create?: XOR<ProductCreateWithoutProductLogsInput, ProductUncheckedCreateWithoutProductLogsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductLogsInput
    upsert?: ProductUpsertWithoutProductLogsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductLogsInput, ProductUpdateWithoutProductLogsInput>, ProductUncheckedUpdateWithoutProductLogsInput>
  }

  export type UserUpdateOneRequiredWithoutProductLogsNestedInput = {
    create?: XOR<UserCreateWithoutProductLogsInput, UserUncheckedCreateWithoutProductLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductLogsInput
    upsert?: UserUpsertWithoutProductLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductLogsInput, UserUpdateWithoutProductLogsInput>, UserUncheckedUpdateWithoutProductLogsInput>
  }

  export type OrderUpdateOneRequiredWithoutProductLogsNestedInput = {
    create?: XOR<OrderCreateWithoutProductLogsInput, OrderUncheckedCreateWithoutProductLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductLogsInput
    upsert?: OrderUpsertWithoutProductLogsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutProductLogsInput, OrderUpdateWithoutProductLogsInput>, OrderUncheckedUpdateWithoutProductLogsInput>
  }

  export type ProductLineItemUpdateManyWithoutProductLogNestedInput = {
    create?: XOR<ProductLineItemCreateWithoutProductLogInput, ProductLineItemUncheckedCreateWithoutProductLogInput> | ProductLineItemCreateWithoutProductLogInput[] | ProductLineItemUncheckedCreateWithoutProductLogInput[]
    connectOrCreate?: ProductLineItemCreateOrConnectWithoutProductLogInput | ProductLineItemCreateOrConnectWithoutProductLogInput[]
    upsert?: ProductLineItemUpsertWithWhereUniqueWithoutProductLogInput | ProductLineItemUpsertWithWhereUniqueWithoutProductLogInput[]
    createMany?: ProductLineItemCreateManyProductLogInputEnvelope
    set?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    disconnect?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    delete?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    connect?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    update?: ProductLineItemUpdateWithWhereUniqueWithoutProductLogInput | ProductLineItemUpdateWithWhereUniqueWithoutProductLogInput[]
    updateMany?: ProductLineItemUpdateManyWithWhereWithoutProductLogInput | ProductLineItemUpdateManyWithWhereWithoutProductLogInput[]
    deleteMany?: ProductLineItemScalarWhereInput | ProductLineItemScalarWhereInput[]
  }

  export type ProductLineItemUncheckedUpdateManyWithoutProductLogNestedInput = {
    create?: XOR<ProductLineItemCreateWithoutProductLogInput, ProductLineItemUncheckedCreateWithoutProductLogInput> | ProductLineItemCreateWithoutProductLogInput[] | ProductLineItemUncheckedCreateWithoutProductLogInput[]
    connectOrCreate?: ProductLineItemCreateOrConnectWithoutProductLogInput | ProductLineItemCreateOrConnectWithoutProductLogInput[]
    upsert?: ProductLineItemUpsertWithWhereUniqueWithoutProductLogInput | ProductLineItemUpsertWithWhereUniqueWithoutProductLogInput[]
    createMany?: ProductLineItemCreateManyProductLogInputEnvelope
    set?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    disconnect?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    delete?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    connect?: ProductLineItemWhereUniqueInput | ProductLineItemWhereUniqueInput[]
    update?: ProductLineItemUpdateWithWhereUniqueWithoutProductLogInput | ProductLineItemUpdateWithWhereUniqueWithoutProductLogInput[]
    updateMany?: ProductLineItemUpdateManyWithWhereWithoutProductLogInput | ProductLineItemUpdateManyWithWhereWithoutProductLogInput[]
    deleteMany?: ProductLineItemScalarWhereInput | ProductLineItemScalarWhereInput[]
  }

  export type ProductLogCreateNestedOneWithoutProductLinesInput = {
    create?: XOR<ProductLogCreateWithoutProductLinesInput, ProductLogUncheckedCreateWithoutProductLinesInput>
    connectOrCreate?: ProductLogCreateOrConnectWithoutProductLinesInput
    connect?: ProductLogWhereUniqueInput
  }

  export type EnumProductLineStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductLineStatus
  }

  export type ProductLogUpdateOneRequiredWithoutProductLinesNestedInput = {
    create?: XOR<ProductLogCreateWithoutProductLinesInput, ProductLogUncheckedCreateWithoutProductLinesInput>
    connectOrCreate?: ProductLogCreateOrConnectWithoutProductLinesInput
    upsert?: ProductLogUpsertWithoutProductLinesInput
    connect?: ProductLogWhereUniqueInput
    update?: XOR<XOR<ProductLogUpdateToOneWithWhereWithoutProductLinesInput, ProductLogUpdateWithoutProductLinesInput>, ProductLogUncheckedUpdateWithoutProductLinesInput>
  }

  export type ProductCreateNestedOneWithoutFilesInput = {
    create?: XOR<ProductCreateWithoutFilesInput, ProductUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFilesInput
    connect?: ProductWhereUniqueInput
  }

  export type DownloadLogCreateNestedManyWithoutFileInput = {
    create?: XOR<DownloadLogCreateWithoutFileInput, DownloadLogUncheckedCreateWithoutFileInput> | DownloadLogCreateWithoutFileInput[] | DownloadLogUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutFileInput | DownloadLogCreateOrConnectWithoutFileInput[]
    createMany?: DownloadLogCreateManyFileInputEnvelope
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
  }

  export type DownloadLogUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<DownloadLogCreateWithoutFileInput, DownloadLogUncheckedCreateWithoutFileInput> | DownloadLogCreateWithoutFileInput[] | DownloadLogUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutFileInput | DownloadLogCreateOrConnectWithoutFileInput[]
    createMany?: DownloadLogCreateManyFileInputEnvelope
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<ProductCreateWithoutFilesInput, ProductUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFilesInput
    upsert?: ProductUpsertWithoutFilesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFilesInput, ProductUpdateWithoutFilesInput>, ProductUncheckedUpdateWithoutFilesInput>
  }

  export type DownloadLogUpdateManyWithoutFileNestedInput = {
    create?: XOR<DownloadLogCreateWithoutFileInput, DownloadLogUncheckedCreateWithoutFileInput> | DownloadLogCreateWithoutFileInput[] | DownloadLogUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutFileInput | DownloadLogCreateOrConnectWithoutFileInput[]
    upsert?: DownloadLogUpsertWithWhereUniqueWithoutFileInput | DownloadLogUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DownloadLogCreateManyFileInputEnvelope
    set?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    disconnect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    delete?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    update?: DownloadLogUpdateWithWhereUniqueWithoutFileInput | DownloadLogUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DownloadLogUpdateManyWithWhereWithoutFileInput | DownloadLogUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DownloadLogScalarWhereInput | DownloadLogScalarWhereInput[]
  }

  export type DownloadLogUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<DownloadLogCreateWithoutFileInput, DownloadLogUncheckedCreateWithoutFileInput> | DownloadLogCreateWithoutFileInput[] | DownloadLogUncheckedCreateWithoutFileInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutFileInput | DownloadLogCreateOrConnectWithoutFileInput[]
    upsert?: DownloadLogUpsertWithWhereUniqueWithoutFileInput | DownloadLogUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: DownloadLogCreateManyFileInputEnvelope
    set?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    disconnect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    delete?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    update?: DownloadLogUpdateWithWhereUniqueWithoutFileInput | DownloadLogUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: DownloadLogUpdateManyWithWhereWithoutFileInput | DownloadLogUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: DownloadLogScalarWhereInput | DownloadLogScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutLicensesInput = {
    create?: XOR<ProductCreateWithoutLicensesInput, ProductUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutLicensesInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumLicenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LicenseStatus
  }

  export type ProductUpdateOneRequiredWithoutLicensesNestedInput = {
    create?: XOR<ProductCreateWithoutLicensesInput, ProductUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutLicensesInput
    upsert?: ProductUpsertWithoutLicensesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutLicensesInput, ProductUpdateWithoutLicensesInput>, ProductUncheckedUpdateWithoutLicensesInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DownloadLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<DownloadLogCreateWithoutOrderInput, DownloadLogUncheckedCreateWithoutOrderInput> | DownloadLogCreateWithoutOrderInput[] | DownloadLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutOrderInput | DownloadLogCreateOrConnectWithoutOrderInput[]
    createMany?: DownloadLogCreateManyOrderInputEnvelope
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
  }

  export type ProductLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<ProductLogCreateWithoutOrderInput, ProductLogUncheckedCreateWithoutOrderInput> | ProductLogCreateWithoutOrderInput[] | ProductLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutOrderInput | ProductLogCreateOrConnectWithoutOrderInput[]
    createMany?: ProductLogCreateManyOrderInputEnvelope
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DownloadLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DownloadLogCreateWithoutOrderInput, DownloadLogUncheckedCreateWithoutOrderInput> | DownloadLogCreateWithoutOrderInput[] | DownloadLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutOrderInput | DownloadLogCreateOrConnectWithoutOrderInput[]
    createMany?: DownloadLogCreateManyOrderInputEnvelope
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
  }

  export type ProductLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ProductLogCreateWithoutOrderInput, ProductLogUncheckedCreateWithoutOrderInput> | ProductLogCreateWithoutOrderInput[] | ProductLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutOrderInput | ProductLogCreateOrConnectWithoutOrderInput[]
    createMany?: ProductLogCreateManyOrderInputEnvelope
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DownloadLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DownloadLogCreateWithoutOrderInput, DownloadLogUncheckedCreateWithoutOrderInput> | DownloadLogCreateWithoutOrderInput[] | DownloadLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutOrderInput | DownloadLogCreateOrConnectWithoutOrderInput[]
    upsert?: DownloadLogUpsertWithWhereUniqueWithoutOrderInput | DownloadLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DownloadLogCreateManyOrderInputEnvelope
    set?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    disconnect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    delete?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    update?: DownloadLogUpdateWithWhereUniqueWithoutOrderInput | DownloadLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DownloadLogUpdateManyWithWhereWithoutOrderInput | DownloadLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DownloadLogScalarWhereInput | DownloadLogScalarWhereInput[]
  }

  export type ProductLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ProductLogCreateWithoutOrderInput, ProductLogUncheckedCreateWithoutOrderInput> | ProductLogCreateWithoutOrderInput[] | ProductLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutOrderInput | ProductLogCreateOrConnectWithoutOrderInput[]
    upsert?: ProductLogUpsertWithWhereUniqueWithoutOrderInput | ProductLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ProductLogCreateManyOrderInputEnvelope
    set?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    disconnect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    delete?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    update?: ProductLogUpdateWithWhereUniqueWithoutOrderInput | ProductLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ProductLogUpdateManyWithWhereWithoutOrderInput | ProductLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderInput | ReviewUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderInput | ReviewUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderInput | ReviewUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DownloadLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DownloadLogCreateWithoutOrderInput, DownloadLogUncheckedCreateWithoutOrderInput> | DownloadLogCreateWithoutOrderInput[] | DownloadLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DownloadLogCreateOrConnectWithoutOrderInput | DownloadLogCreateOrConnectWithoutOrderInput[]
    upsert?: DownloadLogUpsertWithWhereUniqueWithoutOrderInput | DownloadLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DownloadLogCreateManyOrderInputEnvelope
    set?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    disconnect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    delete?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    connect?: DownloadLogWhereUniqueInput | DownloadLogWhereUniqueInput[]
    update?: DownloadLogUpdateWithWhereUniqueWithoutOrderInput | DownloadLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DownloadLogUpdateManyWithWhereWithoutOrderInput | DownloadLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DownloadLogScalarWhereInput | DownloadLogScalarWhereInput[]
  }

  export type ProductLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ProductLogCreateWithoutOrderInput, ProductLogUncheckedCreateWithoutOrderInput> | ProductLogCreateWithoutOrderInput[] | ProductLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ProductLogCreateOrConnectWithoutOrderInput | ProductLogCreateOrConnectWithoutOrderInput[]
    upsert?: ProductLogUpsertWithWhereUniqueWithoutOrderInput | ProductLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ProductLogCreateManyOrderInputEnvelope
    set?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    disconnect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    delete?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    connect?: ProductLogWhereUniqueInput | ProductLogWhereUniqueInput[]
    update?: ProductLogUpdateWithWhereUniqueWithoutOrderInput | ProductLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ProductLogUpdateManyWithWhereWithoutOrderInput | ProductLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput> | ReviewCreateWithoutOrderInput[] | ReviewUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutOrderInput | ReviewCreateOrConnectWithoutOrderInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutOrderInput | ReviewUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReviewCreateManyOrderInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutOrderInput | ReviewUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutOrderInput | ReviewUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutDepositRequestsInput = {
    create?: XOR<UserCreateWithoutDepositRequestsInput, UserUncheckedCreateWithoutDepositRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDepositStatusFieldUpdateOperationsInput = {
    set?: $Enums.DepositStatus
  }

  export type UserUpdateOneRequiredWithoutDepositRequestsNestedInput = {
    create?: XOR<UserCreateWithoutDepositRequestsInput, UserUncheckedCreateWithoutDepositRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepositRequestsInput
    upsert?: UserUpsertWithoutDepositRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepositRequestsInput, UserUpdateWithoutDepositRequestsInput>, UserUncheckedUpdateWithoutDepositRequestsInput>
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderCreateNestedOneWithoutDownloadLogsInput = {
    create?: XOR<OrderCreateWithoutDownloadLogsInput, OrderUncheckedCreateWithoutDownloadLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDownloadLogsInput
    connect?: OrderWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutDownloadLogsInput = {
    create?: XOR<FileCreateWithoutDownloadLogsInput, FileUncheckedCreateWithoutDownloadLogsInput>
    connectOrCreate?: FileCreateOrConnectWithoutDownloadLogsInput
    connect?: FileWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutDownloadLogsNestedInput = {
    create?: XOR<OrderCreateWithoutDownloadLogsInput, OrderUncheckedCreateWithoutDownloadLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDownloadLogsInput
    upsert?: OrderUpsertWithoutDownloadLogsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDownloadLogsInput, OrderUpdateWithoutDownloadLogsInput>, OrderUncheckedUpdateWithoutDownloadLogsInput>
  }

  export type FileUpdateOneWithoutDownloadLogsNestedInput = {
    create?: XOR<FileCreateWithoutDownloadLogsInput, FileUncheckedCreateWithoutDownloadLogsInput>
    connectOrCreate?: FileCreateOrConnectWithoutDownloadLogsInput
    upsert?: FileUpsertWithoutDownloadLogsInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutDownloadLogsInput, FileUpdateWithoutDownloadLogsInput>, FileUncheckedUpdateWithoutDownloadLogsInput>
  }

  export type UserCreateNestedOneWithoutAdminActionsInput = {
    create?: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminActionsNestedInput = {
    create?: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActionsInput
    upsert?: UserUpsertWithoutAdminActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminActionsInput, UserUpdateWithoutAdminActionsInput>, UserUncheckedUpdateWithoutAdminActionsInput>
  }

  export type EnumWalletTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.WalletTransactionType
  }

  export type EnumAutoTopupStatusFieldUpdateOperationsInput = {
    set?: $Enums.AutoTopupStatus
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateOneRequiredWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput
    upsert?: UserUpsertWithoutReferredByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredByInput, UserUpdateWithoutReferredByInput>, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorAccountsInput = {
    create?: XOR<UserCreateWithoutTwoFactorAccountsInput, UserUncheckedCreateWithoutTwoFactorAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorAccountsNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorAccountsInput, UserUncheckedCreateWithoutTwoFactorAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorAccountsInput
    upsert?: UserUpsertWithoutTwoFactorAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFactorAccountsInput, UserUpdateWithoutTwoFactorAccountsInput>, UserUncheckedUpdateWithoutTwoFactorAccountsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type EnumAdTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdType
  }

  export type EnumAdPlacementFieldUpdateOperationsInput = {
    set?: $Enums.AdPlacement
  }

  export type EnumSystemLogActionFieldUpdateOperationsInput = {
    set?: $Enums.SystemLogAction
  }

  export type EnumErrorReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ErrorReportStatus
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutReviewsInput = {
    create?: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewsInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type OrderUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReviewsInput
    upsert?: OrderUpsertWithoutReviewsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReviewsInput, OrderUpdateWithoutReviewsInput>, OrderUncheckedUpdateWithoutReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumProductLineStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLineStatus | EnumProductLineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLineStatus[]
    notIn?: $Enums.ProductLineStatus[]
    not?: NestedEnumProductLineStatusFilter<$PrismaModel> | $Enums.ProductLineStatus
  }

  export type NestedEnumProductLineStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductLineStatus | EnumProductLineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductLineStatus[]
    notIn?: $Enums.ProductLineStatus[]
    not?: NestedEnumProductLineStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductLineStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductLineStatusFilter<$PrismaModel>
    _max?: NestedEnumProductLineStatusFilter<$PrismaModel>
  }

  export type NestedEnumLicenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusFilter<$PrismaModel> | $Enums.LicenseStatus
  }

  export type NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumDepositStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[]
    notIn?: $Enums.DepositStatus[]
    not?: NestedEnumDepositStatusFilter<$PrismaModel> | $Enums.DepositStatus
  }

  export type NestedEnumDepositStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[]
    notIn?: $Enums.DepositStatus[]
    not?: NestedEnumDepositStatusWithAggregatesFilter<$PrismaModel> | $Enums.DepositStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositStatusFilter<$PrismaModel>
    _max?: NestedEnumDepositStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumWalletTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[]
    notIn?: $Enums.WalletTransactionType[]
    not?: NestedEnumWalletTransactionTypeFilter<$PrismaModel> | $Enums.WalletTransactionType
  }

  export type NestedEnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[]
    notIn?: $Enums.WalletTransactionType[]
    not?: NestedEnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.WalletTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAutoTopupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoTopupStatus | EnumAutoTopupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoTopupStatus[]
    notIn?: $Enums.AutoTopupStatus[]
    not?: NestedEnumAutoTopupStatusFilter<$PrismaModel> | $Enums.AutoTopupStatus
  }

  export type NestedEnumAutoTopupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AutoTopupStatus | EnumAutoTopupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AutoTopupStatus[]
    notIn?: $Enums.AutoTopupStatus[]
    not?: NestedEnumAutoTopupStatusWithAggregatesFilter<$PrismaModel> | $Enums.AutoTopupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAutoTopupStatusFilter<$PrismaModel>
    _max?: NestedEnumAutoTopupStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[]
    notIn?: $Enums.AdType[]
    not?: NestedEnumAdTypeFilter<$PrismaModel> | $Enums.AdType
  }

  export type NestedEnumAdPlacementFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPlacement | EnumAdPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPlacement[]
    notIn?: $Enums.AdPlacement[]
    not?: NestedEnumAdPlacementFilter<$PrismaModel> | $Enums.AdPlacement
  }

  export type NestedEnumAdTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdType | EnumAdTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdType[]
    notIn?: $Enums.AdType[]
    not?: NestedEnumAdTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdTypeFilter<$PrismaModel>
    _max?: NestedEnumAdTypeFilter<$PrismaModel>
  }

  export type NestedEnumAdPlacementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdPlacement | EnumAdPlacementFieldRefInput<$PrismaModel>
    in?: $Enums.AdPlacement[]
    notIn?: $Enums.AdPlacement[]
    not?: NestedEnumAdPlacementWithAggregatesFilter<$PrismaModel> | $Enums.AdPlacement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdPlacementFilter<$PrismaModel>
    _max?: NestedEnumAdPlacementFilter<$PrismaModel>
  }

  export type NestedEnumSystemLogActionFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemLogAction | EnumSystemLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.SystemLogAction[]
    notIn?: $Enums.SystemLogAction[]
    not?: NestedEnumSystemLogActionFilter<$PrismaModel> | $Enums.SystemLogAction
  }

  export type NestedEnumSystemLogActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SystemLogAction | EnumSystemLogActionFieldRefInput<$PrismaModel>
    in?: $Enums.SystemLogAction[]
    notIn?: $Enums.SystemLogAction[]
    not?: NestedEnumSystemLogActionWithAggregatesFilter<$PrismaModel> | $Enums.SystemLogAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSystemLogActionFilter<$PrismaModel>
    _max?: NestedEnumSystemLogActionFilter<$PrismaModel>
  }

  export type NestedEnumErrorReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorReportStatus | EnumErrorReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorReportStatus[]
    notIn?: $Enums.ErrorReportStatus[]
    not?: NestedEnumErrorReportStatusFilter<$PrismaModel> | $Enums.ErrorReportStatus
  }

  export type NestedEnumErrorReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ErrorReportStatus | EnumErrorReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ErrorReportStatus[]
    notIn?: $Enums.ErrorReportStatus[]
    not?: NestedEnumErrorReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ErrorReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumErrorReportStatusFilter<$PrismaModel>
    _max?: NestedEnumErrorReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[]
    notIn?: $Enums.ReviewStatus[]
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[]
    notIn?: $Enums.ReviewStatus[]
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    balanceVnd?: number
    updatedAt?: Date | string
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    balanceVnd?: number
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ManualDepositRequestCreateWithoutUserInput = {
    internalId?: string | null
    amountVnd: number
    note?: string | null
    qrCode?: string | null
    transferContent?: string | null
    status?: $Enums.DepositStatus
    adminNote?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ManualDepositRequestUncheckedCreateWithoutUserInput = {
    id?: number
    internalId?: string | null
    amountVnd: number
    note?: string | null
    qrCode?: string | null
    transferContent?: string | null
    status?: $Enums.DepositStatus
    adminNote?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ManualDepositRequestCreateOrConnectWithoutUserInput = {
    where: ManualDepositRequestWhereUniqueInput
    create: XOR<ManualDepositRequestCreateWithoutUserInput, ManualDepositRequestUncheckedCreateWithoutUserInput>
  }

  export type ManualDepositRequestCreateManyUserInputEnvelope = {
    data: ManualDepositRequestCreateManyUserInput | ManualDepositRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminActionLogCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType?: string | null
    targetId?: string | null
    diffJson?: string | null
    createdAt?: Date | string
  }

  export type AdminActionLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType?: string | null
    targetId?: string | null
    diffJson?: string | null
    createdAt?: Date | string
  }

  export type AdminActionLogCreateOrConnectWithoutAdminInput = {
    where: AdminActionLogWhereUniqueInput
    create: XOR<AdminActionLogCreateWithoutAdminInput, AdminActionLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminActionLogCreateManyAdminInputEnvelope = {
    data: AdminActionLogCreateManyAdminInput | AdminActionLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ProductLogCreateWithoutUserInput = {
    id?: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductLogsInput
    order: OrderCreateNestedOneWithoutProductLogsInput
    productLines?: ProductLineItemCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    productLines?: ProductLineItemUncheckedCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogCreateOrConnectWithoutUserInput = {
    where: ProductLogWhereUniqueInput
    create: XOR<ProductLogCreateWithoutUserInput, ProductLogUncheckedCreateWithoutUserInput>
  }

  export type ProductLogCreateManyUserInputEnvelope = {
    data: ProductLogCreateManyUserInput | ProductLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorAccountCreateWithoutUserInput = {
    id?: string
    name: string
    issuer: string
    secret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAccountUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    issuer: string
    secret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorAccountCreateOrConnectWithoutUserInput = {
    where: TwoFactorAccountWhereUniqueInput
    create: XOR<TwoFactorAccountCreateWithoutUserInput, TwoFactorAccountUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorAccountCreateManyUserInputEnvelope = {
    data: TwoFactorAccountCreateManyUserInput | TwoFactorAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    used?: boolean
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    used?: boolean
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
    referee: UserCreateNestedOneWithoutReferredByInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    refereeId: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutRefereeInput = {
    id?: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutRefereeInput = {
    id?: string
    referrerId: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutReviewsInput
    order: OrderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    orderId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceVnd?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceVnd?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmountVnd?: FloatFilter<"Order"> | number
    discountVnd?: FloatFilter<"Order"> | number
    couponCode?: StringNullableFilter<"Order"> | string | null
    currency?: StringFilter<"Order"> | string
    itemsJson?: StringFilter<"Order"> | string
    paymentMethod?: EnumPaymentMethodFilter<"Order"> | $Enums.PaymentMethod
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ManualDepositRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: ManualDepositRequestWhereUniqueInput
    update: XOR<ManualDepositRequestUpdateWithoutUserInput, ManualDepositRequestUncheckedUpdateWithoutUserInput>
    create: XOR<ManualDepositRequestCreateWithoutUserInput, ManualDepositRequestUncheckedCreateWithoutUserInput>
  }

  export type ManualDepositRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: ManualDepositRequestWhereUniqueInput
    data: XOR<ManualDepositRequestUpdateWithoutUserInput, ManualDepositRequestUncheckedUpdateWithoutUserInput>
  }

  export type ManualDepositRequestUpdateManyWithWhereWithoutUserInput = {
    where: ManualDepositRequestScalarWhereInput
    data: XOR<ManualDepositRequestUpdateManyMutationInput, ManualDepositRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type ManualDepositRequestScalarWhereInput = {
    AND?: ManualDepositRequestScalarWhereInput | ManualDepositRequestScalarWhereInput[]
    OR?: ManualDepositRequestScalarWhereInput[]
    NOT?: ManualDepositRequestScalarWhereInput | ManualDepositRequestScalarWhereInput[]
    id?: IntFilter<"ManualDepositRequest"> | number
    internalId?: StringNullableFilter<"ManualDepositRequest"> | string | null
    userId?: StringFilter<"ManualDepositRequest"> | string
    amountVnd?: FloatFilter<"ManualDepositRequest"> | number
    note?: StringNullableFilter<"ManualDepositRequest"> | string | null
    qrCode?: StringNullableFilter<"ManualDepositRequest"> | string | null
    transferContent?: StringNullableFilter<"ManualDepositRequest"> | string | null
    status?: EnumDepositStatusFilter<"ManualDepositRequest"> | $Enums.DepositStatus
    adminNote?: StringNullableFilter<"ManualDepositRequest"> | string | null
    decidedAt?: DateTimeNullableFilter<"ManualDepositRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"ManualDepositRequest"> | Date | string
  }

  export type AdminActionLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminActionLogWhereUniqueInput
    update: XOR<AdminActionLogUpdateWithoutAdminInput, AdminActionLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminActionLogCreateWithoutAdminInput, AdminActionLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminActionLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminActionLogWhereUniqueInput
    data: XOR<AdminActionLogUpdateWithoutAdminInput, AdminActionLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminActionLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminActionLogScalarWhereInput
    data: XOR<AdminActionLogUpdateManyMutationInput, AdminActionLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminActionLogScalarWhereInput = {
    AND?: AdminActionLogScalarWhereInput | AdminActionLogScalarWhereInput[]
    OR?: AdminActionLogScalarWhereInput[]
    NOT?: AdminActionLogScalarWhereInput | AdminActionLogScalarWhereInput[]
    id?: StringFilter<"AdminActionLog"> | string
    adminId?: StringFilter<"AdminActionLog"> | string
    action?: StringFilter<"AdminActionLog"> | string
    targetType?: StringNullableFilter<"AdminActionLog"> | string | null
    targetId?: StringNullableFilter<"AdminActionLog"> | string | null
    diffJson?: StringNullableFilter<"AdminActionLog"> | string | null
    createdAt?: DateTimeFilter<"AdminActionLog"> | Date | string
  }

  export type ProductLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductLogWhereUniqueInput
    update: XOR<ProductLogUpdateWithoutUserInput, ProductLogUncheckedUpdateWithoutUserInput>
    create: XOR<ProductLogCreateWithoutUserInput, ProductLogUncheckedCreateWithoutUserInput>
  }

  export type ProductLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductLogWhereUniqueInput
    data: XOR<ProductLogUpdateWithoutUserInput, ProductLogUncheckedUpdateWithoutUserInput>
  }

  export type ProductLogUpdateManyWithWhereWithoutUserInput = {
    where: ProductLogScalarWhereInput
    data: XOR<ProductLogUpdateManyMutationInput, ProductLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductLogScalarWhereInput = {
    AND?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
    OR?: ProductLogScalarWhereInput[]
    NOT?: ProductLogScalarWhereInput | ProductLogScalarWhereInput[]
    id?: StringFilter<"ProductLog"> | string
    productId?: StringFilter<"ProductLog"> | string
    userId?: StringFilter<"ProductLog"> | string
    orderId?: StringFilter<"ProductLog"> | string
    action?: StringFilter<"ProductLog"> | string
    quantity?: IntFilter<"ProductLog"> | number
    lineIndices?: StringNullableFilter<"ProductLog"> | string | null
    content?: StringNullableFilter<"ProductLog"> | string | null
    notes?: StringNullableFilter<"ProductLog"> | string | null
    createdAt?: DateTimeFilter<"ProductLog"> | Date | string
  }

  export type TwoFactorAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFactorAccountWhereUniqueInput
    update: XOR<TwoFactorAccountUpdateWithoutUserInput, TwoFactorAccountUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorAccountCreateWithoutUserInput, TwoFactorAccountUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFactorAccountWhereUniqueInput
    data: XOR<TwoFactorAccountUpdateWithoutUserInput, TwoFactorAccountUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorAccountUpdateManyWithWhereWithoutUserInput = {
    where: TwoFactorAccountScalarWhereInput
    data: XOR<TwoFactorAccountUpdateManyMutationInput, TwoFactorAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFactorAccountScalarWhereInput = {
    AND?: TwoFactorAccountScalarWhereInput | TwoFactorAccountScalarWhereInput[]
    OR?: TwoFactorAccountScalarWhereInput[]
    NOT?: TwoFactorAccountScalarWhereInput | TwoFactorAccountScalarWhereInput[]
    id?: StringFilter<"TwoFactorAccount"> | string
    userId?: StringFilter<"TwoFactorAccount"> | string
    name?: StringFilter<"TwoFactorAccount"> | string
    issuer?: StringFilter<"TwoFactorAccount"> | string
    secret?: StringFilter<"TwoFactorAccount"> | string
    createdAt?: DateTimeFilter<"TwoFactorAccount"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactorAccount"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    used?: BoolFilter<"PasswordResetToken"> | boolean
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringFilter<"Referral"> | string
    referralCode?: StringFilter<"Referral"> | string
    referrerRewardVnd?: FloatFilter<"Referral"> | number
    refereeRewardVnd?: FloatFilter<"Referral"> | number
    rewardPaid?: BoolFilter<"Referral"> | boolean
    rewardPaidAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    firstDepositVnd?: FloatNullableFilter<"Referral"> | number | null
    firstDepositAt?: DateTimeNullableFilter<"Referral"> | Date | string | null
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithoutRefereeInput = {
    update: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutRefereeInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    orderId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    isAnonymous?: BoolFilter<"Review"> | boolean
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    adminNote?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productLogs?: ProductLogCreateNestedManyWithoutProductInput
    files?: FileCreateNestedManyWithoutProductInput
    licenses?: LicenseCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutProductInput
    files?: FileUncheckedCreateNestedManyWithoutProductInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    categoryId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    priceVnd?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    fileUrl?: StringNullableFilter<"Product"> | string | null
    fileName?: StringNullableFilter<"Product"> | string | null
    totalLines?: IntFilter<"Product"> | number
    usedLines?: IntFilter<"Product"> | number
    images?: StringNullableFilter<"Product"> | string | null
    active?: BoolFilter<"Product"> | boolean
    fakeSold?: IntFilter<"Product"> | number
    fakeRating?: FloatFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    icon?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity?: number
    priceVnd: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity?: number
    priceVnd: number
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductLogCreateWithoutProductInput = {
    id?: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProductLogsInput
    order: OrderCreateNestedOneWithoutProductLogsInput
    productLines?: ProductLineItemCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    productLines?: ProductLineItemUncheckedCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogCreateOrConnectWithoutProductInput = {
    where: ProductLogWhereUniqueInput
    create: XOR<ProductLogCreateWithoutProductInput, ProductLogUncheckedCreateWithoutProductInput>
  }

  export type ProductLogCreateManyProductInputEnvelope = {
    data: ProductLogCreateManyProductInput | ProductLogCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutProductInput = {
    id?: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
    downloadLogs?: DownloadLogCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutProductInput = {
    id?: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutProductInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutProductInput, FileUncheckedCreateWithoutProductInput>
  }

  export type FileCreateManyProductInputEnvelope = {
    data: FileCreateManyProductInput | FileCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type LicenseCreateWithoutProductInput = {
    id?: string
    codeOrJwt: string
    status?: $Enums.LicenseStatus
    boundEmail?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LicenseUncheckedCreateWithoutProductInput = {
    id?: string
    codeOrJwt: string
    status?: $Enums.LicenseStatus
    boundEmail?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LicenseCreateOrConnectWithoutProductInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutProductInput, LicenseUncheckedCreateWithoutProductInput>
  }

  export type LicenseCreateManyProductInputEnvelope = {
    data: LicenseCreateManyProductInput | LicenseCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    order: OrderCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    orderId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    priceVnd?: FloatFilter<"OrderItem"> | number
  }

  export type ProductLogUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductLogWhereUniqueInput
    update: XOR<ProductLogUpdateWithoutProductInput, ProductLogUncheckedUpdateWithoutProductInput>
    create: XOR<ProductLogCreateWithoutProductInput, ProductLogUncheckedCreateWithoutProductInput>
  }

  export type ProductLogUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductLogWhereUniqueInput
    data: XOR<ProductLogUpdateWithoutProductInput, ProductLogUncheckedUpdateWithoutProductInput>
  }

  export type ProductLogUpdateManyWithWhereWithoutProductInput = {
    where: ProductLogScalarWhereInput
    data: XOR<ProductLogUpdateManyMutationInput, ProductLogUncheckedUpdateManyWithoutProductInput>
  }

  export type FileUpsertWithWhereUniqueWithoutProductInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutProductInput, FileUncheckedUpdateWithoutProductInput>
    create: XOR<FileCreateWithoutProductInput, FileUncheckedCreateWithoutProductInput>
  }

  export type FileUpdateWithWhereUniqueWithoutProductInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutProductInput, FileUncheckedUpdateWithoutProductInput>
  }

  export type FileUpdateManyWithWhereWithoutProductInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutProductInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    productId?: StringFilter<"File"> | string
    s3Key?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    checksum?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
  }

  export type LicenseUpsertWithWhereUniqueWithoutProductInput = {
    where: LicenseWhereUniqueInput
    update: XOR<LicenseUpdateWithoutProductInput, LicenseUncheckedUpdateWithoutProductInput>
    create: XOR<LicenseCreateWithoutProductInput, LicenseUncheckedCreateWithoutProductInput>
  }

  export type LicenseUpdateWithWhereUniqueWithoutProductInput = {
    where: LicenseWhereUniqueInput
    data: XOR<LicenseUpdateWithoutProductInput, LicenseUncheckedUpdateWithoutProductInput>
  }

  export type LicenseUpdateManyWithWhereWithoutProductInput = {
    where: LicenseScalarWhereInput
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyWithoutProductInput>
  }

  export type LicenseScalarWhereInput = {
    AND?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    OR?: LicenseScalarWhereInput[]
    NOT?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    id?: StringFilter<"License"> | string
    productId?: StringFilter<"License"> | string
    codeOrJwt?: StringFilter<"License"> | string
    status?: EnumLicenseStatusFilter<"License"> | $Enums.LicenseStatus
    boundEmail?: StringNullableFilter<"License"> | string | null
    issuedAt?: DateTimeNullableFilter<"License"> | Date | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutProductLogsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    files?: FileCreateNestedManyWithoutProductInput
    licenses?: LicenseCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductLogsInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    files?: FileUncheckedCreateNestedManyWithoutProductInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductLogsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductLogsInput, ProductUncheckedCreateWithoutProductLogsInput>
  }

  export type UserCreateWithoutProductLogsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductLogsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductLogsInput, UserUncheckedCreateWithoutProductLogsInput>
  }

  export type OrderCreateWithoutProductLogsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductLogsInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProductLogsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductLogsInput, OrderUncheckedCreateWithoutProductLogsInput>
  }

  export type ProductLineItemCreateWithoutProductLogInput = {
    id?: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status?: $Enums.ProductLineStatus
    errorReported?: boolean
    replacement?: string | null
    adminNote?: string | null
    rejectedAt?: Date | string | null
    replacedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductLineItemUncheckedCreateWithoutProductLogInput = {
    id?: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status?: $Enums.ProductLineStatus
    errorReported?: boolean
    replacement?: string | null
    adminNote?: string | null
    rejectedAt?: Date | string | null
    replacedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductLineItemCreateOrConnectWithoutProductLogInput = {
    where: ProductLineItemWhereUniqueInput
    create: XOR<ProductLineItemCreateWithoutProductLogInput, ProductLineItemUncheckedCreateWithoutProductLogInput>
  }

  export type ProductLineItemCreateManyProductLogInputEnvelope = {
    data: ProductLineItemCreateManyProductLogInput | ProductLineItemCreateManyProductLogInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductLogsInput = {
    update: XOR<ProductUpdateWithoutProductLogsInput, ProductUncheckedUpdateWithoutProductLogsInput>
    create: XOR<ProductCreateWithoutProductLogsInput, ProductUncheckedCreateWithoutProductLogsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductLogsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductLogsInput, ProductUncheckedUpdateWithoutProductLogsInput>
  }

  export type ProductUpdateWithoutProductLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    files?: FileUpdateManyWithoutProductNestedInput
    licenses?: LicenseUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    files?: FileUncheckedUpdateManyWithoutProductNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutProductLogsInput = {
    update: XOR<UserUpdateWithoutProductLogsInput, UserUncheckedUpdateWithoutProductLogsInput>
    create: XOR<UserCreateWithoutProductLogsInput, UserUncheckedCreateWithoutProductLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductLogsInput, UserUncheckedUpdateWithoutProductLogsInput>
  }

  export type UserUpdateWithoutProductLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithoutProductLogsInput = {
    update: XOR<OrderUpdateWithoutProductLogsInput, OrderUncheckedUpdateWithoutProductLogsInput>
    create: XOR<OrderCreateWithoutProductLogsInput, OrderUncheckedCreateWithoutProductLogsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutProductLogsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutProductLogsInput, OrderUncheckedUpdateWithoutProductLogsInput>
  }

  export type OrderUpdateWithoutProductLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductLineItemUpsertWithWhereUniqueWithoutProductLogInput = {
    where: ProductLineItemWhereUniqueInput
    update: XOR<ProductLineItemUpdateWithoutProductLogInput, ProductLineItemUncheckedUpdateWithoutProductLogInput>
    create: XOR<ProductLineItemCreateWithoutProductLogInput, ProductLineItemUncheckedCreateWithoutProductLogInput>
  }

  export type ProductLineItemUpdateWithWhereUniqueWithoutProductLogInput = {
    where: ProductLineItemWhereUniqueInput
    data: XOR<ProductLineItemUpdateWithoutProductLogInput, ProductLineItemUncheckedUpdateWithoutProductLogInput>
  }

  export type ProductLineItemUpdateManyWithWhereWithoutProductLogInput = {
    where: ProductLineItemScalarWhereInput
    data: XOR<ProductLineItemUpdateManyMutationInput, ProductLineItemUncheckedUpdateManyWithoutProductLogInput>
  }

  export type ProductLineItemScalarWhereInput = {
    AND?: ProductLineItemScalarWhereInput | ProductLineItemScalarWhereInput[]
    OR?: ProductLineItemScalarWhereInput[]
    NOT?: ProductLineItemScalarWhereInput | ProductLineItemScalarWhereInput[]
    id?: StringFilter<"ProductLineItem"> | string
    productLogId?: StringFilter<"ProductLineItem"> | string
    orderId?: StringFilter<"ProductLineItem"> | string
    productName?: StringFilter<"ProductLineItem"> | string
    content?: StringFilter<"ProductLineItem"> | string
    priceVnd?: FloatFilter<"ProductLineItem"> | number
    status?: EnumProductLineStatusFilter<"ProductLineItem"> | $Enums.ProductLineStatus
    errorReported?: BoolFilter<"ProductLineItem"> | boolean
    replacement?: StringNullableFilter<"ProductLineItem"> | string | null
    adminNote?: StringNullableFilter<"ProductLineItem"> | string | null
    rejectedAt?: DateTimeNullableFilter<"ProductLineItem"> | Date | string | null
    replacedAt?: DateTimeNullableFilter<"ProductLineItem"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductLineItem"> | Date | string
    updatedAt?: DateTimeFilter<"ProductLineItem"> | Date | string
  }

  export type ProductLogCreateWithoutProductLinesInput = {
    id?: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductLogsInput
    user: UserCreateNestedOneWithoutProductLogsInput
    order: OrderCreateNestedOneWithoutProductLogsInput
  }

  export type ProductLogUncheckedCreateWithoutProductLinesInput = {
    id?: string
    productId: string
    userId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ProductLogCreateOrConnectWithoutProductLinesInput = {
    where: ProductLogWhereUniqueInput
    create: XOR<ProductLogCreateWithoutProductLinesInput, ProductLogUncheckedCreateWithoutProductLinesInput>
  }

  export type ProductLogUpsertWithoutProductLinesInput = {
    update: XOR<ProductLogUpdateWithoutProductLinesInput, ProductLogUncheckedUpdateWithoutProductLinesInput>
    create: XOR<ProductLogCreateWithoutProductLinesInput, ProductLogUncheckedCreateWithoutProductLinesInput>
    where?: ProductLogWhereInput
  }

  export type ProductLogUpdateToOneWithWhereWithoutProductLinesInput = {
    where?: ProductLogWhereInput
    data: XOR<ProductLogUpdateWithoutProductLinesInput, ProductLogUncheckedUpdateWithoutProductLinesInput>
  }

  export type ProductLogUpdateWithoutProductLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductLogsNestedInput
    user?: UserUpdateOneRequiredWithoutProductLogsNestedInput
    order?: OrderUpdateOneRequiredWithoutProductLogsNestedInput
  }

  export type ProductLogUncheckedUpdateWithoutProductLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutFilesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productLogs?: ProductLogCreateNestedManyWithoutProductInput
    licenses?: LicenseCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFilesInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutProductInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFilesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFilesInput, ProductUncheckedCreateWithoutFilesInput>
  }

  export type DownloadLogCreateWithoutFileInput = {
    id?: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutDownloadLogsInput
  }

  export type DownloadLogUncheckedCreateWithoutFileInput = {
    id?: string
    orderId: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DownloadLogCreateOrConnectWithoutFileInput = {
    where: DownloadLogWhereUniqueInput
    create: XOR<DownloadLogCreateWithoutFileInput, DownloadLogUncheckedCreateWithoutFileInput>
  }

  export type DownloadLogCreateManyFileInputEnvelope = {
    data: DownloadLogCreateManyFileInput | DownloadLogCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutFilesInput = {
    update: XOR<ProductUpdateWithoutFilesInput, ProductUncheckedUpdateWithoutFilesInput>
    create: XOR<ProductCreateWithoutFilesInput, ProductUncheckedCreateWithoutFilesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFilesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFilesInput, ProductUncheckedUpdateWithoutFilesInput>
  }

  export type ProductUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUpdateManyWithoutProductNestedInput
    licenses?: LicenseUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutProductNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type DownloadLogUpsertWithWhereUniqueWithoutFileInput = {
    where: DownloadLogWhereUniqueInput
    update: XOR<DownloadLogUpdateWithoutFileInput, DownloadLogUncheckedUpdateWithoutFileInput>
    create: XOR<DownloadLogCreateWithoutFileInput, DownloadLogUncheckedCreateWithoutFileInput>
  }

  export type DownloadLogUpdateWithWhereUniqueWithoutFileInput = {
    where: DownloadLogWhereUniqueInput
    data: XOR<DownloadLogUpdateWithoutFileInput, DownloadLogUncheckedUpdateWithoutFileInput>
  }

  export type DownloadLogUpdateManyWithWhereWithoutFileInput = {
    where: DownloadLogScalarWhereInput
    data: XOR<DownloadLogUpdateManyMutationInput, DownloadLogUncheckedUpdateManyWithoutFileInput>
  }

  export type DownloadLogScalarWhereInput = {
    AND?: DownloadLogScalarWhereInput | DownloadLogScalarWhereInput[]
    OR?: DownloadLogScalarWhereInput[]
    NOT?: DownloadLogScalarWhereInput | DownloadLogScalarWhereInput[]
    id?: StringFilter<"DownloadLog"> | string
    orderId?: StringFilter<"DownloadLog"> | string
    fileId?: StringNullableFilter<"DownloadLog"> | string | null
    ip?: StringNullableFilter<"DownloadLog"> | string | null
    userAgent?: StringNullableFilter<"DownloadLog"> | string | null
    createdAt?: DateTimeFilter<"DownloadLog"> | Date | string
  }

  export type ProductCreateWithoutLicensesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productLogs?: ProductLogCreateNestedManyWithoutProductInput
    files?: FileCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutLicensesInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutProductInput
    files?: FileUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutLicensesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLicensesInput, ProductUncheckedCreateWithoutLicensesInput>
  }

  export type ProductUpsertWithoutLicensesInput = {
    update: XOR<ProductUpdateWithoutLicensesInput, ProductUncheckedUpdateWithoutLicensesInput>
    create: XOR<ProductCreateWithoutLicensesInput, ProductUncheckedCreateWithoutLicensesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutLicensesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutLicensesInput, ProductUncheckedUpdateWithoutLicensesInput>
  }

  export type ProductUpdateWithoutLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUpdateManyWithoutProductNestedInput
    files?: FileUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutProductNestedInput
    files?: FileUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    providerTxid?: string | null
    amountVnd: number
    rawJson?: string | null
    matchedBy?: string | null
    createdAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    providerTxid?: string | null
    amountVnd: number
    rawJson?: string | null
    matchedBy?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity?: number
    priceVnd: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity?: number
    priceVnd: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DownloadLogCreateWithoutOrderInput = {
    id?: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    file?: FileCreateNestedOneWithoutDownloadLogsInput
  }

  export type DownloadLogUncheckedCreateWithoutOrderInput = {
    id?: string
    fileId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DownloadLogCreateOrConnectWithoutOrderInput = {
    where: DownloadLogWhereUniqueInput
    create: XOR<DownloadLogCreateWithoutOrderInput, DownloadLogUncheckedCreateWithoutOrderInput>
  }

  export type DownloadLogCreateManyOrderInputEnvelope = {
    data: DownloadLogCreateManyOrderInput | DownloadLogCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ProductLogCreateWithoutOrderInput = {
    id?: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductLogsInput
    user: UserCreateNestedOneWithoutProductLogsInput
    productLines?: ProductLineItemCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    userId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
    productLines?: ProductLineItemUncheckedCreateNestedManyWithoutProductLogInput
  }

  export type ProductLogCreateOrConnectWithoutOrderInput = {
    where: ProductLogWhereUniqueInput
    create: XOR<ProductLogCreateWithoutOrderInput, ProductLogUncheckedCreateWithoutOrderInput>
  }

  export type ProductLogCreateManyOrderInputEnvelope = {
    data: ProductLogCreateManyOrderInput | ProductLogCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutOrderInput = {
    id?: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutOrderInput = {
    id?: string
    userId: string
    productId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type ReviewCreateManyOrderInputEnvelope = {
    data: ReviewCreateManyOrderInput | ReviewCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    provider?: EnumPaymentProviderFilter<"Payment"> | $Enums.PaymentProvider
    providerTxid?: StringNullableFilter<"Payment"> | string | null
    amountVnd?: FloatFilter<"Payment"> | number
    rawJson?: StringNullableFilter<"Payment"> | string | null
    matchedBy?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type DownloadLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: DownloadLogWhereUniqueInput
    update: XOR<DownloadLogUpdateWithoutOrderInput, DownloadLogUncheckedUpdateWithoutOrderInput>
    create: XOR<DownloadLogCreateWithoutOrderInput, DownloadLogUncheckedCreateWithoutOrderInput>
  }

  export type DownloadLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: DownloadLogWhereUniqueInput
    data: XOR<DownloadLogUpdateWithoutOrderInput, DownloadLogUncheckedUpdateWithoutOrderInput>
  }

  export type DownloadLogUpdateManyWithWhereWithoutOrderInput = {
    where: DownloadLogScalarWhereInput
    data: XOR<DownloadLogUpdateManyMutationInput, DownloadLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type ProductLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: ProductLogWhereUniqueInput
    update: XOR<ProductLogUpdateWithoutOrderInput, ProductLogUncheckedUpdateWithoutOrderInput>
    create: XOR<ProductLogCreateWithoutOrderInput, ProductLogUncheckedCreateWithoutOrderInput>
  }

  export type ProductLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: ProductLogWhereUniqueInput
    data: XOR<ProductLogUpdateWithoutOrderInput, ProductLogUncheckedUpdateWithoutOrderInput>
  }

  export type ProductLogUpdateManyWithWhereWithoutOrderInput = {
    where: ProductLogScalarWhereInput
    data: XOR<ProductLogUpdateManyMutationInput, ProductLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
    create: XOR<ReviewCreateWithoutOrderInput, ReviewUncheckedCreateWithoutOrderInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutOrderInput, ReviewUncheckedUpdateWithoutOrderInput>
  }

  export type ReviewUpdateManyWithWhereWithoutOrderInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    productLogs?: ProductLogCreateNestedManyWithoutProductInput
    files?: FileCreateNestedManyWithoutProductInput
    licenses?: LicenseCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutProductInput
    files?: FileUncheckedCreateNestedManyWithoutProductInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    productLogs?: ProductLogUpdateManyWithoutProductNestedInput
    files?: FileUpdateManyWithoutProductNestedInput
    licenses?: LicenseUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productLogs?: ProductLogUncheckedUpdateManyWithoutProductNestedInput
    files?: FileUncheckedUpdateManyWithoutProductNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutDepositRequestsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepositRequestsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepositRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepositRequestsInput, UserUncheckedCreateWithoutDepositRequestsInput>
  }

  export type UserUpsertWithoutDepositRequestsInput = {
    update: XOR<UserUpdateWithoutDepositRequestsInput, UserUncheckedUpdateWithoutDepositRequestsInput>
    create: XOR<UserCreateWithoutDepositRequestsInput, UserUncheckedCreateWithoutDepositRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepositRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepositRequestsInput, UserUncheckedUpdateWithoutDepositRequestsInput>
  }

  export type UserUpdateWithoutDepositRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepositRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutDownloadLogsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogCreateNestedManyWithoutOrderInput
    reviews?: ReviewCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDownloadLogsInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutOrderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDownloadLogsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDownloadLogsInput, OrderUncheckedCreateWithoutDownloadLogsInput>
  }

  export type FileCreateWithoutDownloadLogsInput = {
    id?: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutDownloadLogsInput = {
    id?: string
    productId: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutDownloadLogsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutDownloadLogsInput, FileUncheckedCreateWithoutDownloadLogsInput>
  }

  export type OrderUpsertWithoutDownloadLogsInput = {
    update: XOR<OrderUpdateWithoutDownloadLogsInput, OrderUncheckedUpdateWithoutDownloadLogsInput>
    create: XOR<OrderCreateWithoutDownloadLogsInput, OrderUncheckedCreateWithoutDownloadLogsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDownloadLogsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDownloadLogsInput, OrderUncheckedUpdateWithoutDownloadLogsInput>
  }

  export type OrderUpdateWithoutDownloadLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDownloadLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type FileUpsertWithoutDownloadLogsInput = {
    update: XOR<FileUpdateWithoutDownloadLogsInput, FileUncheckedUpdateWithoutDownloadLogsInput>
    create: XOR<FileCreateWithoutDownloadLogsInput, FileUncheckedCreateWithoutDownloadLogsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutDownloadLogsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutDownloadLogsInput, FileUncheckedUpdateWithoutDownloadLogsInput>
  }

  export type FileUpdateWithoutDownloadLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutDownloadLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAdminActionsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminActionsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
  }

  export type UserUpsertWithoutAdminActionsInput = {
    update: XOR<UserUpdateWithoutAdminActionsInput, UserUncheckedUpdateWithoutAdminActionsInput>
    create: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminActionsInput, UserUncheckedUpdateWithoutAdminActionsInput>
  }

  export type UserUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferredByInput = {
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTwoFactorAccountsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorAccountsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorAccountsInput, UserUncheckedCreateWithoutTwoFactorAccountsInput>
  }

  export type UserUpsertWithoutTwoFactorAccountsInput = {
    update: XOR<UserUpdateWithoutTwoFactorAccountsInput, UserUncheckedUpdateWithoutTwoFactorAccountsInput>
    create: XOR<UserCreateWithoutTwoFactorAccountsInput, UserUncheckedCreateWithoutTwoFactorAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFactorAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFactorAccountsInput, UserUncheckedUpdateWithoutTwoFactorAccountsInput>
  }

  export type UserUpdateWithoutTwoFactorAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletCreateNestedOneWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutRefereeInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    password: string
    role?: $Enums.UserRole
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referredById?: string | null
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    depositRequests?: ManualDepositRequestUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionLogUncheckedCreateNestedManyWithoutAdminInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutUserInput
    twoFactorAccounts?: TwoFactorAccountUncheckedCreateNestedManyWithoutUserInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productLogs?: ProductLogCreateNestedManyWithoutProductInput
    files?: FileCreateNestedManyWithoutProductInput
    licenses?: LicenseCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    categoryId?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutProductInput
    files?: FileUncheckedCreateNestedManyWithoutProductInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type OrderCreateWithoutReviewsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    downloadLogs?: DownloadLogUncheckedCreateNestedManyWithoutOrderInput
    productLogs?: ProductLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReviewsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUpdateOneWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutRefereeNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referredById?: NullableStringFieldUpdateOperationsInput | string | null
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    depositRequests?: ManualDepositRequestUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionLogUncheckedUpdateManyWithoutAdminNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutUserNestedInput
    twoFactorAccounts?: TwoFactorAccountUncheckedUpdateManyWithoutUserNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUpdateManyWithoutProductNestedInput
    files?: FileUpdateManyWithoutProductNestedInput
    licenses?: LicenseUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutProductNestedInput
    files?: FileUncheckedUpdateManyWithoutProductNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderUpsertWithoutReviewsInput = {
    update: XOR<OrderUpdateWithoutReviewsInput, OrderUncheckedUpdateWithoutReviewsInput>
    create: XOR<OrderCreateWithoutReviewsInput, OrderUncheckedCreateWithoutReviewsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReviewsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReviewsInput, OrderUncheckedUpdateWithoutReviewsInput>
  }

  export type OrderUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyUserInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmountVnd: number
    discountVnd?: number
    couponCode?: string | null
    currency?: string
    itemsJson: string
    paymentMethod?: $Enums.PaymentMethod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManualDepositRequestCreateManyUserInput = {
    id?: number
    internalId?: string | null
    amountVnd: number
    note?: string | null
    qrCode?: string | null
    transferContent?: string | null
    status?: $Enums.DepositStatus
    adminNote?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AdminActionLogCreateManyAdminInput = {
    id?: string
    action: string
    targetType?: string | null
    targetId?: string | null
    diffJson?: string | null
    createdAt?: Date | string
  }

  export type ProductLogCreateManyUserInput = {
    id?: string
    productId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type TwoFactorAccountCreateManyUserInput = {
    id?: string
    name: string
    issuer: string
    secret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    used?: boolean
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    refereeId: string
    referralCode: string
    referrerRewardVnd?: number
    refereeRewardVnd?: number
    rewardPaid?: boolean
    rewardPaidAt?: Date | string | null
    firstDepositVnd?: number | null
    firstDepositAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    productId: string
    orderId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutOrderNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutOrderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmountVnd?: FloatFieldUpdateOperationsInput | number
    discountVnd?: FloatFieldUpdateOperationsInput | number
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    itemsJson?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDepositRequestUpdateWithoutUserInput = {
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDepositRequestUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualDepositRequestUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    internalId?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    note?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    transferContent?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: NullableStringFieldUpdateOperationsInput | string | null
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    diffJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductLogsNestedInput
    order?: OrderUpdateOneRequiredWithoutProductLogsNestedInput
    productLines?: ProductLineItemUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productLines?: ProductLineItemUncheckedUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    issuer?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    referralCode?: StringFieldUpdateOperationsInput | string
    referrerRewardVnd?: FloatFieldUpdateOperationsInput | number
    refereeRewardVnd?: FloatFieldUpdateOperationsInput | number
    rewardPaid?: BoolFieldUpdateOperationsInput | boolean
    rewardPaidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstDepositVnd?: NullableFloatFieldUpdateOperationsInput | number | null
    firstDepositAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
    order?: OrderUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    priceVnd?: number
    stock?: number
    fileUrl?: string | null
    fileName?: string | null
    totalLines?: number
    usedLines?: number
    images?: string | null
    active?: boolean
    fakeSold?: number
    fakeRating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUpdateManyWithoutProductNestedInput
    files?: FileUpdateManyWithoutProductNestedInput
    licenses?: LicenseUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productLogs?: ProductLogUncheckedUpdateManyWithoutProductNestedInput
    files?: FileUncheckedUpdateManyWithoutProductNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceVnd?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    totalLines?: IntFieldUpdateOperationsInput | number
    usedLines?: IntFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    fakeSold?: IntFieldUpdateOperationsInput | number
    fakeRating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    quantity?: number
    priceVnd: number
  }

  export type ProductLogCreateManyProductInput = {
    id?: string
    userId: string
    orderId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type FileCreateManyProductInput = {
    id?: string
    s3Key: string
    size: number
    checksum?: string | null
    createdAt?: Date | string
  }

  export type LicenseCreateManyProductInput = {
    id?: string
    codeOrJwt: string
    status?: $Enums.LicenseStatus
    boundEmail?: string | null
    issuedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    userId: string
    orderId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductLogUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductLogsNestedInput
    order?: OrderUpdateOneRequiredWithoutProductLogsNestedInput
    productLines?: ProductLineItemUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productLines?: ProductLineItemUncheckedUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadLogs?: DownloadLogUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadLogs?: DownloadLogUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeOrJwt?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    boundEmail?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    order?: OrderUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLineItemCreateManyProductLogInput = {
    id?: string
    orderId: string
    productName: string
    content: string
    priceVnd: number
    status?: $Enums.ProductLineStatus
    errorReported?: boolean
    replacement?: string | null
    adminNote?: string | null
    rejectedAt?: Date | string | null
    replacedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductLineItemUpdateWithoutProductLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLineItemUncheckedUpdateWithoutProductLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLineItemUncheckedUpdateManyWithoutProductLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    priceVnd?: FloatFieldUpdateOperationsInput | number
    status?: EnumProductLineStatusFieldUpdateOperationsInput | $Enums.ProductLineStatus
    errorReported?: BoolFieldUpdateOperationsInput | boolean
    replacement?: NullableStringFieldUpdateOperationsInput | string | null
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadLogCreateManyFileInput = {
    id?: string
    orderId: string
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DownloadLogUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDownloadLogsNestedInput
  }

  export type DownloadLogUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadLogUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    provider: $Enums.PaymentProvider
    providerTxid?: string | null
    amountVnd: number
    rawJson?: string | null
    matchedBy?: string | null
    createdAt?: Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId: string
    quantity?: number
    priceVnd: number
  }

  export type DownloadLogCreateManyOrderInput = {
    id?: string
    fileId?: string | null
    ip?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ProductLogCreateManyOrderInput = {
    id?: string
    productId: string
    userId: string
    action: string
    quantity: number
    lineIndices?: string | null
    content?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyOrderInput = {
    id?: string
    userId: string
    productId: string
    rating: number
    comment?: string | null
    isAnonymous?: boolean
    status?: $Enums.ReviewStatus
    adminNote?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    providerTxid?: NullableStringFieldUpdateOperationsInput | string | null
    amountVnd?: FloatFieldUpdateOperationsInput | number
    rawJson?: NullableStringFieldUpdateOperationsInput | string | null
    matchedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceVnd?: FloatFieldUpdateOperationsInput | number
  }

  export type DownloadLogUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneWithoutDownloadLogsNestedInput
  }

  export type DownloadLogUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadLogUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductLogUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductLogsNestedInput
    user?: UserUpdateOneRequiredWithoutProductLogsNestedInput
    productLines?: ProductLineItemUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productLines?: ProductLineItemUncheckedUpdateManyWithoutProductLogNestedInput
  }

  export type ProductLogUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    lineIndices?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    adminNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}